<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/TiddlyWiki.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

  <meta name="description" content="1，分别用递归和非递归方式实现二叉树的遍历    题目：要求用非递归和递归方式分别按照先序、中序、后序遍历二叉树；约定先序遍历顺序为：根、左、右，中序：左、中、右，后序：左、右、中。    递归方式较为简单，代码如下：">
<meta name="keywords" content="二叉树">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树系列问题">
<meta property="og:url" content="http://yoursite.com/2018/08/26/第三章二叉树系列问题/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1，分别用递归和非递归方式实现二叉树的遍历    题目：要求用非递归和递归方式分别按照先序、中序、后序遍历二叉树；约定先序遍历顺序为：根、左、右，中序：左、中、右，后序：左、右、中。    递归方式较为简单，代码如下：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-09T14:32:04.917Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="二叉树系列问题">
<meta name="twitter:description" content="1，分别用递归和非递归方式实现二叉树的遍历    题目：要求用非递归和递归方式分别按照先序、中序、后序遍历二叉树；约定先序遍历顺序为：根、左、右，中序：左、中、右，后序：左、右、中。    递归方式较为简单，代码如下：">
  <link rel="canonical" href="http://yoursite.com/2018/08/26/第三章二叉树系列问题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>二叉树系列问题 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/ltt19921124" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; 
    top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
    </path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7
     120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6
      130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm">
      </path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6
       C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1
        176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9
         216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5
          157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8
           Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover
            .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes
             octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">50</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">22</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">107</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/第三章二叉树系列问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Move">
      <meta itemprop="description" content="hhh">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">二叉树系列问题

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-08-26 15:39:20" itemprop="dateCreated datePublished" datetime="2018-08-26T15:39:20+08:00">2018-08-26</time>
            </span>
          
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-09 22:32:04" itemprop="dateModified" datetime="2018-11-09T22:32:04+08:00">2018-11-09</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span></span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>1，分别用递归和非递归方式实现二叉树的遍历<br>    题目：要求用非递归和递归方式分别按照先序、中序、后序遍历二叉树；约定先序遍历顺序为：根、左、右，中序：左、中、右，后序：左、右、中。<br>    递归方式较为简单，代码如下：</p>
<a id="more"></a>
<p>先序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void preOrderRecur(Node head) &#123;</span><br><span class="line">		if (head == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(head.value + &quot; &quot;);</span><br><span class="line">		preOrderRecur(head.left);</span><br><span class="line">		preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void inOrderRecur(Node head) &#123;</span><br><span class="line">		if (head == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		inOrderRecur(head.left);</span><br><span class="line">		System.out.print(head.value + &quot; &quot;);</span><br><span class="line">		inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void posOrderRecur(Node head) &#123;</span><br><span class="line">		if (head == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		posOrderRecur(head.left);</span><br><span class="line">		posOrderRecur(head.right);</span><br><span class="line">		System.out.print(head.value + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这就是打印的时机不一样，形成了三种遍历方式。<br>    用递归方式解决的问题都能用非递归来解决。这是因为递归函数无非就是利用函数栈来保存信息，如果自己申请的数据结构来代替函数栈，也可以实现相同的功能。<br>    用非递归方式实现先序遍历具体规则如下：<br>        1),申请一个新的栈，记为stack。然后将头节点head压入stack。<br>        2),从stack中弹出栈顶结点，记为cur，然后打印cur的值，再将节点cur的右孩子(不为空的话)先压入stack中，最后将cur的左孩子(不为空的话)压入stack中。<br>        3),不断重复步骤2，直到stack为空，全部过程为结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void preOrderUnRecur(Node head) &#123;</span><br><span class="line">		System.out.print(&quot;pre-order: &quot;);</span><br><span class="line">		if (head != null) &#123;</span><br><span class="line">			Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">			stack.add(head);</span><br><span class="line">			while (!stack.isEmpty()) &#123;</span><br><span class="line">				head = stack.pop();</span><br><span class="line">				System.out.print(head.value + &quot; &quot;);</span><br><span class="line">				if (head.right != null) &#123;</span><br><span class="line">					stack.push(head.right);</span><br><span class="line">				&#125;</span><br><span class="line">				if (head.left != null) &#123;</span><br><span class="line">					stack.push(head.left);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是非递归实现先序的代码。<br>    用非递归方式实现中序遍历的规则：<br>        1),申请新的栈，记为stack，初始时，令变量cur=head。<br>        2),先把cur节点压入栈中，对以cur为头的整颗子树来说，依次把左边界压入栈中，即不停地令cur=cur.left，然后重复步骤2。<br>        3),不断重复步骤2，直到cur为空，此时从stack中弹出一个节点，记为node，打印node的值，并且让cur=node.right，然后继续重复步骤2.<br>        4),当stack为空且cur为空时，整个过程停止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void inOrderUnRecur(Node head) &#123;</span><br><span class="line">		System.out.print(&quot;in-order: &quot;);</span><br><span class="line">		if (head != null) &#123;</span><br><span class="line">			Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">			while (!stack.isEmpty() || head != null) &#123;</span><br><span class="line">				if (head != null) &#123;</span><br><span class="line">					stack.push(head);</span><br><span class="line">					head = head.left;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					head = stack.pop();</span><br><span class="line">					System.out.print(head.value + &quot; &quot;);</span><br><span class="line">					head = head.right;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以非递归方式实现后序遍历的规则：<br>    代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void posOrderUnRecur1(Node head) &#123;</span><br><span class="line">    System.out.print(&quot;pos-order: &quot;);</span><br><span class="line">    if (head != null) &#123;</span><br><span class="line">        Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        while (!s1.isEmpty()) &#123;</span><br><span class="line">            head = s1.pop();</span><br><span class="line">            s2.push(head);</span><br><span class="line">            if (head.left != null) &#123;</span><br><span class="line">                s1.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (head.right != null) &#123;</span><br><span class="line">               s1.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!s2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(s2.pop().value + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二非递归实现后序遍历，只使用一个栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void posOrderUnRecur2(Node h) &#123;</span><br><span class="line">		System.out.print(&quot;pos-order: &quot;);</span><br><span class="line">		if (h != null) &#123;</span><br><span class="line">			Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();</span><br><span class="line">			stack.push(h);</span><br><span class="line">			Node c = null;</span><br><span class="line">			while (!stack.isEmpty()) &#123;</span><br><span class="line">				c = stack.peek();</span><br><span class="line">				if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;</span><br><span class="line">					stack.push(c.left);</span><br><span class="line">				&#125; else if (c.right != null &amp;&amp; h != c.right) &#123;</span><br><span class="line">					stack.push(c.right);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					System.out.print(stack.pop().value + &quot; &quot;);</span><br><span class="line">					h = c;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2，打印二叉树的边界节点<br>    题目：给定一棵二叉树的头节点，按照如下两种标准分别实现二叉树边界节点的逆时针打印。<br>    标准一：<br>        1，头节点为边界节点。<br>        2，叶节点为边界节点。<br>        3，如果节点在其所在的层中是最左或最右的，那么也是边界节点。<br>    标准二：<br>        1，头节点为边界节点<br>        2，叶节点为边界节点<br>        3，树左边界延伸下去的路径为边界节点<br>        4，树右边界延伸下去的路径为边界节点<br>    按照标准一打印的全部过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static void printEdge1(Node head) &#123;</span><br><span class="line">		if (head == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		int height = getHeight(head, 0);</span><br><span class="line">		Node[][] edgeMap = new Node[height][2];</span><br><span class="line">		setEdgeMap(head, 0, edgeMap);</span><br><span class="line">		// print left edge</span><br><span class="line">		for (int i = 0; i != edgeMap.length; i++) &#123;</span><br><span class="line">			System.out.print(edgeMap[i][0].value + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		// print leaf node but not in map</span><br><span class="line">		printLeafNotInMap(head, 0, edgeMap);</span><br><span class="line">		// print right edge but not left edge</span><br><span class="line">		for (int i = edgeMap.length - 1; i != -1; i--) &#123;</span><br><span class="line">			if (edgeMap[i][0] != edgeMap[i][1]) &#123;</span><br><span class="line">				System.out.print(edgeMap[i][1].value + &quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public static int getHeight(Node h, int l) &#123;</span><br><span class="line">		if (h == null) &#123;</span><br><span class="line">			return l;</span><br><span class="line">		&#125;</span><br><span class="line">		return Math.max(getHeight(h.left, l + 1), getHeight(h.right, l + 1));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void setEdgeMap(Node h, int l, Node[][] edgeMap) &#123;</span><br><span class="line">		if (h == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		edgeMap[l][0] = edgeMap[l][0] == null ? h : edgeMap[l][0];</span><br><span class="line">		edgeMap[l][1] = h;</span><br><span class="line">		setEdgeMap(h.left, l + 1, edgeMap);</span><br><span class="line">		setEdgeMap(h.right, l + 1, edgeMap);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void printLeafNotInMap(Node h, int l, Node[][] m) &#123;</span><br><span class="line">		if (h == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (h.left == null &amp;&amp; h.right == null &amp;&amp; h != m[l][0] &amp;&amp; h != m[l][1]) &#123;</span><br><span class="line">			System.out.print(h.value + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printLeafNotInMap(h.left, l + 1, m);</span><br><span class="line">		printLeafNotInMap(h.right, l + 1, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照标准二的要求实现打印的具体过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void printEdge2(Node head) &#123;</span><br><span class="line">		if (head == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(head.value + &quot; &quot;);</span><br><span class="line">		if (head.left != null &amp;&amp; head.right != null) &#123;</span><br><span class="line">			printLeftEdge(head.left, true);</span><br><span class="line">			printRightEdge(head.right, true);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			printEdge2(head.left != null ? head.left : head.right);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void printLeftEdge(Node h, boolean print) &#123;</span><br><span class="line">		if (h == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (print || (h.left == null &amp;&amp; h.right == null)) &#123;</span><br><span class="line">			System.out.print(h.value + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printLeftEdge(h.left, print);</span><br><span class="line">		printLeftEdge(h.right, print &amp;&amp; h.left == null ? true : false);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void printRightEdge(Node h, boolean print) &#123;</span><br><span class="line">		if (h == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		printRightEdge(h.left, print &amp;&amp; h.right == null ? true : false);</span><br><span class="line">		printRightEdge(h.right, print);</span><br><span class="line">		if (print || (h.left == null &amp;&amp; h.right == null)) &#123;</span><br><span class="line">			System.out.print(h.value + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3，如何较为直观打印二叉树<br>    二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树有重复值得时候，仅仅通过三种遍历的结果来构造二叉树的真实结构更是难上加难，有时则根本可能。给定一颗二叉树的头节点head，已知二叉树节点值的类型为32位整型，请实现一个打印二叉树的函数，可以直观地展树的形状，也便于画出真是的结构。<br>    代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void printTree(Node head) &#123;</span><br><span class="line">		System.out.println(&quot;Binary Tree:&quot;);</span><br><span class="line">		printInOrder(head, 0, &quot;H&quot;, 17);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void printInOrder(Node head, int height, String to, int len) &#123;</span><br><span class="line">		if (head == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		printInOrder(head.right, height + 1, &quot;v&quot;, len);</span><br><span class="line">		String val = to + head.value + to;</span><br><span class="line">		int lenM = val.length();</span><br><span class="line">		int lenL = (len - lenM) / 2;</span><br><span class="line">		int lenR = len - lenM - lenL;</span><br><span class="line">		val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">		System.out.println(getSpace(height * len) + val);</span><br><span class="line">		printInOrder(head.left, height + 1, &quot;^&quot;, len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String getSpace(int num) &#123;</span><br><span class="line">		String space = &quot; &quot;;</span><br><span class="line">		StringBuffer buf = new StringBuffer(&quot;&quot;);</span><br><span class="line">		for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">			buf.append(space);</span><br><span class="line">		&#125;</span><br><span class="line">		return buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4，二叉树的序列化和反序列化<br>    题目：二叉树被记录成文件的过程叫做二叉树的序列化，通过文件重建成原来的二叉树的过程叫做二叉树的反序列化。给定一颗二叉树的头节点hed，并已知二叉树节点值得类型为32位整型，请设计一种二叉树序列化和反序列化的方案，并用代码实现。<br>    思路：<br>    方法一：先介绍下先序遍历下的序列化过程，首先假设序列化的结果字符串为str，初始时str=””。先序遍历二叉树，如果遇到null节点，就在字符串末尾加上”#!”，”#”表示这个节点为空，节点值不存在，”!”表示一个值的结束；如果遇到不为空的节点，假设节点值为3，就在str的末尾加上”3!”。<br>    代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public static class Node &#123;</span><br><span class="line">	public int value;</span><br><span class="line">	public Node left;</span><br><span class="line">	public Node right;</span><br><span class="line"></span><br><span class="line">	public Node(int data) &#123;</span><br><span class="line">		this.value = data;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public static String serialByPre(Node head) &#123;</span><br><span class="line">	if (head == null) &#123;</span><br><span class="line">		return &quot;#!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	String res = head.value + &quot;!&quot;;</span><br><span class="line">	res += serialByPre(head.left);</span><br><span class="line">	res += serialByPre(head.right);</span><br><span class="line">	return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来介绍通过先序遍历序列化的结果字符串str，重建二叉树的过程，即反序列化。<br>    把结果字符串str变成字符串类型的数组，记为values，数组代表一棵二叉树先序遍历的节点顺序。例如，str=”12!3!#!#!#!”，生成的values为[“12”,”3”,”#”,”#”,”#”]，然后用values[0…4]按照先序遍历的顺序建立整棵树。<br>    1，遇到”12”，生成节点值为12的节点(head)，然后用values[0…4]建立节点12的左子树，<br>    2，遇到”3”，生成节点值为3的节点，它是节点12的左孩子，然后用values[2…4]建立节点3的左子树。<br>    3，”#”，生成null节点，它是节点3的左孩子，该节点为null，所以这个节点没有后续建立子树的过程。回到节点3后，继续用values[3…4]建立节点3的右子树。<br>    4，后续过程就是依次。<br>    先序遍历反序列化的全部过程代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public static Node reconByPreString(String preStr) &#123;</span><br><span class="line">	String[] values = preStr.split(&quot;!&quot;);</span><br><span class="line">	Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">	for (int i = 0; i != values.length; i++) &#123;</span><br><span class="line">		queue.offer(values[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return reconPreOrder(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node reconPreOrder(Queue&lt;String&gt; queue) &#123;</span><br><span class="line">	String value = queue.poll();</span><br><span class="line">	if (value.equals(&quot;#&quot;)) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	Node head = new Node(Integer.valueOf(value));</span><br><span class="line">	head.left = reconPreOrder(queue);</span><br><span class="line">	head.right = reconPreOrder(queue);</span><br><span class="line">	return head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：通过层遍历实现序列化和反序列化。首先假设序列化的结果字符串为str，初始时str为空，然后实现二叉树的按层遍历，具体方式是利用队列结构，这也是宽度遍历图的常见方式。<br>    代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  public static String serialByLevel(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">	return &quot;#!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String res = head.value + &quot;!&quot;;</span><br><span class="line">Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</span><br><span class="line">queue.offer(head);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">	head = queue.poll();</span><br><span class="line">	if (head.left != null) &#123;</span><br><span class="line">		res += head.left.value + &quot;!&quot;;</span><br><span class="line">		queue.offer(head.left);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		res += &quot;#!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	if (head.right != null) &#123;</span><br><span class="line">		res += head.right.value + &quot;!&quot;;</span><br><span class="line">		queue.offer(head.right);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		res += &quot;#!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>5，遍历二叉树的神级方法–Morris方法<br>    题目：给定一个二叉树的head，完成先序、中序、后续遍历。要求时间复杂度为O(n)，额外空间复杂度为O(1)。<br>    思路：难度在于复杂度的要求，尤其是额外空间复杂度为O(1)的要求。之前的遍历方法虽然常用但无法做到额外空间复杂度为O(1)。这是因为遍历二叉树的递归方法实际上利用了函数栈(系统帮压栈)，非递归的方法使用了申请的栈，两者的额外空间复杂度都与树的高度有关，所以空间复杂度为O(h)，h为树的高度。那么完全不用栈结构能完成三种遍历吗？可以，答案是使用二叉树节点中大量指向null的指针，本提就是大名鼎鼎的Morris遍历，由Joseph Morris于1979年发明。<br>    中序代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  public static void morrisIn(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">Node cur1 = head;</span><br><span class="line">Node cur2 = null;</span><br><span class="line">while (cur1 != null) &#123;</span><br><span class="line">	cur2 = cur1.left;</span><br><span class="line">	if (cur2 != null) &#123;</span><br><span class="line">		while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">			cur2 = cur2.right;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cur2.right == null) &#123;</span><br><span class="line">			cur2.right = cur1;</span><br><span class="line">			cur1 = cur1.left;</span><br><span class="line">			continue;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cur2.right = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(cur1.value + &quot; &quot;);</span><br><span class="line">	cur1 = cur1.right;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先序遍历代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  public static void morrisPre(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">Node cur1 = head;</span><br><span class="line">Node cur2 = null;</span><br><span class="line">while (cur1 != null) &#123;</span><br><span class="line">	cur2 = cur1.left;</span><br><span class="line">	if (cur2 != null) &#123;</span><br><span class="line">		while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">			cur2 = cur2.right;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cur2.right == null) &#123;</span><br><span class="line">			cur2.right = cur1;</span><br><span class="line">			System.out.print(cur1.value + &quot; &quot;);</span><br><span class="line">			cur1 = cur1.left;</span><br><span class="line">			continue;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cur2.right = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		System.out.print(cur1.value + &quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	cur1 = cur1.right;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>后续遍历代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  public static void morrisPos(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">Node cur1 = head;</span><br><span class="line">Node cur2 = null;</span><br><span class="line">while (cur1 != null) &#123;</span><br><span class="line">	cur2 = cur1.left;</span><br><span class="line">	if (cur2 != null) &#123;</span><br><span class="line">		while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">			cur2 = cur2.right;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cur2.right == null) &#123;</span><br><span class="line">			cur2.right = cur1;</span><br><span class="line">			cur1 = cur1.left;</span><br><span class="line">			continue;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cur2.right = null;</span><br><span class="line">			printEdge(cur1.left);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cur1 = cur1.right;</span><br><span class="line">&#125;</span><br><span class="line">printEdge(head);</span><br><span class="line">System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>6，在二叉树中找到累加和为指定值得最长路径长度<br>    题目：给定一颗二叉树头节点head和一个32位整数sum，二叉树节点值类型为整型，求累加和为sum的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。<br>    7，找到二叉树中的最多搜索二叉子树<br>    题目：给定一颗二叉树的头节点head，已知所有节点值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点。<br>    要求：如果节点数为n，要求时间复杂度为O(n)，额外空间复杂度为O(h)，h为二叉树高度。<br>    思路：<br>    以节点node为头的树中，最大的搜索二叉树只能来自于以下两种情况。<br>        第一种：如果来自node左子树上的最大搜索二叉子树是以node.left为头的；来自node右子树上的最大搜索二叉子树是以node.left为头的，node左子树上的最大搜索二叉子树的最大值小于node.value；node右子树上的最大搜索二叉子树的最小值大于node.value，那么以节点node为头的整棵树都是二叉搜索树。<br>        第二种：如果不满足第一种，说明以节点node为头的树整体不能连成搜索二叉树。这种情况下，以node为头的树的最大搜索二叉树是来自于node的左子树上的最大搜索二叉子树和来自于node右子树上的最大搜索二叉子树之间，节点数较多的那个。<br>    求解的具体步骤：<br>        1，整体过程是二叉树的后续遍历<br>        2，遍历到当前节点记为cur时，先遍历cur的左子树收集4个信息，分别是左子树上最大搜索二叉子树的头节点(IBST)、节点数(ISize)、最小值(IMin)、和最大值(IMax)。再遍历cur的右子树收集4个信息，分别是右子树上最大搜索二叉子树的头节点(rBST)、节点数(rSize)、最小值(rMin)和最大值(rMax)。<br>        3，根据步骤2所收集的信息，判断是否满足第一种情况，如果满足第一种情况，就返回cur节点，如果满足第二种，就返回lBST和rBST中较大的一个。<br>        4，可以使用全局变量的方式实现步骤2中收集节点数、最小值和最大值的问题。找到最大搜索二叉子树的具体过程参看下面代码中的biggestSubBST。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   public static Node biggestSubBST(Node head) &#123;</span><br><span class="line">	int[] record = new int[3]; // 0-&gt;size, 1-&gt;min, 2-&gt;max</span><br><span class="line">	return posOrder(head, record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Node posOrder(Node head, int[] record) &#123;</span><br><span class="line">	if (head == null) &#123;</span><br><span class="line">		record[0] = 0;</span><br><span class="line">		record[1] = Integer.MAX_VALUE;</span><br><span class="line">		record[2] = Integer.MIN_VALUE;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	int value = head.value;</span><br><span class="line">	Node left = head.left;</span><br><span class="line">	Node right = head.right;</span><br><span class="line">	Node lBST = posOrder(left, record);</span><br><span class="line">	int lSize = record[0];</span><br><span class="line">	int lMin = record[1];</span><br><span class="line">	int lMax = record[2];</span><br><span class="line">	Node rBST = posOrder(right, record);</span><br><span class="line">	int rSize = record[0];</span><br><span class="line">	int rMin = record[1];</span><br><span class="line">	int rMax = record[2];</span><br><span class="line">	record[1] = Math.min(lMin, value);</span><br><span class="line">	record[2] = Math.max(rMax, value);</span><br><span class="line">	if (left == lBST &amp;&amp; right == rBST &amp;&amp; lMax &lt; value &amp;&amp; value &lt; rMin) &#123;</span><br><span class="line">		record[0] = lSize + rSize + 1;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	record[0] = Math.max(lSize, rSize);</span><br><span class="line">	return lSize &gt; rSize ? lBST : rBST;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>8，找到二叉树中符合搜索二叉树条件的最大拓扑结构<br>    题目：给定一棵二叉树头节点head，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小。</p>
<pre><code>9，二叉树的按层打印与ZigZag打印
题目：给定一颗二叉树的头节点head，分别实现按层打印和zigzag打印二叉树的函数。例如：头节点1，左孩子2，右孩子为3，节点2左孩子为4，右孩子为空，节点3左孩子为5，右孩子为6，节点5左孩子为7，节点5右孩子为8。
按层打印时，输出格式如下：
level 1：1
level 2：2 3
level 3：4 5 6 
level 4：7 8    
zigzag打印时，如下输出：
level 1 from left to right：1
level 1 from right to left：3 2
level 1 from left to right：4 5 6
level 1 from right to left：8 7
二叉树按层打印的代码：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  public static void printByLevel(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</span><br><span class="line">int level = 1;</span><br><span class="line">Node last = head;</span><br><span class="line">Node nLast = null;</span><br><span class="line">queue.offer(head);</span><br><span class="line">System.out.print(&quot;Level &quot; + (level++) + &quot; : &quot;);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">	head = queue.poll();</span><br><span class="line">	System.out.print(head.value + &quot; &quot;);</span><br><span class="line">	if (head.left != null) &#123;</span><br><span class="line">		queue.offer(head.left);</span><br><span class="line">		nLast = head.left;</span><br><span class="line">	&#125;</span><br><span class="line">	if (head.right != null) &#123;</span><br><span class="line">		queue.offer(head.right);</span><br><span class="line">		nLast = head.right;</span><br><span class="line">	&#125;</span><br><span class="line">	if (head == last &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">		System.out.print(&quot;\nLevel &quot; + (level++) + &quot; : &quot;);</span><br><span class="line">		last = nLast;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>思路：按层打印对二叉树做简单的宽度优先遍历即可，但本题有额外的要求，就是同一层的节点必须打印在一行上，并且要输出行号。这就需要在原来的宽度优先遍历做一些改进。关键是如何换行。<br>    只需用两个node型的变量last和nLast即可，last表示当前打印行的最右节点，nLast表示下一行的最右节点，假设我们每一层都做从左到右的宽度优先遍历，如果发现遍历到的节点等于last，说明该换行了。换行之后只要令last=nLast，就可以继续下一行的打印过程，此过程重复，直到所有的节点都打印完。那么问题就变成了如何更新nLast？只需要让nLast一直跟踪记录宽度优先遍历队列中的最新加入的节点即可。这是因为最新加入队列的节点一定是目前已经发现的下一行的最右节点。所以在当前行打印完时，nLast一定是下一行所有节点中的最右节点。<br>    2)二叉树zigzag打印<br>    先介绍不推荐的做法：<br>    使用arraylist结构，两个，分别记为list1.list2，用list1去收集当前层的节点，然后从左到右打印当前层，接着把当前层的孩子节点放进list2，并从右到左打印，接下来再把list2的所有的节点的孩子节点放入list1，如此反复。不推荐的原因是arraylist是动态数组，在这个结构中，当元素达到一定的量时，会发生扩容操作，扩容操作的时间复杂度是O(n)比较高的，这个结构增加删除元素的时间复杂度都比较高。总之，用这种数据结构不够干净和纯粹，最好不要使用。<br>    推荐的方法是双端队列，具体为java的LinkedList结构，这个结构的底层是非常纯粹的双端队列结构，本书的方法也仅使用双端队列结构的基本操作。<br>    先举题目的例子来展示大体过程，首先生成双端队列结构dp，将节点1从dp的头部放入dp。<br>    原则1：如果是从左到右的过程，那么一律从dp的头部弹出节点，如果弹出的节点没有孩子节点，当然不用放入任何节点到dp中；如果当前节点有孩子节点，先让左孩子从尾部进入dp，再让右孩子从尾部进入dp。<br>    根据原则1，先从dp头部弹出节点1并打印，然后先让节点2从dp尾部进入，再让节点3从dp尾部进入。<br>    原则2：如果是从右到左的过程，那么一律从dp的尾部弹出节点，如果弹出的节点没有还节点，当然不能放入任何节点到dp中；如果当前节点有孩子节点，先让右孩子从头部进入dp，再让左孩子从头部进入dp。<br>    根据原则2，先从dp尾部弹出节点3并打印，然后先让节点6从dp头部进入，再让节点5从dp头部进入。<br>    根据原则2，先从dp尾部弹出节点并打印，然后让节点4从dp头部进入。<br>    根据原则1，依次从dp头部弹出节点4、5、6并打印，这期间先让节点7从dp尾部进入，再让节点8从dp尾部进入。<br>    最后根据原则2，依次从dp尾部弹出节点8和节点7并打印即可。<br>    用原则1和2的过程切换，我们可以完成zigzag的打印过程，所以问题在于，如何确定原则1和原则2的切换时机，其实还是如何确定每一层最后一个节点的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  public static void printByZigZag(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">Deque&lt;Node&gt; dq = new LinkedList&lt;Node&gt;();</span><br><span class="line">int level = 1;</span><br><span class="line">boolean lr = true;</span><br><span class="line">Node last = head;</span><br><span class="line">Node nLast = null;</span><br><span class="line">dq.offerFirst(head);</span><br><span class="line">printLevelAndOrientation(level++, lr);</span><br><span class="line">while (!dq.isEmpty()) &#123;</span><br><span class="line">	if (lr) &#123;</span><br><span class="line">		head = dq.pollFirst();</span><br><span class="line">		if (head.left != null) &#123;</span><br><span class="line">			nLast = nLast == null ? head.left : nLast;</span><br><span class="line">			dq.offerLast(head.left);</span><br><span class="line">		&#125;</span><br><span class="line">		if (head.right != null) &#123;</span><br><span class="line">			nLast = nLast == null ? head.right : nLast;</span><br><span class="line">			dq.offerLast(head.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		head = dq.pollLast();</span><br><span class="line">		if (head.right != null) &#123;</span><br><span class="line">			nLast = nLast == null ? head.right : nLast;</span><br><span class="line">			dq.offerFirst(head.right);</span><br><span class="line">		&#125;</span><br><span class="line">		if (head.left != null) &#123;</span><br><span class="line">			nLast = nLast == null ? head.left : nLast;</span><br><span class="line">			dq.offerFirst(head.left);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(head.value + &quot; &quot;);</span><br><span class="line">	if (head == last &amp;&amp; !dq.isEmpty()) &#123;</span><br><span class="line">		lr = !lr;</span><br><span class="line">		last = nLast;</span><br><span class="line">		nLast = null;</span><br><span class="line">		System.out.println();</span><br><span class="line">		printLevelAndOrientation(level++, lr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
      

        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/二叉树/" rel="tag"># 二叉树</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2018/08/26/第二章，链表问题算法-二/" rel="next" title="链表问题算法(二)">
                  <i class="fa fa-chevron-left"></i> 链表问题算法(二)
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2018/08/26/第四章递归和动态规划/" rel="prev" title="递归和动态规划">
                  递归和动态规划 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/timg.jpg"
      alt="Move">
  <p class="site-author-name" itemprop="name">Move</p>
  <div class="site-description" itemprop="description">hhh</div>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ltt19921124" title="GitHub &rarr; https://github.com/ltt19921124" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://liuwangshu.cn/" title="http://liuwangshu.cn/" rel="noopener" target="_blank">刘望舒</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/singwhatiwanna/" title="https://blog.csdn.net/singwhatiwanna/" rel="noopener" target="_blank">任玉刚</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://me.csdn.net/sinyu890807" title="https://me.csdn.net/sinyu890807" rel="noopener" target="_blank">郭霖</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Move</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数"></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共168.5k字</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>






  

  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>