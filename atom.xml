<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-02T20:37:40.393Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lu Tian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之责任链模式</title>
    <link href="http://yoursite.com/2019/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/03/设计模式之责任链模式/</id>
    <published>2019-09-02T20:36:21.000Z</published>
    <updated>2019-09-02T20:37:40.393Z</updated>
    
    <content type="html"><![CDATA[<p>责任链模式经常应用于java和安卓中。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;责任链模式经常应用于java和安卓中。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2019/09/03/test-1/"/>
    <id>http://yoursite.com/2019/09/03/test-1/</id>
    <published>2019-09-02T19:49:14.000Z</published>
    <updated>2019-09-02T20:05:51.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>kk</p><a id="more"></a><p>文章</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章&quot;&gt;&lt;a href=&quot;#文章&quot; class=&quot;headerlink&quot; title=&quot;文章&quot;&gt;&lt;/a&gt;文章&lt;/h2&gt;&lt;p&gt;kk&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android9.0根activity启动流程分析</title>
    <link href="http://yoursite.com/2019/09/03/Android9.0%E6%A0%B9activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/09/03/Android9.0根activity启动流程分析/</id>
    <published>2019-09-02T17:07:13.099Z</published>
    <updated>2018-12-22T13:56:42.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="activity的启动流程"><a href="#activity的启动流程" class="headerlink" title="activity的启动流程"></a>activity的启动流程</h3><h3 id="activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS-ActivityManagerService-过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看9-0-0-r3源码。"><a href="#activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS-ActivityManagerService-过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看9-0-0-r3源码。" class="headerlink" title="activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS(ActivityManagerService)过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看9.0.0_r3源码。"></a>activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS(ActivityManagerService)过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看<a href="http://androidxref.com/9.0.0_r3/" target="_blank" rel="noopener">9.0.0_r3源码</a>。</h3><h5 id="1，Launcher请求AMS过程"><a href="#1，Launcher请求AMS过程" class="headerlink" title="1，Launcher请求AMS过程"></a>1，Launcher请求AMS过程</h5><a id="more"></a><p>Launcher启动后会显示应用的图标于桌面上，这些应用图标就是启动根activity的入口，点击它们时就会通过Launcher类来请求AMS来启动该应用程序。Launcher的源码路径为：/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java<br>时序图如下：</p><hr><p><img src="/picture/%E6%97%B6%E5%BA%8F.png" alt></p><h5 id="2，接下来查看ApplicationThread的scheduleLaunchActivity方法，其中ApplicationThread是ActivityThread的内部类，应用程序进程创建后会运行代表主线程的实例ActivityThread，它管理着当前应用程序进程的线程。ApplicationThread的scheduleLaunchActivity方法如下所示。"><a href="#2，接下来查看ApplicationThread的scheduleLaunchActivity方法，其中ApplicationThread是ActivityThread的内部类，应用程序进程创建后会运行代表主线程的实例ActivityThread，它管理着当前应用程序进程的线程。ApplicationThread的scheduleLaunchActivity方法如下所示。" class="headerlink" title="2，接下来查看ApplicationThread的scheduleLaunchActivity方法，其中ApplicationThread是ActivityThread的内部类，应用程序进程创建后会运行代表主线程的实例ActivityThread，它管理着当前应用程序进程的线程。ApplicationThread的scheduleLaunchActivity方法如下所示。"></a>2，接下来查看ApplicationThread的scheduleLaunchActivity方法，其中ApplicationThread是ActivityThread的内部类，应用程序进程创建后会运行代表主线程的实例ActivityThread，它管理着当前应用程序进程的线程。ApplicationThread的scheduleLaunchActivity方法如下所示。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">        boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    ...</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleLaunchActivity方法会将启动Activity的参数封装成ActivityClientRecord ，sendMessage方法向H类发送类型为LAUNCH_ACTIVITY的消息，并将ActivityClientRecord 传递过去，sendMessage方法有多个重载方法，最终调用的sendMessage方法如下所示。</p><h4 id="frameworks-base-core-java-android-app-ActivityThread-java"><a href="#frameworks-base-core-java-android-app-ActivityThread-java" class="headerlink" title="frameworks/base/core/java/android/app/ActivityThread.java:"></a>frameworks/base/core/java/android/app/ActivityThread.java:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; / &quot; + obj);</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        msg.obj = obj;</span><br><span class="line">        msg.arg1 = arg1;</span><br><span class="line">        msg.arg2 = arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里mH指的是H，它是ActivityThread的内部类并继承Handler，是应用程序进程中主线程的消息管理类。H的代码如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">          if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">          switch (msg.what) &#123;</span><br><span class="line">              case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                  final ActivityClientRecord r = (ActivityClientRecord) msg.obj;//1</span><br><span class="line">                  r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                          r.activityInfo.applicationInfo, r.compatInfo);//2</span><br><span class="line">                  handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);//3</span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">              &#125; break;</span><br><span class="line">              case RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityRestart&quot;);</span><br><span class="line">                  ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">                  handleRelaunchActivity(r);</span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">              &#125; break;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看H的handleMessage方法中对LAUNCH_ACTIVITY的处理，在注释1处将传过来的msg的成员变量obj转换为ActivityClientRecord。<br>在注释2处通过getPackageInfoNoCheck方法获得LoadedApk类型的对象并赋值给ActivityClientRecord 的成员变量packageInfo 。应用程序进程要启动Activity时需要将该Activity所属的APK加载进来，而LoadedApk就是用来描述已加载的APK文件。<br>在注释3处调用handleLaunchActivity方法，代码如下所示。</p><h4 id="frameworks-base-core-java-android-app-ActivityThread-java-1"><a href="#frameworks-base-core-java-android-app-ActivityThread-java-1" class="headerlink" title="frameworks/base/core/java/android/app/ActivityThread.java"></a>frameworks/base/core/java/android/app/ActivityThread.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    //启动Activity</span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);//1</span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        //将Activity的状态置为Resume</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                r.state = oldState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //停止Activity启动</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处的performLaunchActivity方法用来启动Activity ，注释2处的代码用来将Activity 的状态置为Resume。如果该Activity为null则会通知AMS停止启动Activity。来查看performLaunchActivity方法做了什么：</p><h4 id="frameworks-base-core-java-android-app-ActivityThread-java-2"><a href="#frameworks-base-core-java-android-app-ActivityThread-java-2" class="headerlink" title="frameworks/base/core/java/android/app/ActivityThread.java"></a>frameworks/base/core/java/android/app/ActivityThread.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        //获取ActivityInfo类</span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;//1</span><br><span class="line">        if (r.packageInfo == null) &#123;</span><br><span class="line">        //获取APK文件的描述类LoadedApk</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);//2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ComponentName component = r.intent.getComponent();//3</span><br><span class="line">        ...</span><br><span class="line">        //创建要启动Activity的上下文环境</span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);//4</span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">            //用类加载器来创建该Activity的实例</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);//5</span><br><span class="line">          ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //创建Application</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);//6</span><br><span class="line">            ...</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">               ...</span><br><span class="line">                /**</span><br><span class="line">                *7 初始化Activity</span><br><span class="line">                */</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">               ...</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);//8</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            r.paused = true;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line">        &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处用来获取ActivityInfo，ActivityInfo用于存储代码和AndroidManifes设置的Activity和receiver节点信息，比如Activity的theme和launchMode。在注释2处获取APK文件的描述类LoadedApk。注释3处获取要启动的Activity的ComponentName类，ComponentName类中保存了该Activity的包名和类名。注释4处用来创建要启动Activity的上下文环境。注释5处根据ComponentName中存储的Activity类名，用类加载器来创建该Activity的实例。注释6处用来创建Application，makeApplication方法内部会调用Application的onCreate方法。注释7处调用Activity的attach方法初始化Activity，attach方法中会创建Window对象（PhoneWindow）并与Activity自身进行关联。注释8处会调用Instrumentation的callActivityOnCreate方法来启动Activity，如下所示。</p><h4 id="frameworks-base-core-java-android-app-Instrumentation-java"><a href="#frameworks-base-core-java-android-app-Instrumentation-java" class="headerlink" title="frameworks/base/core/java/android/app/Instrumentation.java"></a>frameworks/base/core/java/android/app/Instrumentation.java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line">        performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performCreate方法中会调用Activity的onCreate方法，讲到这里，根Activity就启动了，即应用程序就启动了。<br>根Activity启动过程就讲到这里，下面我们来学习根Activity启动过程中涉及到的进程。</p><h5 id="3-根Activity启动过程中涉及的进程"><a href="#3-根Activity启动过程中涉及的进程" class="headerlink" title="3,根Activity启动过程中涉及的进程"></a>3,根Activity启动过程中涉及的进程</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;activity的启动流程&quot;&gt;&lt;a href=&quot;#activity的启动流程&quot; class=&quot;headerlink&quot; title=&quot;activity的启动流程&quot;&gt;&lt;/a&gt;activity的启动流程&lt;/h3&gt;&lt;h3 id=&quot;activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS-ActivityManagerService-过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看9-0-0-r3源码。&quot;&gt;&lt;a href=&quot;#activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS-ActivityManagerService-过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看9-0-0-r3源码。&quot; class=&quot;headerlink&quot; title=&quot;activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS(ActivityManagerService)过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看9.0.0_r3源码。&quot;&gt;&lt;/a&gt;activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS(ActivityManagerService)过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看&lt;a href=&quot;http://androidxref.com/9.0.0_r3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;9.0.0_r3源码&lt;/a&gt;。&lt;/h3&gt;&lt;h5 id=&quot;1，Launcher请求AMS过程&quot;&gt;&lt;a href=&quot;#1，Launcher请求AMS过程&quot; class=&quot;headerlink&quot; title=&quot;1，Launcher请求AMS过程&quot;&gt;&lt;/a&gt;1，Launcher请求AMS过程&lt;/h5&gt;
    
    </summary>
    
      <category term="安卓" scheme="http://yoursite.com/categories/%E5%AE%89%E5%8D%93/"/>
    
    
      <category term="安卓" scheme="http://yoursite.com/tags/%E5%AE%89%E5%8D%93/"/>
    
      <category term="activity启动" scheme="http://yoursite.com/tags/activity%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android之Handler内存泄漏及解决方式</title>
    <link href="http://yoursite.com/2019/08/26/Android%E4%B9%8BHandler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/26/Android之Handler内存泄漏及解决方式/</id>
    <published>2019-08-25T18:52:55.000Z</published>
    <updated>2019-08-26T07:04:14.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android开发之内存泄漏"><a href="#Android开发之内存泄漏" class="headerlink" title="Android开发之内存泄漏"></a>Android开发之内存泄漏</h2><p>此文参考自<a href="https://www.jianshu.com/p/ed9e15eff47a?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=qq" target="_blank" rel="noopener">Android内存泄露</a><br>在Android开发中，内存泄漏非常常见。</p><a id="more"></a><p>所谓内存泄漏，就是<strong>本来应该被回收的对象未能被回因而导致对象留在内存中。</strong><br>内存泄漏产生的原因：当一个对象不再被使用时，本该回收但是<strong>此时有另外一个正在使用的对象持有它的引用从而导致它不能被回收</strong>。<br>在Android开发中，Handler内存泄漏极为常见。Handler的用法有：<strong>新建Handler子类</strong>、<strong>匿名内部类</strong>。<br>匿名内部类使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//匿名内部类</span><br><span class="line">    Handler myHandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            //处理业务逻辑</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">//启动子线程</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //定义发送的消息</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.what = UPDATE;</span><br><span class="line">        //向MessageQueue队列发送消息，传入主线程的Handler</span><br><span class="line">        myHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>定义内部类方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//静态Handler类配合弱引用使用</span><br><span class="line">    class MyHandler extends Handler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case UPDATE:</span><br><span class="line">                        text.setText(&quot;nice&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                        default:</span><br><span class="line">                            break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MyHandler myHandler = new MyHandler();</span><br><span class="line"></span><br><span class="line">//启动子线程</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //定义发送的消息</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        message.what = UPDATE;</span><br><span class="line">        //向MessageQueue队列发送消息，传入主线程的Handler</span><br><span class="line">        myHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这两种方式并没有太大的区别。<br>不过上述两种方式都有<strong>内存泄漏</strong>的风险。<br><img src="/picture/QQ%E6%88%AA%E5%9B%BE20190826034354.png" alt><br>如上图所示，Android Studio提示Handler没有被设置为静态类的时候会造成泄漏。</p><h2 id="Handler泄漏原因"><a href="#Handler泄漏原因" class="headerlink" title="Handler泄漏原因"></a>Handler泄漏原因</h2><p>在java中，<strong>静态内部类</strong>和<strong>匿名内部类</strong>都默认持有外部类的引用。Android中Handler消息队列还有未处理的消息时(或还有正在处理的消息)，消息队列的Message会持有Handler实例的引用。而同时由于Handler的使用方式(非静态内部类和静态内部类)，又会持有外部类的引用(MainActivity实例)，这个引用链会一直保持，直到handler消息队列中的消息都被处理完。</p><p>在Handler队列还有未处理完的消息时或正在处理消息时，此时若需要销毁外部类，但是由于引用关系，GC(垃圾回收器)无法回收MainActivity，从而造成内存泄漏。</p><h2 id="解决方法一-静态内部类-弱引用"><a href="#解决方法一-静态内部类-弱引用" class="headerlink" title="解决方法一(静态内部类+弱引用)"></a>解决方法一(静态内部类+弱引用)</h2><p>解决这个可以用<strong>静态Handler内部类加上弱引用的方式</strong>。<br>因为静态内部类不会持有外部类的引用，从而使得”未被处理/正在处理的消息–&gt;Handler实例–&gt;外部类”这条引用链不成立。<br>同时还可以加上<strong>WeakReference弱引用持有Activity实例</strong>，因为弱引用对象拥有短暂的生命周期，在GC的时候一旦发现了只具有弱引用的对象，不管内存空间是否足够，都会回收它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//静态Handler类配合弱引用使用</span><br><span class="line">static class MyHandler extends Handler &#123;</span><br><span class="line">    //定义弱引用实例</span><br><span class="line">    private WeakReference&lt;MainActivity&gt; mainActivityWeakReference;</span><br><span class="line">    //在构造方法中传入需要持有的Activity实例</span><br><span class="line">    private MyHandler (MainActivity activity) &#123;</span><br><span class="line">        mainActivityWeakReference = new WeakReference&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">        super.handleMessage(msg);</span><br><span class="line">        MainActivity activity = mainActivityWeakReference.get();</span><br><span class="line">        if (activity != null) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case UPDATE:</span><br><span class="line">                    text.setText(&quot;nice&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private MyHandler myHandler = new MyHandler(this);</span><br><span class="line">@Override</span><br><span class="line">public void onClick(View view) &#123;</span><br><span class="line">    switch (view.getId()) &#123;</span><br><span class="line">        case R.id.bu:</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    &lt;!-- Message message = Message.obtain();</span><br><span class="line">                    message.what = UPDATE;</span><br><span class="line">                    //发送消息</span><br><span class="line">                    myHandler.sendMessage(message); --&gt;</span><br><span class="line">                    //code</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方法二-外部类结束生命周期时，清空Handler内的消息队列"><a href="#解决方法二-外部类结束生命周期时，清空Handler内的消息队列" class="headerlink" title="解决方法二(外部类结束生命周期时，清空Handler内的消息队列)"></a>解决方法二(外部类结束生命周期时，清空Handler内的消息队列)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    myHandler.removeCallbacksAndMessages(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：<strong>为了保证Handler中消息队列所有消息都能被执行，建议使用静态Handler内部类 + 弱引用</strong>的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android开发之内存泄漏&quot;&gt;&lt;a href=&quot;#Android开发之内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;Android开发之内存泄漏&quot;&gt;&lt;/a&gt;Android开发之内存泄漏&lt;/h2&gt;&lt;p&gt;此文参考自&lt;a href=&quot;https://www.jianshu.com/p/ed9e15eff47a?utm_campaign=haruki&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=qq&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android内存泄露&lt;/a&gt;&lt;br&gt;在Android开发中，内存泄漏非常常见。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希原理</title>
    <link href="http://yoursite.com/2019/08/25/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/25/一致性哈希原理/</id>
    <published>2019-08-25T04:36:58.000Z</published>
    <updated>2019-08-26T07:01:17.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一致性哈希原理产生的原因及应用"><a href="#一致性哈希原理产生的原因及应用" class="headerlink" title="一致性哈希原理产生的原因及应用"></a>一致性哈希原理产生的原因及应用</h2><p>在工程中，我们常用服务器集群来实现数据缓存，有以下常见的策略：</p><ul><li>添加、删除、查询数据，都将数据的id通过哈希算法转换成一个哈希值，机尾key</li><li>若有N台机器，则计算key % N的值，这个值就是该条数据所属的机器编号，无论是添加、查询、删除操作，都只在这台机器上进行<a id="more"></a>很明显这种策略有问题，如果增加或减少机器数量，代价会很高，所有的数据要根据id中心计算哈希值，并将得到的哈希值重新进行取模操作，然后进行大规模的数据迁移。<br>为了解决这个问题，<strong>一致性哈希算法</strong>诞生了。<br><strong>一致性哈希算法是一种很好的数据缓存方案</strong>。假设数据根据id进行哈希算法转换成的哈希值范围是0 ~ (2^32 - 1),也就是0 ~ (2^32 - 1)的数字空间，现在将这些书头尾相连形成一个闭环，在一条数据根据id生成哈希值后对应到环中的一个位置上。如下图所示：<br><img src="/picture/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.png" alt="1"></li></ul><p><img src="/picture/%E5%93%88%E5%B8%8C.png" alt="2"></p><p>在图2中，data1根据id计算出哈希值key1，顺时针第一台机器是machine2，所以data1归属机器2，同理，data2归属machine3，data3和data4归属machine1。</p><h2 id="增加机器是处理步骤"><a href="#增加机器是处理步骤" class="headerlink" title="增加机器是处理步骤"></a>增加机器是处理步骤</h2><p>假设有2台机器和3条数据，数据和机器在环中结构如下图所示：<br><img src="/picyure/%E7%8E%AF.png" alt="3"><br>此时若加入机器m3，同时计算出m3的id在m1与m2右半侧的环中，这样加入m3机器后的结构如下图所示：<br><img src="/picture/jia.png" alt="4"></p><p>在没有添加m3之前，从m1到m3这一段是m2掌管的范围，添加m3之后则归属m3，同时要把这一段旧数据从m2迁移到m3上，由此可见添加机器时的调整代价较小。删除机器时也一样，只要把删除的机器上的数据全部复制到顺时针找到的下一台机器上即可，比如在图4删除机器m2，m2上的数据data2只要把它迁移到m1上即可。</p><p>机器负载不均时的处理，很有可能造成机器在整个环上的分布不均匀，从而导致机器之间的负载不均衡，如下图两台机器，m1比m2面临更大的负载。<br><img src="/picture/fuzai.png" alt="5"></p><p>为了解决这种数据倾斜的问题，<strong>一致性哈希算法引入了虚拟节点</strong>，即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。具体做法可以在主机ip地址或主机名的后面加编号或者端口号来实现。如上图所示可以为每台机器计算两个虚拟节点 ，分别计算m1 - 1、m1- 2、m2 - 1、m2 - 2的哈希值，于是形成四个虚拟节点，节点数变多了，根据哈希函数的性质，平衡性会更好。</p><p><img src="/picture/fuzaiyouhua.png" alt="6"></p><p>此时数据定位算法不变，只是多走了一步虚拟节点的映射，如下表</p><p><img src="/picture/yingshe.png" alt="7"><br>当一条数据计算出归属于某一个虚拟节点时，再根据上表的跳转，数据将最终归属于实际的机器；同样虚拟节点之间的数据迁移操作也可以根据上表的对应关系，变成实际机器之间的数据迁移操作。上述例子是给每台机器分配两个虚拟节点的情况。那么如果有三台机器A、B、C，我们给每台机器分配1万个虚拟节点，一共有3万个虚拟节点去抢占哈希环中的位置。那么在3万个虚拟节点中，有三分之一属于A、三分之一属于B、三分之一属于C，如果对外提供服务那么这三台机器实际上是负载均衡的。也就是说我们让每台机器分配较多的虚拟节点去抢占哈希环，数量多起来后，哈希函数的离散型就可以得到很好的体现，然后每台机器就可以按照虚拟节点的比例来分配负载了，这就是虚拟节点技术。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一致性哈希原理产生的原因及应用&quot;&gt;&lt;a href=&quot;#一致性哈希原理产生的原因及应用&quot; class=&quot;headerlink&quot; title=&quot;一致性哈希原理产生的原因及应用&quot;&gt;&lt;/a&gt;一致性哈希原理产生的原因及应用&lt;/h2&gt;&lt;p&gt;在工程中，我们常用服务器集群来实现数据缓存，有以下常见的策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加、删除、查询数据，都将数据的id通过哈希算法转换成一个哈希值，机尾key&lt;/li&gt;
&lt;li&gt;若有N台机器，则计算key % N的值，这个值就是该条数据所属的机器编号，无论是添加、查询、删除操作，都只在这台机器上进行
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java高并发系列：4种常用的线程锁的特点，性能比较和使用场景</title>
    <link href="http://yoursite.com/2019/08/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/08/23/java高并发系列：4种常用的线程锁的特点，性能比较和使用场景/</id>
    <published>2019-08-23T06:22:19.000Z</published>
    <updated>2019-08-23T07:55:13.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程的由来"><a href="#多线程的由来" class="headerlink" title="多线程的由来"></a>多线程的由来</h2><p>在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。</p><a id="more"></a><p>使用多线程的理由之一是和进程相比，它是一种非常<strong>花销小，切换快</strong>，更”节俭”的多任务操作方式。<br>在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而在进程中的同时运行多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。</p><h2 id="多线程并发面临的问题"><a href="#多线程并发面临的问题" class="headerlink" title="多线程并发面临的问题"></a>多线程并发面临的问题</h2><p>多线程并发面临的问题：</p><ul><li>多线程资源共享</li><li>锁的选择</li><li>线程死锁<br>由于多个线程是共同占有所属进程的资源和地址空间的，那么就会存在一个问题：如果多个线程要同时访问某个资源，怎么处理？</li></ul><h2 id="Java提供了多种多线程锁机制的实现方式，常见的有："><a href="#Java提供了多种多线程锁机制的实现方式，常见的有：" class="headerlink" title="Java提供了多种多线程锁机制的实现方式，常见的有："></a>Java提供了多种多线程锁机制的实现方式，常见的有：</h2><ul><li>synchronized</li><li>ReentrantLock</li><li>Semaphore</li><li>AtomicInteger<br>每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。</li></ul><h2 id="4种java线程锁-线程锁"><a href="#4种java线程锁-线程锁" class="headerlink" title="4种java线程锁(线程锁)"></a>4种java线程锁(线程锁)</h2><h3 id="1，synchronized"><a href="#1，synchronized" class="headerlink" title="1，synchronized"></a>1，synchronized</h3><p>在Java中synchronized关键字被常用于维护数据一致性。<br>synchronized机制是给共享资源上锁，只有拿到锁的线程才可以访问共享资源，这样就可以强制使得对共享资源的访问都是顺序的。<br>Java开发人员都认识synchronized，使用它来实现多线程的同步操作是非常简单的，只要在需要同步的对方的方法、类或代码块中加入该关键字，它能够保证在同一个时刻最多只有一个线程执行同一个对象的同步代码，可保证修饰的代码在执行过程中不会被其他线程干扰。使用synchronized修饰的代码具有原子性和可见性，在需要进程同步的程序中使用的频率非常高，可以满足一般的进程同步要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized实现的机理依赖于软件层面上的JVM，因此其性能会随着Java版本的不断升级而提高。<br>到了Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7与1.8中，均对该关键字的实现机理做了优化。</p><p>需要说明的是，当线程通过synchronized等待锁时是不能被Thread.interrupt()中断的，因此程序设计时必须检查确保合理，否则可能会造成线程死锁的尴尬境地。</p><p>最后，尽管Java实现的锁机制有很多种，并且有些锁机制性能也比synchronized高，但还是强烈推荐在多线程应用程序中使用该关键字，因为实现方便，后续工作由JVM来完成，可靠性高。只有在确定锁机制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如ReentrantLock等。</p><h3 id="2，ReentrantLock"><a href="#2，ReentrantLock" class="headerlink" title="2，ReentrantLock"></a>2，ReentrantLock</h3><p>可重入锁，顾名思义，这个锁可以被线程多次重复进入进行获取操作。</p><p>ReentantLock继承接口Lock并实现了接口中定义的方法，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p><p><strong>Lock实现的机理依赖于特殊的CPU指定，可以认为不受JVM的约束</strong>，并可以通过其他语言平台来完成底层的实现。在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准。</p><p><strong>因此我们建议在高并发量情况下使用ReentrantLock</strong>。</p><p>ReentrantLock引入两个概念：<strong>公平锁与非公平锁</strong>。</p><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁。反之，JVM按随机、就近原则分配锁的机制则称为不公平锁。</p><p>ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。这是因为，非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><p>ReentrantLock通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，<strong>使用ReentrantLock必须在finally控制块中进行解锁操作</strong>。通常使用方式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    //…进行任务操作5 &#125;</span><br><span class="line"></span><br><span class="line">finally &#123;</span><br><span class="line"></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3,Semaphore"></a>3,Semaphore</h3><p>上述两种锁机制类型都是“互斥锁”，学过操作系统的都知道，互斥是进程同步关系的一种特殊情况，相当于只存在一个临界资源，因此同时最多只能给一个线程提供服务。但是，在实际复杂的多线程应用程序中，可能存在多个临界资源，这时候我们可以借助Semaphore信号量来完成多个临界资源的访问。</p><p>Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。</p><p>经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，<strong>释放锁的操作也必须在finally代码块中完成</strong>。</p><h3 id="4-AtomicInteger"><a href="#4-AtomicInteger" class="headerlink" title="4,AtomicInteger"></a>4,AtomicInteger</h3><p>首先说明，此处AtomicInteger是一系列相同类的代表之一，常见的还有AtomicLong、AtomicLong等，他们的实现原理相同，区别在与运算对象类型的不同。</p><p>我们知道，在多线程程序中，诸如++i或i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock的好几倍。</p><h2 id="java多线程总结"><a href="#java多线程总结" class="headerlink" title="java多线程总结"></a>java多线程总结</h2><h3 id="1，synchronized-1"><a href="#1，synchronized-1" class="headerlink" title="1，synchronized"></a>1，synchronized</h3><p>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好。</p><h3 id="2，ReentrantLock-1"><a href="#2，ReentrantLock-1" class="headerlink" title="2，ReentrantLock"></a>2，ReentrantLock</h3><p>在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍，而ReentrantLock确还能维持常态。</p><p><strong>高并发量情况下使用ReentrantLock。</strong></p><h3 id="3，Atomic"><a href="#3，Atomic" class="headerlink" title="3，Atomic"></a>3，Atomic</h3><p>和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。</p><p>所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。</p><p>以上就是Java线程锁的详解，除了从编程的角度应对高并发，更多还需要从架构设计的层面来应对高并发场景，例如：Redis缓存、CDN、异步消息等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程的由来&quot;&gt;&lt;a href=&quot;#多线程的由来&quot; class=&quot;headerlink&quot; title=&quot;多线程的由来&quot;&gt;&lt;/a&gt;多线程的由来&lt;/h2&gt;&lt;p&gt;在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java锁介绍：独享锁/共享锁+公平锁/非公平锁+乐观锁/ 悲观锁</title>
    <link href="http://yoursite.com/2019/08/23/java%E9%94%81%E4%BB%8B%E7%BB%8D%EF%BC%9A%E7%8B%AC%E4%BA%AB%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81-%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://yoursite.com/2019/08/23/java锁介绍：独享锁-共享锁-公平锁-非公平锁-乐观锁-悲观锁/</id>
    <published>2019-08-23T05:10:02.000Z</published>
    <updated>2019-08-23T05:24:14.988Z</updated>
    
    <content type="html"><![CDATA[<p><strong>该文转载于<a href="https://youzhixueyuan.com/detailed-explanation-of-java-lock.html" target="_blank" rel="noopener">java锁介绍：独享锁/共享锁+公平锁/非公平锁+乐观锁/ 悲观锁</a></strong><br>在Java并发场景中，会涉及到各种各样的锁，比如：高并发编程系列：4种常用Java线程锁的特点，性能比较、使用场景，这些锁有对应的种类：公平锁，乐观锁，悲观锁等等，这篇文章来详细介绍各种锁的分类：</p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>独享锁/共享锁</li><li>分段锁</li><li>自旋锁<a id="more"></a></li></ul><h2 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h2><p><strong>1，乐观锁</strong><br>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<br><strong>乐观锁适用于多读的应用类型</strong>，乐观锁在Java中是通过使用无锁编程来实现，<strong>最常采用的是CAS算法</strong>，Java原子类中的递增操作就通过CAS自旋实现的。<br>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>简单来说，CAS算法有3个三个操作数：</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>要写入的新值 B</li></ul><p><strong>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V</strong>。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而<strong>Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。</strong><br><strong>2,悲观锁</strong><br>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。<br>传统的MySQL关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。详情可以参考：<a href="https://youzhixueyuan.com/mysql-row-locks-table-locks-pessimistic-locks.html" target="_blank" rel="noopener">阿里P8架构师谈：MySQL行锁、表锁、悲观锁、乐观锁的特点与应用</a></p><p>再比如上面提到的Java的同步synchronized关键字的实现就是典型的悲观锁。</p><p><strong>3,总结</strong></p><ul><li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li><li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h2 id="乐观锁-VS-悲观锁-1"><a href="#乐观锁-VS-悲观锁-1" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h2><p><strong>1，公平锁</strong><br>就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。<br><strong>公平锁的优点</strong>是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p><strong>2，非公平锁</strong><br>上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。<br>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p><strong>3，典型应用</strong><br>java jdk并发包中的ReentrantLock可以指定构造函数的boolean类型来创建公平锁和非公平锁（默认）,比如：公平锁可以使用new ReentrantLock(true)实现。</p><h2 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h2><p><strong>1，独享锁</strong><br>是指该锁一次只能被一个线程所持有。<br><strong>2，共享锁</strong><br>是指该锁可被多个线程所持有。<br><strong>3，比较</strong><br>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。<br><strong>读锁的共享锁可保证并发读是非常高效的</strong>，读写，写读 ，写写的过程是互斥的。<br><strong>独享锁与共享锁也是通过AQS来实现的</strong>，通过实现不同的方法，来实现独享或者共享。<br><strong>4，AQS</strong><br>抽象队列同步器（AbstractQueuedSynchronizer，简称AQS）是用来构建锁或者其他同步组件的基础框架，它使用一个整型的volatile变量（命名为state）来维护同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><p>concurrent包的实现结构如上图所示，AQS、非阻塞数据结构和原子变量类等基础类都是基于volatile变量的读/写和CAS实现，而像Lock、同步器、阻塞队列、Executor和并发容器等高层类又是基于基础类实现。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。<br>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</p><p><strong>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;该文转载于&lt;a href=&quot;https://youzhixueyuan.com/detailed-explanation-of-java-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java锁介绍：独享锁/共享锁+公平锁/非公平锁+乐观锁/ 悲观锁&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;在Java并发场景中，会涉及到各种各样的锁，比如：高并发编程系列：4种常用Java线程锁的特点，性能比较、使用场景，这些锁有对应的种类：公平锁，乐观锁，悲观锁等等，这篇文章来详细介绍各种锁的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公平锁/非公平锁&lt;/li&gt;
&lt;li&gt;可重入锁&lt;/li&gt;
&lt;li&gt;独享锁/共享锁&lt;/li&gt;
&lt;li&gt;分段锁&lt;/li&gt;
&lt;li&gt;自旋锁
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程系列：java线程池的使用方式，核心运行原理及注意事项</title>
    <link href="http://yoursite.com/2019/08/23/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%9Ajava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/08/23/java并发编程系列：java线程池的使用方式，核心运行原理及注意事项/</id>
    <published>2019-08-22T19:25:30.000Z</published>
    <updated>2019-08-23T07:58:00.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h2><p>java中为了提高并发度，可以使用多线程共同执行，但是与此同时如果有大量的线程在短时间内被创建和销毁，会占用大量的系统时间，影响系统效率。</p><a id="more"></a><p>为了解决上述问题，<strong>java引入了线程池</strong>,可以使创建好的线程在指定的时间内由系统统一管理，而不是在执行时才创建，执行后就销毁，从而<strong>避免了频繁创建、销毁线程带来的额外的系统开销</strong>。<br>文章主要讲解<strong>线程池如何使用，以及实现原理、处理步骤，以及注意事项</strong>。</p><h2 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h2><p>以ThreadPoolExecutor为例，当我们把一个Runnable交给线程池去执行的时候，这个线程池处理的流程是这样的：</p><h2 id="线程池的使用-ThreadPoolExecutor"><a href="#线程池的使用-ThreadPoolExecutor" class="headerlink" title="线程池的使用(ThreadPoolExecutor)"></a>线程池的使用(ThreadPoolExecutor)</h2><p>在java中，线程池是Executor这个接口，具体的实现是ThreadPoolExecutor类，它是线程池中最核心的一个类，因此要理解java中的线程池，必须先了解这个类。<br><strong>ThreadPoolExecutor提供了四个构造函数</strong>，它继承自AbstractExecutorService类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//5个参数的构造函数</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">//6个参数的构造函数</span><br><span class="line">    ublic ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">//6个参数的构造函数</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">//7个参数的构造函数</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">//</span><br></pre></td></tr></table></figure><p>观察可发现，前面三个构造函数都是调用了最后一个构造函数的实现。</p><h2 id="构造函数中各个参数的含义"><a href="#构造函数中各个参数的含义" class="headerlink" title="构造函数中各个参数的含义"></a>构造函数中各个参数的含义</h2><p>1，<strong>corePoolSize(线程池的基本大小)</strong><br>当一个任务提交到线程池时，线程池会创建一个线程来执行任务，即使其他的空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池就会提前创建并启动所有基本线程。<br>2，<strong>runnableTaskQueue（任务队列）</strong><br>用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。</li><li>PriorityBlockingQueue：一个具有优先级得无限阻塞队列。<br>3，<strong>maximumPoolSize（线程池最大大小）</strong><br>线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li></ul><p>4，<em>ThreadFactory：用于设置创建线程的工厂**</em><br>可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。</p><p>5，<strong>RejectedExecutionHandler（饱和策略）</strong><br>当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。n AbortPolicy：直接抛出异常。</p><ul><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</li><li>DiscardPolicy：不处理，丢弃掉。</li><li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务</li></ul><p>6，<strong>keepAliveTime（线程活动保持时间）</strong><br>线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p><p>7，<strong>TimeUnit（线程活动保持时间的单位）</strong><br>可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</p><h2 id="线程池的注意事项"><a href="#线程池的注意事项" class="headerlink" title="线程池的注意事项"></a>线程池的注意事项</h2><p>线程池能大大提高服务器的并发性能，但使用它也会存在一定风险。与所有多线程应用程序一样，用线程池构建的应用程序容易产生各种并发问题，如对共享资源的竞争和死锁。此外，如果线程池本身的实现不健壮，或者没有合理地使用线程池，还容易导致与线程池有关的死锁、系统资源不足和线程泄漏等问题。</p><h3 id="1，建议使用new-ThreadPoolExecutor-…-的方式创建线程池"><a href="#1，建议使用new-ThreadPoolExecutor-…-的方式创建线程池" class="headerlink" title="1，建议使用new ThreadPoolExecutor(…)的方式创建线程池"></a>1，建议使用new ThreadPoolExecutor(…)的方式创建线程池</h3><p>线程池的创建不应使用<br>Executors 去创建，而应该通过 ThreadPoolExecutor<br>创建，这样可以让读者更加明确地知道线程池的参数设置、运行规则，规避资源耗尽的风险，这一点在也阿里巴巴JAVA开发手册中也有明确要求。这一点不容小觑，曾有同学因为线程池使用不当导致生产的同一台机器上部署的多个应用都因无法创建线程池而出现故障。</p><h3 id="2，合理设置线程数"><a href="#2，合理设置线程数" class="headerlink" title="2，合理设置线程数"></a>2，合理设置线程数</h3><p>线程池的工作线程数设置应根据实际情况配置，CPU密集型业务（搜索、排序等）CPU空闲时间较少，线程数不能设置太多。<br>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1。<br>如果是IO密集型任务，参考值可以设置为2*NCPU。</p><h3 id="3，设置能代表具体业务的线程名称"><a href="#3，设置能代表具体业务的线程名称" class="headerlink" title="3，设置能代表具体业务的线程名称"></a>3，设置能代表具体业务的线程名称</h3><p>这样方便通过日志的线程名称识别所属业务。具体实现可以通过指定ThreadPoolExecutor的ThreadFactory参数，如使Spring提供的CustomizableThreadFactory。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要线程池&quot;&gt;&lt;a href=&quot;#为什么需要线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要线程池&quot;&gt;&lt;/a&gt;为什么需要线程池&lt;/h2&gt;&lt;p&gt;java中为了提高并发度，可以使用多线程共同执行，但是与此同时如果有大量的线程在短时间内被创建和销毁，会占用大量的系统时间，影响系统效率。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程Synchronized同步锁</title>
    <link href="http://yoursite.com/2019/08/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BSynchronized%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    <id>http://yoursite.com/2019/08/22/Java并发编程Synchronized同步锁/</id>
    <published>2019-08-22T14:38:18.000Z</published>
    <updated>2019-08-22T18:18:18.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java并发编程与Synchronized简介"><a href="#java并发编程与Synchronized简介" class="headerlink" title="java并发编程与Synchronized简介"></a>java并发编程与Synchronized简介</h2><p>提到java并发编程我们就不得不谈到synchronized，我们现在学习synchronizd的底层原理。掌握以下知识点：</p><ul><li>1,synchronized的底层原理</li><li>2,synchronized锁与JVM的实现</li><li>3,synchronized锁升级顺序</li><li>4,synchronized锁的优劣和应用场景<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3>synchronized中文意思是”同步”,或”同步锁”。<br>synchronized的作用是保证<strong>在同一时刻，被修饰的代码块或方法只会有一个线程执行</strong>,以达到保证并发环境下的线程安全。<a id="more"></a><h3 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h3>1，synchronized的3种使用方式</li><li>修饰实例方法：作用于当前实例加锁</li><li>修饰静态方法：作用于当前类对象加锁</li><li>修饰代码块：指定加锁对象，对给定对象加锁<br>2，synchronized代码示范<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//实例方法</span><br><span class="line">public synchronized void method() &#123;</span><br><span class="line">    // 代码</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//静态方法</span><br><span class="line">public static synchronized void method() &#123;</span><br><span class="line">    // 代码</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例对象和类对象</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">    // 代码</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">synchronized (TestSyn.Class) /*类对象*/&#123;</span><br><span class="line">    // 代码</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="synchronized的底层实现"><a href="#synchronized的底层实现" class="headerlink" title="synchronized的底层实现"></a>synchronized的底层实现</h3><p>synchronized的底层实现是完全依赖于java虚拟机的。<br>所以先看看JVM内存的存储：<strong>java对象头，以及Monitor对象。</strong><br>1，<strong>java对象头</strong><br>在JVM中，对象在内存中的存储布局，可以分为三个区域：</p><ul><li>对象头(Header)</li><li>实例数据(INstance Data)</li><li>对齐填充(Padding)<br><strong>Jvva对象头主要包含两部分数据：</strong></li><li>类型指针(Mark Word)：是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li>标记字段：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、线程持有的锁、偏向线程ID、偏向时间戳等等。它是实现轻量级锁和偏向锁的关键</li></ul><p>2,<strong>java对象存储位置</strong><br>很明显synchronized使用的锁对象存储在java对象头里的<strong>标记字段</strong>里。</p><p>3，<strong>Monitor</strong><br>synchronized的对象锁，指针指向一个monitor对象(由C++实现)的起始地址，每个对象实例都会有一个monitor。<br>Monitor描述为对象监视器，可以类比为一个特殊的房间，这个房间里有一些被保护的数据，<strong>Monitor保证每次只能有一个线程进入这个房间进行访问被保护的数据</strong>，进入房间即为持有Monitor，退出房间即为释放Monitor。<br>使用synchronized加锁的同步代码块在字节码引擎中执行时，主要就是通过锁对象的monitor的取用与释放来实现的。<br>4，<strong>线程状态流转在Monitor上的实现</strong><br>描述为对象监视器，当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程：</p><ul><li>Contention:所有请求锁的线程将被首先放置到该竞争队列</li><li>Entry List：Contention List中的那些有资格成为候选人的线程被移到Entry List</li><li>Wait List：那些调用wait方法被阻塞的线程被放置到wait list。</li><li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程被称为OnDeck</li><li>owner:获得锁的线程称为owner</li><li>!Owner:释放锁的线程</li></ul><h3 id="synchronized锁的升级顺序"><a href="#synchronized锁的升级顺序" class="headerlink" title="synchronized锁的升级顺序"></a>synchronized锁的升级顺序</h3><p>锁解决了数据的安全性问题，但是同样带来的性能的下降，hotspot虚拟机的作者经过调查发现：<strong>大部分情况下，加锁的代码不仅仅存在多线程竞争，而且总是由一个线程多次获得</strong>。所以基于这样一个概率，在JDK 6之后进行了一些优化，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁、轻量级锁、自旋锁、重量级锁，锁的状态根据竞争激烈的程度从低到高不断升级。</p><p>1，<strong>偏向锁</strong><br>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其它的线程获取，则持有偏向锁的线程将永远不需要同步。<br>2，<strong>轻量级锁</strong><br>如果明显存在其它线程申请锁，那么偏向锁将很快升级为轻量级锁。<br>3，<strong>自旋锁</strong><br>自旋锁原理是如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等所持有锁的线程释放锁后立即获取锁，这样就避免用户线程和内核切换的消耗。<br>4，<strong>重量级锁</strong><br>这就是原始的synchronized的实现，重量级锁的特点：其它线程试图获得锁的时候，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java并发编程与Synchronized简介&quot;&gt;&lt;a href=&quot;#java并发编程与Synchronized简介&quot; class=&quot;headerlink&quot; title=&quot;java并发编程与Synchronized简介&quot;&gt;&lt;/a&gt;java并发编程与Synchronized简介&lt;/h2&gt;&lt;p&gt;提到java并发编程我们就不得不谈到synchronized，我们现在学习synchronizd的底层原理。掌握以下知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1,synchronized的底层原理&lt;/li&gt;
&lt;li&gt;2,synchronized锁与JVM的实现&lt;/li&gt;
&lt;li&gt;3,synchronized锁升级顺序&lt;/li&gt;
&lt;li&gt;4,synchronized锁的优劣和应用场景&lt;h3 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h3&gt;synchronized中文意思是”同步”,或”同步锁”。&lt;br&gt;synchronized的作用是保证&lt;strong&gt;在同一时刻，被修饰的代码块或方法只会有一个线程执行&lt;/strong&gt;,以达到保证并发环境下的线程安全。
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树序列化和反序列化</title>
    <link href="http://yoursite.com/2019/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/09/二叉树序列化和反序列化/</id>
    <published>2019-05-08T21:07:49.000Z</published>
    <updated>2019-05-08T21:58:05.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p>二叉树记录成文件(一般是字符串形式)的过程叫做序列化，通过文件内容重构出一颗二叉树的过程叫做二叉树的反序列化。</p><a id="more"></a><p><strong>方法一：通过先序遍历实现序列化和反序列化</strong><br><strong>序列化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public Node left;</span><br><span class="line">    public Node right;</span><br><span class="line"></span><br><span class="line">    public Node (int data) &#123;</span><br><span class="line">        this.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SerialByPre &#123;</span><br><span class="line">    //序列化代码</span><br><span class="line">public static  String serialByPre (Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">return &quot;#_&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String res = head.value + &quot;!&quot;;</span><br><span class="line">res += serialByPre(head.left);</span><br><span class="line">res += serialByPre(head.right);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">    //主函数</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Node head = new Node(1);</span><br><span class="line">head.left = new Node(2);</span><br><span class="line">head.right = new Node(3);</span><br><span class="line">head.left.left = new Node(4);</span><br><span class="line">head.left.right= new Node(5);</span><br><span class="line">head.right.left= new Node(6);</span><br><span class="line">head.right.right= new Node(7);</span><br><span class="line">String str = serialByPre(head);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反序列化：</strong><br><strong>反序列化函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Node reconByPreString (String preStr) &#123;</span><br><span class="line">String[] strs = preStr.split(&quot;_&quot;);</span><br><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">queue.offer(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">return reconPreOrder(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>reconPreNode函数：</strong><br>作用是从一个字符串重构出一棵二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   public static Node reconPreNode(Queue&lt;String&gt; queue) &#123;</span><br><span class="line">String value = queue.poll();</span><br><span class="line">if (value.equals(&quot;#&quot;)) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">Node head = new Node(Integer.valueOf(value));</span><br><span class="line">head.left = reconPreNode(queue);</span><br><span class="line">head.right = reconPreNode(queue);</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：通过先序遍历实现序列化和反序列化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static String serialByLevel (Node head) &#123;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return &quot;#_&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + &quot;_&quot;;</span><br><span class="line">    Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        if (head.left != null) &#123;</span><br><span class="line">            res += head.left.value + &quot;_&quot;;</span><br><span class="line">            queue.offer(head.left);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res += &quot;#_&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head.right != null) &#123;</span><br><span class="line">            res += head.right.value + &quot;_&quot;;</span><br><span class="line">            queue.offer(head.right);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res += &quot;#_&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   public static Node reconByLevelString(String levelStr) &#123;</span><br><span class="line">String[] values = levelStr.split(&quot;_&quot;);</span><br><span class="line">int index = 0;</span><br><span class="line">Node head = generateNodeByString(values[index++]);</span><br><span class="line">Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</span><br><span class="line">if (head != null) &#123;</span><br><span class="line">queue.offer(head);</span><br><span class="line">&#125;</span><br><span class="line">Node node = null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">node = queue.poll();</span><br><span class="line">node.left = generateNodeByString(values[index++]);</span><br><span class="line">node.right = generateNodeByString(values[index++]);</span><br><span class="line">if (node.left != null) &#123;</span><br><span class="line">queue.offer(node.left);</span><br><span class="line">&#125;</span><br><span class="line">if (node.right != null) &#123;</span><br><span class="line">queue.offer(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line">   //</span><br><span class="line">   public static Node generateNodeByString (String val) &#123;</span><br><span class="line">if (val.equals(&quot;#&quot;)) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return new Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法二是按层序列化二叉树和反序列化构造出一颗二叉树的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树的序列化和反序列化&quot;&gt;&lt;a href=&quot;#二叉树的序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;二叉树的序列化和反序列化&quot;&gt;&lt;/a&gt;二叉树的序列化和反序列化&lt;/h2&gt;&lt;p&gt;二叉树记录成文件(一般是字符串形式)的过程叫做序列化，通过文件内容重构出一颗二叉树的过程叫做二叉树的反序列化。&lt;/p&gt;
    
    </summary>
    
      <category term="二叉树" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈希函数、并查集以及布隆过滤器</title>
    <link href="http://yoursite.com/2019/05/07/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%A5%E5%8F%8A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/07/哈希函数、并查集以及布隆过滤器/</id>
    <published>2019-05-07T02:22:19.000Z</published>
    <updated>2019-05-11T11:55:02.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>也叫散列函数，一般是输入一个字符串或基本数据类型经过哈希函数得到一个唯一的固定位数的散列值。</p><a id="more"></a><h3 id="哈希函数的特点"><a href="#哈希函数的特点" class="headerlink" title="哈希函数的特点"></a>哈希函数的特点</h3><p>1，经典哈希函数输入域可以是无穷大的(比如字符串，以及常见的对象)<br>2，输出域一般是有穷的<br>3，一个输入参数多次调用同一个哈希函数得到的结果是一样的<br>4，会有两个参数的哈希值对应同一个哈希值，这个时候我们称发生了哈希碰撞<br>5，<strong>这是很重要的性质：</strong>多个输入参数输入哈希函数后，它们的返回值分布是趋向均匀的，也是哈希函数的离散型<br>如下图所示，这是这些文件的哈希码，我们一般用这个来检验我们下载下来的软件是否被篡改了：<br><img src="/picture/QQ%E6%88%AA%E5%9B%BE20190511174108.png" alt></p><p>SHA-256:表示算法返回的哈希值为256位。可以用以下代码来算哈希值进而确定我们从网络下载下来的软件是否是被篡改了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -hashfile jdk-12.exe SHA256</span><br></pre></td></tr></table></figure><p>得到的哈希值如下：<br><img src="/picture/QQ%E6%88%AA%E5%9B%BE20190511180304.png" alt><br>这个哈希值和我们在jdk官网显示出的一样，说明我们的文件并没有被篡改。<br>同样对于.zip文件也得出一个哈希码，和官网的一样。且在命令行多次调用该方法得到的哈希码都是一样的(当然前提是文件没有被改动，只修改文件名不会有影响)<br>!(/picture/QQ截图20190511180627.png)</p><p><strong>一个小技巧：</strong>可以用一个哈希函数可以改出很多个哈希函数，并且它们还是相互独立的。相互独立的意思是一个哈希函数修改后的函数的规律不会和原哈希函数有关。方法是：把得到的哈希值劈成两半，把前128位数作为哈希函数1，后128位作为哈希函数2(即假设原来的哈希函数返回值有256位)，得到h1和h2后，我们可以 使 h3 = h1 + 1 * h2，这样得到h3这个新的哈希函数。h4 = h1 + 2 * h2, h5 = h1 + 3 * h2，以此类推可以得到多个相互独立的哈希值(然后它们对应相应的哈希函数)。甚至仅仅改变系数就可以得到很多个不同的哈希函数。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>定义：散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。(来自百度百科)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;哈希函数&quot;&gt;&lt;a href=&quot;#哈希函数&quot; class=&quot;headerlink&quot; title=&quot;哈希函数&quot;&gt;&lt;/a&gt;哈希函数&lt;/h2&gt;&lt;p&gt;也叫散列函数，一般是输入一个字符串或基本数据类型经过哈希函数得到一个唯一的固定位数的散列值。&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>打印二叉树边界节点</title>
    <link href="http://yoursite.com/2019/05/05/%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2019/05/05/打印二叉树边界节点/</id>
    <published>2019-05-05T03:22:40.000Z</published>
    <updated>2019-05-05T15:50:03.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打印二叉树边界节点"><a href="#打印二叉树边界节点" class="headerlink" title="打印二叉树边界节点"></a>打印二叉树边界节点</h2><p>打印二叉树的边界节点</p><a id="more"></a><p>对于边界点有如下定义(标准一)：</p><ul><li>1,头节点是边界节点</li><li>2，叶节点也是边界节点</li><li>3，如果节点在其所在的层中是最左或最右的，那也是边界节点</li></ul><p>定义二(或标准二)：</p><ul><li>1，头节点是边界节点</li><li>2，叶节点是边界节点</li><li>3，树左边界延伸下去的路径是边界节点</li><li>4，树右边界延伸下去的路径是边界节点<br><strong>按照标准一打印：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class Node1 &#123;</span><br><span class="line">public int value;</span><br><span class="line">public Node1  left;</span><br><span class="line">public Node1  right;</span><br><span class="line"></span><br><span class="line">public Node1 (int data) &#123;</span><br><span class="line">value = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PrintBinaryTreeEdge1 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void printEdge1 (Node1 head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int height = getHeight(head, 0);</span><br><span class="line">Node1[][] edgeMap = new Node1[height][2];</span><br><span class="line">setEdgeMap(head, 0, edgeMap);</span><br><span class="line">//打印左边界</span><br><span class="line">for (int i = 0; i != edgeMap.length; i++) &#123;</span><br><span class="line">System.out.print(edgeMap[i][0].value + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">//打印既不是左边界，也不是有边界的叶节点</span><br><span class="line">printLeafNotInMap(head, 0, edgeMap);</span><br><span class="line">//打印右边界，但不是左边界的节点</span><br><span class="line">for (int i = edgeMap.length - 1; i != -1; i--) &#123;</span><br><span class="line">if (edgeMap[i][0] != edgeMap[i][1]) &#123;</span><br><span class="line">System.out.print(edgeMap[i][1].value + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public static int getHeight (Node1 h, int l ) &#123;</span><br><span class="line">if (h == null) &#123;</span><br><span class="line">return l;</span><br><span class="line">&#125;</span><br><span class="line">return Math.max(getHeight(h.left, l + 1), getHeight(h.right, l + 1));</span><br><span class="line">&#125;</span><br><span class="line">public static void setEdgeMap(Node1 h, int ll, Node1[][] edgeMap) &#123;</span><br><span class="line">if (h == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">edgeMap[ll][0] = edgeMap[ll][0] == null ? h : edgeMap[ll][0];</span><br><span class="line">edgeMap[ll][1] = h;</span><br><span class="line">setEdgeMap(h.left, ll + 1, edgeMap);</span><br><span class="line">setEdgeMap(h.right, ll + 1, edgeMap);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public static void printLeafNotInMap (Node1 h, int l, Node1[][] m) &#123;</span><br><span class="line">if (h == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (h.left == null &amp;&amp; h.right == null &amp;&amp; h != m[l][0] &amp;&amp; h != m[l][1]) &#123;</span><br><span class="line">System.out.print(h.value + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">printLeafNotInMap(h.left, l + 1, m);</span><br><span class="line">printLeafNotInMap(h.right, l + 1, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    //主方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Node1 head = new Node1(1);</span><br><span class="line">head.left = new Node1(2);</span><br><span class="line">head.right = new Node1(3);</span><br><span class="line">head.left.left = new Node1(4);</span><br><span class="line">head.left.right= new Node1(5);</span><br><span class="line">head.right.left= new Node1(6);</span><br><span class="line">head.right.right= new Node1(7);</span><br><span class="line">printEdge1(head);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>按照标准二打印：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void printEdge2 (Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(head.value + &quot; &quot;);</span><br><span class="line">if (head.left != null &amp;&amp; head.right != null) &#123;</span><br><span class="line">printLeftEgde(head.left, true);</span><br><span class="line">printRightEdge(head.right, true);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printEdge2(head.left != null ? head.left : head.right);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">//打印左边界</span><br><span class="line">public static void printLeftEgde (Node h, boolean print) &#123;</span><br><span class="line">if (h == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (print || (h.left == null &amp;&amp; h.right == null)) &#123;</span><br><span class="line">System.out.print(h.value + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">printLeftEgde(h.left, print);</span><br><span class="line">printLeftEgde(h.right, print &amp;&amp; h.left == null ? true : false);</span><br><span class="line">&#125;</span><br><span class="line">//打印右边界</span><br><span class="line">public static void printRightEdge (Node h, boolean print) &#123;</span><br><span class="line">if (h == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">printRightEdge(h.left, print &amp;&amp; h.right == null ? true : false);</span><br><span class="line">printLeftEgde(h.right, print);</span><br><span class="line">if (print || (h.left == null &amp;&amp; h.right == null)) &#123;</span><br><span class="line">System.out.print(h.value + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;打印二叉树边界节点&quot;&gt;&lt;a href=&quot;#打印二叉树边界节点&quot; class=&quot;headerlink&quot; title=&quot;打印二叉树边界节点&quot;&gt;&lt;/a&gt;打印二叉树边界节点&lt;/h2&gt;&lt;p&gt;打印二叉树的边界节点&lt;/p&gt;
    
    </summary>
    
      <category term="二叉树" scheme="http://yoursite.com/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>信封嵌套问题</title>
    <link href="http://yoursite.com/2019/05/01/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/01/信封嵌套问题/</id>
    <published>2019-04-30T18:11:15.000Z</published>
    <updated>2019-04-30T21:15:27.254Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个N行2列的二维数组arr，每一个小数组的两个值分别代表一个信封的长和宽，如果信封A的长和宽小于信封B，那么信封A可以放在信封B里，返回信封最多可以嵌套多少层。</p><a id="more"></a><p>例：arr = {<br>    {3,4}<br>    {2,3}<br>    {4,5}<br>    {1,3}<br>    {2,3}<br>    {3,6}<br>    {1,2}<br>    {3,2}<br>    {2,4}<br>}<br>信封最多可以嵌套4层，从里到外分别是{1,2} {2,3} {3,4} {4,5}，所以返回4。<br>此问题与<strong>最长增长子序列</strong>问题思想类似。</p><p>把N个长度为2的小数组变成信封数组。然后对信封数组排序，排序的策略为：按照长度从小到大排序，长度相等的信封之间按照宽度从大到小排序，代码如下：<br>//定义信封类以及信封的长和宽信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Envelope &#123;</span><br><span class="line">public int len;</span><br><span class="line">public int wid;</span><br><span class="line"></span><br><span class="line">public Envelope (int len,int wid) &#123;</span><br><span class="line">this.len = len;</span><br><span class="line">this.wid = wid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//定义类进行信封的比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class EnvelopeComparator implements Comparator&lt;Envelope&gt; &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compare(Envelope o1, Envelope o2) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return o1.len != o2.len ? o1.len - o2.len : o2.wid - o1.wid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class MostEnvelope &#123;</span><br><span class="line"></span><br><span class="line">public static Envelope[] getSortedEnvelopes (int[][] matrix) &#123;</span><br><span class="line">Envelope[] res = new Envelope[matrix.length];</span><br><span class="line">for (int i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">res[i] = new Envelope(matrix[i][0], matrix[i][1]);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.parallelSort(res,new EnvelopeComparator());</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">//这是主方法</span><br><span class="line">public static int maxEnvelopes(int[][] matrix) &#123;</span><br><span class="line">Envelope[] envelopes = getSortedEnvelopes(matrix);</span><br><span class="line">int[] ends = new int[matrix.length];</span><br><span class="line">ends[0] = envelopes[0].wid;</span><br><span class="line"></span><br><span class="line">int right = 0;</span><br><span class="line">int l = 0;</span><br><span class="line">int r = 0;</span><br><span class="line">int m = 0;</span><br><span class="line">for (int i = 1;i &lt; envelopes.length;i++) &#123;</span><br><span class="line">l = 0;</span><br><span class="line">r = right;</span><br><span class="line">while (l &lt;= r) &#123;</span><br><span class="line">m = (l + r) / 2;</span><br><span class="line">if (envelopes[i].wid &gt;ends[m]) &#123;</span><br><span class="line">l = m + 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">r = m - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">right = Math.max(right, l);</span><br><span class="line">ends[l] = envelopes[i].wid;</span><br><span class="line">&#125;</span><br><span class="line">return right + 1;</span><br><span class="line">&#125;</span><br><span class="line">    //测试代码</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">        //定义数组</span><br><span class="line">int[][] matrix = &#123; &#123;2,3&#125;,&#123;4,5&#125;,&#123;3,4&#125;,&#123;2,2&#125;,&#123;2,4&#125;,&#123;3,6&#125;&#125;;</span><br><span class="line">System.out.println(maxEnvelopes(matrix));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个N行2列的二维数组arr，每一个小数组的两个值分别代表一个信封的长和宽，如果信封A的长和宽小于信封B，那么信封A可以放在信封B里，返回信封最多可以嵌套多少层。&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长增长子序列</title>
    <link href="http://yoursite.com/2019/04/27/%E6%9C%80%E9%95%BF%E5%A2%9E%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/04/27/最长增长子序列/</id>
    <published>2019-04-27T09:04:57.000Z</published>
    <updated>2019-04-27T09:22:27.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长增长子序列"><a href="#最长增长子序列" class="headerlink" title="最长增长子序列"></a>最长增长子序列</h2><p>给定一个数组arr，返回arr的最长增长子序列，例，arr = {7,1,9,3,8,19},最长增长子序列为 {1,3,8,19}。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public static int[] generateLIS (int[] arr,int[] dp) &#123;</span><br><span class="line">int len = 0;</span><br><span class="line">int index = 0;</span><br><span class="line">for (int i = 0;i &lt; dp.length;i ++) &#123;</span><br><span class="line">if (dp[i] &gt; len) &#123;</span><br><span class="line">len = dp[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int[] lis = new int[len];</span><br><span class="line">lis[--len] = arr[index];</span><br><span class="line">for (int i = index;i &gt;= 0;i--) &#123;</span><br><span class="line">if (arr[i] &lt; arr[index] &amp;&amp; dp[i] == dp[index] - 1) &#123;</span><br><span class="line">lis[--len] = arr[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return lis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   public static int[] getdp1 (int[] arr) &#123;</span><br><span class="line">int[] dp = new int[arr.length];</span><br><span class="line">for (int i = 0;i &lt; arr.length;i++) &#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">for (int j = 0;j &lt; i;j++) &#123;</span><br><span class="line">if (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最长增长子序列&quot;&gt;&lt;a href=&quot;#最长增长子序列&quot; class=&quot;headerlink&quot; title=&quot;最长增长子序列&quot;&gt;&lt;/a&gt;最长增长子序列&lt;/h2&gt;&lt;p&gt;给定一个数组arr，返回arr的最长增长子序列，例，arr = {7,1,9,3,8,19},最长增长子序列为 {1,3,8,19}。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   public static int[] generateLIS (int[] arr,int[] dp) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int len = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int index = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int i = 0;i &amp;lt; dp.length;i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (dp[i] &amp;gt; len) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			len = dp[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			index = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int[] lis = new int[len];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	lis[--len] = arr[index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int i = index;i &amp;gt;= 0;i--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (arr[i] &amp;lt; arr[index] &amp;amp;&amp;amp; dp[i] == dp[index] - 1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			lis[--len] = arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			index = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return lis;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>换钱的方法数</title>
    <link href="http://yoursite.com/2019/04/25/%E6%8D%A2%E9%92%B1%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0/"/>
    <id>http://yoursite.com/2019/04/25/换钱的方法数/</id>
    <published>2019-04-24T16:17:34.000Z</published>
    <updated>2019-04-25T04:17:57.669Z</updated>
    
    <content type="html"><![CDATA[<p><strong>换钱的方法数</strong><br>给定数组arr，arr中的值都为正数且不重复，每一个值代表一种货币面值，每种面值的货币可使用任意张，再给定一个正数aim，代表要找的钱数，求换钱有多少种方法。</p><a id="more"></a><p>举例：<br>arr = [5,10,25,1],aim = 0;方法有1种，即所有面值的货币都不适用，返回1。<br>arr = [5,10,25,1],aim = 15;方法有6种，3张5元；1张10元、1张5元；1张10元、、5张1元；10张1元、1张5元；2张5元、5张1元；15张1元，所以返回6。</p><p><strong>递归方法</strong><br>递归方法代码如下：<br>主方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   public static int coins1(int[] arr,int aim) &#123;</span><br><span class="line"></span><br><span class="line">if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return process1(arr,0,aim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int process1 (int[] arr,int index,int aim) &#123;</span><br><span class="line">int res = 0;</span><br><span class="line">if (index == arr.length) &#123;</span><br><span class="line">res = aim == 0 ? 1 : 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (int i = 0;arr[index] * i &lt;= aim;i++) &#123;</span><br><span class="line">res += process1(arr, index + 1, aim - arr[index] * i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;换钱的方法数&lt;/strong&gt;&lt;br&gt;给定数组arr，arr中的值都为正数且不重复，每一个值代表一种货币面值，每种面值的货币可使用任意张，再给定一个正数aim，代表要找的钱数，求换钱有多少种方法。&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>换钱最少货币数</title>
    <link href="http://yoursite.com/2019/04/24/%E6%8D%A2%E9%92%B1%E6%9C%80%E5%B0%91%E8%B4%A7%E5%B8%81%E6%95%B0/"/>
    <id>http://yoursite.com/2019/04/24/换钱最少货币数/</id>
    <published>2019-04-23T16:36:50.000Z</published>
    <updated>2019-04-24T13:20:40.159Z</updated>
    
    <content type="html"><![CDATA[<p>给定数组arr，arr中所有的值都为正数且不重复，每个值代表一种面值的货币，每种面的值货币可以使用任意张，再给定一个正数aim，代表要找的钱数，求组成aim的最少货币数。</p><a id="more"></a><p>举例：arr=[5,2,3]，aim = 20。<br>4张5元可以组成20元，其它的方法都会需要更多的方法数，所以返回4。<br>arr=[5,2,3]，aim=0。<br>不用任何货币就可以组成0元，返回0；<br>arr=[5,2,3]，aim=2。<br>根本就无法组成2元，钱找不开的情况下默认返回-1。<br><strong>暴力递归的方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   //</span><br><span class="line">   public static int minCoins (int[] arr,int aim) &#123;</span><br><span class="line">if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">return process(arr,0,aim);</span><br><span class="line">&#125;</span><br><span class="line">   //当前考虑的是面值i，还剩rest的钱需要找零</span><br><span class="line">   //如果返回-1，说明使用arr[i..N-1]面值的情况下，无论如何也无法找零rest</span><br><span class="line">   //如果返回不是-1，代表自由使用arr[i..N-1]面值的情况下，找零rest需要的最少张数</span><br><span class="line">public static int process  (int[] arr,int i,int rest) &#123;</span><br><span class="line">       //base case</span><br><span class="line">       //已经没有面值能够考虑了</span><br><span class="line">       //如果此时剩余的钱为0，返回0张</span><br><span class="line">       //如果此时剩余的钱不是0，返回-1</span><br><span class="line">if (i == arr.length) &#123;</span><br><span class="line">return rest == 0 ? 0 : -1;</span><br><span class="line">&#125;</span><br><span class="line">       //最少张数，初始值为-1，还没找到有效解</span><br><span class="line">int res = -1;</span><br><span class="line">       //依次尝试使用当前的面值(arr[i])0张、1张、k张，但不能超过rest</span><br><span class="line">for (int k = 0;k * arr[i] &lt;= rest;k++) &#123;</span><br><span class="line">           //使用了k张arr[i]，剩余的钱为rest - k * arr[i]</span><br><span class="line">           //交给剩下的面值去搞定(arr[i+1...N-1])</span><br><span class="line">int next = process(arr,i + 1,rest - k * arr[i]);</span><br><span class="line">if (next != -1) &#123;//说明后续过程有效</span><br><span class="line">res = res == -1 ? next + k : Math.min(res, next + k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划的方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   public static int minCoins2 (int[] arr,int aim) &#123;</span><br><span class="line">if (arr == null || arr.length == 0 || aim &lt; 0) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int N = arr.length;</span><br><span class="line">int[][] dp = new int[N + 1][aim + 1];</span><br><span class="line">//设置最后一排的值，除dp[N][0]为0外，其余都是-1</span><br><span class="line">for (int col = 1;col &lt;= aim;col++) &#123;</span><br><span class="line">dp[N][col] = -1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = N - 1;i &gt;= 0;i++) &#123;//从底往上计算每一行</span><br><span class="line">for (int rest = 0;rest &lt;= aim;rest++) &#123;//每一行都从左往右</span><br><span class="line">dp[i][rest] = -1;//初始时先设置dp[i][rest]的值无效</span><br><span class="line">if (dp[i + 1][rest] != -1) &#123;//下面的值如果有效</span><br><span class="line">dp[i][rest] = dp[i + 1][rest];//先设置成下面的值</span><br><span class="line">&#125;</span><br><span class="line">               //如果左边的位置不越界且有效</span><br><span class="line">if (rest - arr[i] &gt;= 0 &amp;&amp; dp[i][rest] - arr[i] != -1) &#123;</span><br><span class="line">if (dp[i][rest] == -1) &#123;//如果之前下面的值无效</span><br><span class="line">dp[i][rest] = dp[i][rest - arr[i]] + 1;</span><br><span class="line">&#125; else &#123;//说明下面和左边的值都有效，取最小的</span><br><span class="line">dp[i][rest] = Math.min(dp[i][rest], dp[i][rest - arr[i]] + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[0][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定数组arr，arr中所有的值都为正数且不重复，每个值代表一种面值的货币，每种面的值货币可以使用任意张，再给定一个正数aim，代表要找的钱数，求组成aim的最少货币数。&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器人达到指定位置方法数</title>
    <link href="http://yoursite.com/2019/04/23/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BE%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E6%95%B0/"/>
    <id>http://yoursite.com/2019/04/23/机器人达到指定位置方法数/</id>
    <published>2019-04-23T05:18:45.000Z</published>
    <updated>2019-05-06T19:21:19.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器人达到指定位置方法数"><a href="#机器人达到指定位置方法数" class="headerlink" title="机器人达到指定位置方法数"></a>机器人达到指定位置方法数</h2><p>问题概述：动态规划的题目，假设有N个位置，N大于等于2。开始机器人在其中的某个位置(M位置,M一定是1到N的某一个),机器人可以往左走或往右走，在位置1则只能往右走到位置2，同理在位置N只能往左走到N-1位置。在除了这两个位置的其它位置则可以往左或往右；规定机器人走K步，最终能来到P位置(P也是1到N位置中的一个)的方法有多少种，给定四个参数N、M、K、P，返回方法数。</p><a id="more"></a><p><strong>暴力递归的方法</strong><br>分析：各个参数的意义：</p><p>N：位置1 ~ N，是固定参数<br>cur：当前位置cur，可变参数<br>rest：还剩rest步没走，可变参数<br>P：最终的目标位置，固定参数</p><p>walk方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int walk (int N,int cur,int rest,int p) &#123;</span><br><span class="line">   //剩余步数为0，当前位置就是最后的位置，看是否是位置P，是就找到一种方法返回1，否则就说明这种方法到不了///目标位置返回0</span><br><span class="line">if (rest == 0) &#123;</span><br><span class="line">return cur == p ? 1 : 0;</span><br><span class="line">&#125;</span><br><span class="line">   //在1位置，只能向右走，所以来到2位置</span><br><span class="line">if (cur == 1) &#123;</span><br><span class="line">return walk(N,2,rest - 1,p);</span><br><span class="line">&#125;</span><br><span class="line">   //在N位置，那么下一步只能向左走，所以来到N - 1位置</span><br><span class="line">if (cur == N) &#123;</span><br><span class="line">return walk(N, N - 1, rest - 1, p);</span><br><span class="line">&#125;</span><br><span class="line">   //在1和N位置外的其它位置，可以向右向左，要算上它们各自的方法总和</span><br><span class="line">return walk(N,cur + 1,rest - 1, p) + walk(N,cur - 1,rest - 1, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int ways1 (int N,int M,int K,int P) &#123;</span><br><span class="line">if (N &lt; 2 || K&lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return walk(N,M,K,P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在mian方法里这样调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int N = 6,M = 1,K = 8,P = 3;</span><br><span class="line">//返回28，说明有28种方法</span><br><span class="line">System.out.println(ways1(N,M,K,P));</span><br></pre></td></tr></table></figure><p><strong>动态规划的方法</strong><br>时间复杂度:O(N * K)<br>从暴力递归的方法来优化成动态规划，在这个过程中，一旦写出了尝试函数，后续的优化过程都是很固定的。<br>这个例子中，首先根据walk方法的含义结合题意，分析整个过程是不是无后效性的。利用尝试方法去解决的问题，绝大多数都是无后效性的，有后效性的递归过程在面试过程中极其少见。所谓<strong>无后效性，就是指一个递归状态的返回值与怎么达到这个状态的路径无关</strong>。</p><p>本题中的walk函数N、P，任何时候都不变，<strong>说明N、P与具体的递归状态无关</strong>，忽略他们。只需要关注cur和rest两个参数，也就是当前来到的位置和剩余的步数。walk(cur,rest)的含义是：当前来到cur位置，还剩下rest位置可以走，那么有多少种方法走到目标P位置。例如walk(5,7)，代表来到5位置，还可以走7步，最终到达P有多少种方式，如下图画出了求出walk(5,7)状态的依赖树：<br><img src="/picture/zhuangtai.png" alt><br>上图walk(5,5)状态出现了两次，含义是当前来到5位置，还剩5步，有效方法有多少种。那么最终的返回值与怎么到达这个状态的路径有关系吗？没有。不管是从walk(4,6)来到walk(5,5)还是从walk(6,6)来到walk(5,5),只要是”当前来到5位置，还剩5步”这个问题，返回值都是不变的，这就是一个无后效性问题。一旦问题经论证是无后效性的就可以按一下步骤进行优化成动态规划：</p><ul><li>1，找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了</li><li>2，把可变参数的所有组合映射成一张表，有1个可变参数就是1维表，2个就是二维表，依此类推</li><li>3，最终答案要的是表中的哪个位置，在表中标出</li><li>4，根据递归过程的base case，把这张表最简单、不需要依赖其他位置的那些位置填好值</li><li>5，根据递归过程非base case的部分，也就是分析表中的普遍位置需要怎么计算得到，那么这张表的填写顺序也就确定了</li><li>6，填好表，返回最终答案填在表中位置的值</li></ul><p>接下来我们以N = 7，M = 4，K = 9，P = 5 为例来走一下这个过程。<br>过程：</p><ul><li><p>1，walk函数中，可变参数cur和rest一旦确定，返回值就确定了</p></li><li><p>2，有cur和rest两个可变参数，所以是一个二维表。<br><a href="/picture/erwei.png"></a></p></li><li><p>3,N = 7,M = 4,K = 9, P = 5的最终答案，就是dp[9][4]的值</p></li><li><p>4，递归过程的base case是指问题规模小到什么程度，就不需要再划分子问题，答案就可以直接得到了。walk函数的base case如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (rest == 0) &#123; return cur == P ? 1 : 0 &#125;。</span><br></pre></td></tr></table></figure><p>当rest = 0，cur = pP，返回1，否则返回0，本例中P = 5，所以可以把表中的第一行填好，表中的第一行所有状态都是最简单且不需要依赖其他位置的。</p></li><li><p>5，base case之外的位置，在walk函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  if (cur == 1) &#123;</span><br><span class="line">return walk(N,2,rest - 1,p);</span><br><span class="line">&#125;</span><br><span class="line">if (cur == N) &#123;</span><br><span class="line">return walk(N, N - 1, rest - 1, p);</span><br><span class="line">&#125;</span><br><span class="line">  return walk(N,cur + 1,rest - 1, p) + walk(N,cur - 1,rest - 1, p);</span><br></pre></td></tr></table></figure><p>若cur在1位置，最终返回dp[rest][cur] = dp[rest - 1][2],若在N位置，最终返回值dp[rest][cur] = dp[rest - 1][N - 1],若cur在中间位置，dp[rest][cur] = dp[rest - 1][cur - 1] + dp[rest - 1][cur + 1]。<br><img src="/picture/" alt><br>说明每一行的值都仅仅依赖上一行的值，那么有了上一行的值，就可以推出整张表整张表的值如下所示。<br><img src="/picture/" alt></p></li><li><p>6,返回dp[9][4]，结果为116</p></li></ul><p>动态规划方法实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   public static int ways2 (int N,int M,int K,int P) &#123;</span><br><span class="line">if (N &lt; 2 || K &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int[][] dp = new int[K + 1][1 + N];</span><br><span class="line">dp[0][P] = 1;</span><br><span class="line">for (int i = 1;i &lt;= K;i++) &#123;</span><br><span class="line">for (int j = 1;j &lt;= N;j++) &#123;</span><br><span class="line">if (j == 1) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][2]; </span><br><span class="line">&#125; else if (j == N) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][N - 1];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[K][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划+空间压缩的方法</strong><br>与最短路径和的空间压缩技巧一样，这就是动态规划 + 空间压缩的方法。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   public static int ways3 (int N,int M,int K,int P) &#123;</span><br><span class="line">if (N &lt; 2 || K &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int[] dp = new int[N + 1];</span><br><span class="line">dp[P] = 1;</span><br><span class="line">for(int i = 1;i &lt;= K;i++) &#123;</span><br><span class="line">int leftUp = dp[1];</span><br><span class="line">for (int j = 1;j &lt;= N;j++) &#123;</span><br><span class="line">int tmp = dp[j];</span><br><span class="line">if (j == 1) &#123;</span><br><span class="line">dp[j] = dp[j +1];</span><br><span class="line">&#125; else if (j == N) &#123;</span><br><span class="line">dp[j] = leftUp;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dp[j] = leftUp + dp[j + 1];</span><br><span class="line">&#125; </span><br><span class="line">leftUp = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;机器人达到指定位置方法数&quot;&gt;&lt;a href=&quot;#机器人达到指定位置方法数&quot; class=&quot;headerlink&quot; title=&quot;机器人达到指定位置方法数&quot;&gt;&lt;/a&gt;机器人达到指定位置方法数&lt;/h2&gt;&lt;p&gt;问题概述：动态规划的题目，假设有N个位置，N大于等于2。开始机器人在其中的某个位置(M位置,M一定是1到N的某一个),机器人可以往左走或往右走，在位置1则只能往右走到位置2，同理在位置N只能往左走到N-1位置。在除了这两个位置的其它位置则可以往左或往右；规定机器人走K步，最终能来到P位置(P也是1到N位置中的一个)的方法有多少种，给定四个参数N、M、K、P，返回方法数。&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态归化以及空间压缩</title>
    <link href="http://yoursite.com/2019/04/22/%E5%8A%A8%E6%80%81%E5%BD%92%E5%8C%96%E4%BB%A5%E5%8F%8A%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2019/04/22/动态归化以及空间压缩/</id>
    <published>2019-04-22T15:25:22.000Z</published>
    <updated>2019-04-23T15:48:04.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划类算法题"><a href="#动态规划类算法题" class="headerlink" title="动态规划类算法题"></a>动态规划类算法题</h2><p>动态规划相关以及动态规划的空间压缩方法。</p><a id="more"></a><h3 id="1-矩阵的最小路径和"><a href="#1-矩阵的最小路径和" class="headerlink" title="1,矩阵的最小路径和"></a>1,矩阵的最小路径和</h3><p>一个矩阵n，从左上角到右下角，路径上所有的数字累加起来就是路径和，返回左右路径和中最小的值。<br>例如，给定一个矩阵，n[0] = {1,3,5,9},n[1] = {8,1,3,4},n[2] = {5,0,6,1},n[3] = {8,8,4,0},路径1,3,1,0,6,1,0是最小的路径和所以返回12，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 9</span><br><span class="line">8 1 3 4</span><br><span class="line">5 0 6 1 </span><br><span class="line">8 8 4 0</span><br></pre></td></tr></table></figure><p><strong>经典动态规划的解法</strong><br>解答：这是经典的动态规划算法，假设矩阵N大小为m*n，先生成大小和N一样的矩阵dp，dp[i][j]就是表示从左上角(0,0)位置走到(i,j)位置的最小路径和。对N的第一行位置来说，(0,j)(0 &lt;= j &lt; n)，从(0,0)位置走到(0,j)位置只能向右走，所以从(0,0)位置到(0,j)的路径和就是N[0][0…j]这些值得累加结果。同理对于N的每一列来说，即(i,0)(0 &lt;= i &lt; m),从(0,0)位置到(i,0)位置的路径和就是N[0…i][0]相加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 4 9 18</span><br><span class="line">9</span><br><span class="line">14</span><br><span class="line">22</span><br></pre></td></tr></table></figure><p>可以发现除了第一行和第一列的位置外其它所有的位置(i,j)都有左边位置(i,j-1)和上面位置(i-1,j),从(0,0)到(i,j)的路径必经过位置(i,j)和位置(i-1,j)，所以dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + N[i][j]。最终生成的dp矩阵如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   4   9   18</span><br><span class="line">9   5   8   12       </span><br><span class="line">14  5   11  12</span><br><span class="line">22  13  15  12</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int minPath (int[][] m) &#123;</span><br><span class="line">if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int row = m.length;</span><br><span class="line">int column = m[0].length;</span><br><span class="line">int[][] dp = new int[row][column];</span><br><span class="line">dp[0][0] = m[0][0];</span><br><span class="line"></span><br><span class="line">for (int i=1;i&lt;row;i++) &#123;</span><br><span class="line">dp[i][0] = dp[i-1][0] + m[i][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i=1;i&lt;column;i++) &#123;</span><br><span class="line">dp[0][i] = dp[0][i-1] + m[0][i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i =1;i &lt; row;i++) &#123;</span><br><span class="line">for (int j = 1;j &lt; column;j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dp[row - 1][column - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<strong>时间复杂度为O(m * n)</strong>，dp矩阵的大小为m * n，所以<strong>额外空间复杂度为O(m * n)</strong>。</p><p><strong>动态规划 + 空间压缩的方法</strong><br>经过空间压缩后的方法时间复杂度仍然是O(m * n)，但是额外空间复杂度会减小至O(min(m,n))，也就是不使用大小为m * n的矩阵，而仅仅使用大小为min(m,n)的数组，具体过程如下：</p><ul><li>1，生成长度为min(m,n)(也就是行数和列数较小的那个值，在这个例子为4)的数组arr,初始值为arr=[0,0,0,0]，从(0,0)位置到达m中第一行的每一个位置，最小路径就是从(0,0)位置开始累加的结果，所以依次把arr设置为arr=[1,4,9,18]，此时arr[j]的值代表从(0,0)位置到(0,j)位置的最小路径和。</li><li>2，步骤1是代表的是从(0,0)到(0,j)的最小路径和，现在想把arr[j]的值更新从(0,0)到(1,j)位置的最小路径和。可知对于arr[0]来说，令arr[0] = arr[0]  + m[1,0] = 9,即从(0,0)到(1,0)的最小路径和。至于(1,1)位置，此时有两种路径，从(1,0)到(1,1)、从(0,1)到(1,1)，arr[1] = min(arr[0],arr[1]) + m[1][1]，更新后arr[1]就成为dp[1][1]的值。同理arr[2] = min(arr[1],arr[2]) + m[1][2]，依次类推，最终arr可以更新成[9,5,8,12]。</li><li>3，重复步骤2，一直到arr彻底变成dp矩阵的最后一行，整个过程其实就是不听滚动更新arr数组，让arr依次变成dp矩阵每一行的值，最终变成最后一行的值。<br>如果矩阵的列数小于行数(M&gt;N)，依然可以用上面的方法更新成dp矩阵每一行的值。但如果给定的列数大于行数(M&lt;N),那么就生成长度为M的arr，然后更新成dp矩阵的每一列值，从左到右滚动过去。<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static int minPath2(int[][] m) &#123;</span><br><span class="line">if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int more = Math.max(m.length, m[0].length);//行数与列数较大的那个为more</span><br><span class="line">int less = Math.min(m.length, m[0].length);//行数与列数较小的那个为less</span><br><span class="line">boolean rowmore = more == m.length;//行数是不是大于或等于列数</span><br><span class="line">int[] arr  = new int[less];</span><br><span class="line">arr[0] = m[0][0];</span><br><span class="line">for (int i = 1;i &lt; less;i++) &#123;</span><br><span class="line">arr[i] = arr[i - 1] + (rowmore ? m[0][i] : m[i][0]);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1;i &lt; more;i++) &#123;</span><br><span class="line">arr[0] = arr[0] + (rowmore ? m[i][0] : m[0][i]);</span><br><span class="line">for (int j = 1;j &lt; less;j++) &#123;</span><br><span class="line">arr[j] = Math.min(arr[j - 1], arr[j]) +</span><br><span class="line">(rowmore ? m[i][j] : m[j][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return arr[less - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划类算法题&quot;&gt;&lt;a href=&quot;#动态规划类算法题&quot; class=&quot;headerlink&quot; title=&quot;动态规划类算法题&quot;&gt;&lt;/a&gt;动态规划类算法题&lt;/h2&gt;&lt;p&gt;动态规划相关以及动态规划的空间压缩方法。&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态归化以及空间压缩</title>
    <link href="http://yoursite.com/2019/04/22/%E5%8A%A8%E6%80%81%E5%BD%92%E5%8C%96%E4%BB%A5%E5%8F%8A%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9(%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C)/"/>
    <id>http://yoursite.com/2019/04/22/动态归化以及空间压缩(矩阵最小路径和)/</id>
    <published>2019-04-22T15:25:22.000Z</published>
    <updated>2019-04-23T15:52:09.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划类算法题"><a href="#动态规划类算法题" class="headerlink" title="动态规划类算法题"></a>动态规划类算法题</h2><p>动态规划相关以及动态规划的空间压缩方法。</p><a id="more"></a><h3 id="1-矩阵的最小路径和"><a href="#1-矩阵的最小路径和" class="headerlink" title="1,矩阵的最小路径和"></a>1,矩阵的最小路径和</h3><p>一个矩阵n，从左上角到右下角，路径上所有的数字累加起来就是路径和，返回左右路径和中最小的值。<br>例如，给定一个矩阵，n[0] = {1,3,5,9},n[1] = {8,1,3,4},n[2] = {5,0,6,1},n[3] = {8,8,4,0},路径1,3,1,0,6,1,0是最小的路径和所以返回12，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 9</span><br><span class="line">8 1 3 4</span><br><span class="line">5 0 6 1 </span><br><span class="line">8 8 4 0</span><br></pre></td></tr></table></figure><p><strong>经典动态规划的解法</strong><br>解答：这是经典的动态规划算法，假设矩阵N大小为m*n，先生成大小和N一样的矩阵dp，dp[i][j]就是表示从左上角(0,0)位置走到(i,j)位置的最小路径和。对N的第一行位置来说，(0,j)(0 &lt;= j &lt; n)，从(0,0)位置走到(0,j)位置只能向右走，所以从(0,0)位置到(0,j)的路径和就是N[0][0…j]这些值得累加结果。同理对于N的每一列来说，即(i,0)(0 &lt;= i &lt; m),从(0,0)位置到(i,0)位置的路径和就是N[0…i][0]相加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 4 9 18</span><br><span class="line">9</span><br><span class="line">14</span><br><span class="line">22</span><br></pre></td></tr></table></figure><p>可以发现除了第一行和第一列的位置外其它所有的位置(i,j)都有左边位置(i,j-1)和上面位置(i-1,j),从(0,0)到(i,j)的路径必经过位置(i,j)和位置(i-1,j)，所以dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + N[i][j]。最终生成的dp矩阵如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   4   9   18</span><br><span class="line">9   5   8   12       </span><br><span class="line">14  5   11  12</span><br><span class="line">22  13  15  12</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int minPath (int[][] m) &#123;</span><br><span class="line">if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int row = m.length;</span><br><span class="line">int column = m[0].length;</span><br><span class="line">int[][] dp = new int[row][column];</span><br><span class="line">dp[0][0] = m[0][0];</span><br><span class="line"></span><br><span class="line">for (int i=1;i&lt;row;i++) &#123;</span><br><span class="line">dp[i][0] = dp[i-1][0] + m[i][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i=1;i&lt;column;i++) &#123;</span><br><span class="line">dp[0][i] = dp[0][i-1] + m[0][i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i =1;i &lt; row;i++) &#123;</span><br><span class="line">for (int j = 1;j &lt; column;j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dp[row - 1][column - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<strong>时间复杂度为O(m * n)</strong>，dp矩阵的大小为m * n，所以<strong>额外空间复杂度为O(m * n)</strong>。</p><p><strong>动态规划 + 空间压缩的方法</strong><br>经过空间压缩后的方法时间复杂度仍然是O(m * n)，但是额外空间复杂度会减小至O(min(m,n))，也就是不使用大小为m * n的矩阵，而仅仅使用大小为min(m,n)的数组，具体过程如下：</p><ul><li>1，生成长度为min(m,n)(也就是行数和列数较小的那个值，在这个例子为4)的数组arr,初始值为arr=[0,0,0,0]，从(0,0)位置到达m中第一行的每一个位置，最小路径就是从(0,0)位置开始累加的结果，所以依次把arr设置为arr=[1,4,9,18]，此时arr[j]的值代表从(0,0)位置到(0,j)位置的最小路径和。</li><li>2，步骤1是代表的是从(0,0)到(0,j)的最小路径和，现在想把arr[j]的值更新从(0,0)到(1,j)位置的最小路径和。可知对于arr[0]来说，令arr[0] = arr[0]  + m[1,0] = 9,即从(0,0)到(1,0)的最小路径和。至于(1,1)位置，此时有两种路径，从(1,0)到(1,1)、从(0,1)到(1,1)，arr[1] = min(arr[0],arr[1]) + m[1][1]，更新后arr[1]就成为dp[1][1]的值。同理arr[2] = min(arr[1],arr[2]) + m[1][2]，依次类推，最终arr可以更新成[9,5,8,12]。</li><li>3，重复步骤2，一直到arr彻底变成dp矩阵的最后一行，整个过程其实就是不听滚动更新arr数组，让arr依次变成dp矩阵每一行的值，最终变成最后一行的值。<br>如果矩阵的列数小于行数(M&gt;N)，依然可以用上面的方法更新成dp矩阵每一行的值。但如果给定的列数大于行数(M&lt;N),那么就生成长度为M的arr，然后更新成dp矩阵的每一列值，从左到右滚动过去。<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static int minPath2(int[][] m) &#123;</span><br><span class="line">if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int more = Math.max(m.length, m[0].length);//行数与列数较大的那个为more</span><br><span class="line">int less = Math.min(m.length, m[0].length);//行数与列数较小的那个为less</span><br><span class="line">boolean rowmore = more == m.length;//行数是不是大于或等于列数</span><br><span class="line">int[] arr  = new int[less];</span><br><span class="line">arr[0] = m[0][0];</span><br><span class="line">for (int i = 1;i &lt; less;i++) &#123;</span><br><span class="line">arr[i] = arr[i - 1] + (rowmore ? m[0][i] : m[i][0]);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1;i &lt; more;i++) &#123;</span><br><span class="line">arr[0] = arr[0] + (rowmore ? m[i][0] : m[0][i]);</span><br><span class="line">for (int j = 1;j &lt; less;j++) &#123;</span><br><span class="line">arr[j] = Math.min(arr[j - 1], arr[j]) +</span><br><span class="line">(rowmore ? m[i][j] : m[j][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return arr[less - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划类算法题&quot;&gt;&lt;a href=&quot;#动态规划类算法题&quot; class=&quot;headerlink&quot; title=&quot;动态规划类算法题&quot;&gt;&lt;/a&gt;动态规划类算法题&lt;/h2&gt;&lt;p&gt;动态规划相关以及动态规划的空间压缩方法。&lt;/p&gt;
    
    </summary>
    
      <category term="动态规划" scheme="http://yoursite.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Morris遍历</title>
    <link href="http://yoursite.com/2019/04/20/Morris%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/04/20/Morris遍历/</id>
    <published>2019-04-20T06:10:29.000Z</published>
    <updated>2019-05-14T02:19:27.875Z</updated>
    
    <content type="html"><![CDATA[<p>Morris遍历是一种时间复杂度O(n)的二叉树遍历。</p><a id="more"></a><p>Morris遍历与递归版本的二叉树遍历的关系(或者相似之处)，如果一个节点有左子树那么<strong>Morris遍历可以回到左子树两次</strong>(递归方法是3次)，Morris模拟了递归的过程。对于没有左子树的节点只会到达依一次。<br>Morris遍历(先序)的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   public static void morrisPre(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Node cur1 = head;</span><br><span class="line">Node cur2 = null;</span><br><span class="line">while (cur1 != null) &#123;</span><br><span class="line">cur2 = cur1.left;</span><br><span class="line">if (cur2 != null) &#123;</span><br><span class="line">while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">cur2 = cur2.right;</span><br><span class="line">&#125;</span><br><span class="line">if (cur2.right == null) &#123;</span><br><span class="line">cur2.right = cur1;</span><br><span class="line">System.out.print(cur1.value + &quot; &quot;);</span><br><span class="line">cur1 = cur1.left;</span><br><span class="line">continue;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cur2.right = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(cur1.value + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">cur1 = cur1.right;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Morris遍历(中序)的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   public static void morrisIn(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Node cur = head;</span><br><span class="line">Node mostRight = null;</span><br><span class="line">while (cur != null) &#123;</span><br><span class="line">mostRight = cur.left;</span><br><span class="line">if (mostRight != null) &#123;</span><br><span class="line">while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">mostRight = mostRight.right;</span><br><span class="line">&#125;</span><br><span class="line">if (mostRight.right == null) &#123;</span><br><span class="line">mostRight.right = cur;</span><br><span class="line">cur = cur.left;</span><br><span class="line">continue;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mostRight.right = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(cur.value + &quot; &quot;);</span><br><span class="line">cur = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：后序遍历有点麻烦，因为Morris遍历最多只能回到一个节点两次并不会回到第三次。采用下面的方法打印后序遍历：所有会回到两次的节点，在它第二次回到的时候逆序打印它的左子树右边界，打印完后，单独打印整棵树的右边界，这就后序遍历。<br><strong>只关注能来到两次的节点</strong>。<br>Morris遍历(后序)的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   public static void morrisPos(Node head) &#123;</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Node cur1 = head;</span><br><span class="line">Node cur2 = null;</span><br><span class="line">while (cur1 != null) &#123;</span><br><span class="line">cur2 = cur1.left;</span><br><span class="line">if (cur2 != null) &#123;</span><br><span class="line">while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">cur2 = cur2.right;</span><br><span class="line">&#125;</span><br><span class="line">if (cur2.right == null) &#123;</span><br><span class="line">cur2.right = cur1;</span><br><span class="line">cur1 = cur1.left;</span><br><span class="line">continue;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">cur2.right = null;</span><br><span class="line">printEdge(cur1.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur1 = cur1.right;</span><br><span class="line">&#125;</span><br><span class="line">printEdge(head);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   public static void printEdge(Node head) &#123;</span><br><span class="line">Node tail = reverseEdge(head);</span><br><span class="line">Node cur = tail;</span><br><span class="line">while (cur != null) &#123;</span><br><span class="line">System.out.print(cur.value + &quot; &quot;);</span><br><span class="line">cur = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">reverseEdge(tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Morris遍历是一种时间复杂度O(n)的二叉树遍历。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
