<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/TiddlyWiki.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

<script>
    (function () {
        if ('ly669966') {
            if (prompt('请输入文章密码') !== 'ly669966') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("ly669966"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>

  <meta name="description" content="前言Glide是Android中使用非常频繁的图片加载框架，在平时开发中使用非常频繁。现在Android的图片加载框架也是非常成熟了，其中Glide应该是非常流行的一个了。">
<meta name="keywords" content="Android图片加载">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide使用及分析">
<meta property="og:url" content="http://yoursite.com/2019/04/01/Glide使用及分析/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言Glide是Android中使用非常频繁的图片加载框架，在平时开发中使用非常频繁。现在Android的图片加载框架也是非常成熟了，其中Glide应该是非常流行的一个了。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-01T20:34:19.635Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Glide使用及分析">
<meta name="twitter:description" content="前言Glide是Android中使用非常频繁的图片加载框架，在平时开发中使用非常频繁。现在Android的图片加载框架也是非常成熟了，其中Glide应该是非常流行的一个了。">
  <link rel="canonical" href="http://yoursite.com/2019/04/01/Glide使用及分析/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Glide使用及分析 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/ltt19921124" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; 
    top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
    </path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7
     120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6
      130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm">
      </path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6
       C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1
        176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9
         216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5
          157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8
           Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover
            .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes
             octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/Glide使用及分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lu Tian">
      <meta itemprop="description" content="每天进步一点点">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Glide使用及分析

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-04-01 23:21:02" itemprop="dateCreated datePublished" datetime="2019-04-01T23:21:02+08:00">2019-04-01</time>
            </span>
          
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-02 04:34:19" itemprop="dateModified" datetime="2019-04-02T04:34:19+08:00">2019-04-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图片加载/" itemprop="url" rel="index"><span itemprop="name">图片加载</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span></span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Glide是Android中使用非常频繁的图片加载框架，在平时开发中使用非常频繁。现在Android的图片加载框架也是非常成熟了，其中Glide应该是非常流行的一个了。</p>
<a id="more"></a>
<h2 id="Glide基本用法及介绍"><a href="#Glide基本用法及介绍" class="headerlink" title="Glide基本用法及介绍"></a>Glide基本用法及介绍</h2><h3 id="添加版本依赖库"><a href="#添加版本依赖库" class="headerlink" title="添加版本依赖库"></a>添加版本依赖库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.github.bumptech.glide:glide:4.9.0&apos;</span><br><span class="line">    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.9.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于Glide 3，这里要多添加一个compiler的库，这个库是用于生成Generated API的。另外记得添加网络权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>添加完了依赖库后我们就可以使用了，在布局当中加入一个Button和一个ImageView，点击Button然后加载图片到ImageView中。onClick方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View v) &#123;</span><br><span class="line">    String url = &quot;http://p1.pstatp.com/large/166200019850062839d3&quot;;</span><br><span class="line">    Glide.with(this).load(url).into(imageView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Glide.with(this).load(url).into(imageView)</strong>就是Glide加载图片的核心代码。</p>
<h3 id="占位图"><a href="#占位图" class="headerlink" title="占位图"></a>占位图</h3><p>会发现点击”加载图片”按钮之后，要稍微等一会图片才会显示出来，因为从网络上下载图片本来需要时间，不过这样的用户体验就不太好了，我们可以用占位图的方式优化体验，就是在图片加载完成之前先用一张本地图片占住这个位置，不至于屏幕是空白的。先准备好一张loading.jpg图片，放在资源文件夹中。修改onClick方法中加载图片的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">    .placeholder(R.drawable.loading);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>这里我们先创建了一个RequestOptions对象，然后调用它的placeholder()方法来指定占位图，再将占位图片的资源id传入到这个方法中。最后，在Glide的三步走之间加入一个apply()方法，来应用我们刚才创建的RequestOptions对象。<br>不过如果你现在重新运行一下代码并点击”加载图片”很可能是根本看不到占位图效果的。因为Glide有非常强大的缓存机制，我们刚才加载图片的时候Glide自动就已经将它缓存下来了，下次加载的时候将会直接从缓存中读取，不会再去网络下载了，因而加载的速度非常快，所以占位图可能根本来不及显示。<br>因此这里我们还需要稍微做一点修改，来让占位图能有机会显示出来，修改代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .placeholder(R.drawable.loading)</span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.NONE);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>增加了diskCacheStrategy(DiskCacheStrategy.NONE);这一行代码，diskCacheStrategy方法传入了DiskCacheStrategy.NONE参数，这样就可以禁用掉Glide的缓存功能。<br>当再次点击”加载图片”按钮之后会立即显示一张占位图，然后等真正的图片加载完成之后会将占位图替换掉。</p>
<p>除了这种加载占位图之外，还有一种异常占位图。异常占位图就是指，如果因为某些异常情况导致图片加载失败，比如说手机网络信号不好，这个时候就显示这张异常占位图。准备一张error.jpg图片，然后修改Glide加载部分的代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .placeholder(R.drawable.ic_launcher_background)</span><br><span class="line">        .error(R.drawable.error)</span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.NONE);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>如上代码所示，这里又串接了一个error()方法就可以指定异常占位图了。</p>
<p>其实看到这里，如果你熟悉Glide 3的话，相信你已经掌握Glide 4的变化规律了。在Glide 3当中，像placeholder()、error()、diskCacheStrategy()等等一系列的API，都是直接串联在Glide三步走方法中使用的。<br>而Glide 4(这里用的是Glide 4.9)中引入了一个RequestOptions对象，将这一系列的API都移动到了RequestOptions当中。这样做的好处是可以使我们摆脱冗长的Glide加载语句，而且还能进行自己的API封装，因为RequestOptions是可以作为参数传入到方法中的。</p>
<p>比如你就可以写出这样的Glide加载工具类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class GlideUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static void load(Context context,</span><br><span class="line">                            String url,</span><br><span class="line">                            ImageView imageView,</span><br><span class="line">                            RequestOptions options) &#123;</span><br><span class="line">        Glide.with(context)</span><br><span class="line">             .load(url)</span><br><span class="line">             .apply(options)</span><br><span class="line">             .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会很方便，可以让Glide的加载语句不至于变得冗长。</p>
<h3 id="指定加载的图片大小"><a href="#指定加载的图片大小" class="headerlink" title="指定加载的图片大小"></a>指定加载的图片大小</h3><p>实际上，使用Glide在大多数情况下我们都是不需要指定图片大小的，因为Glide会自动根据ImageView的大小来决定图片的大小，以此保证图片不会占用过多的内存从而引发OOM。<br>不过，如果你真的有这样的需求，必须给图片指定一个固定的大小，Glide仍然是支持这个功能的。修改Glide加载部分的代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .override(200, 100);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>仍然非常简单，这里使用override()方法指定了一个图片的尺寸。也就是说，Glide现在只会将图片加载成200*100像素的尺寸，而不会管你的ImageView的大小是多少了。<br>如果你想加载一张图片的原始尺寸的话，可以使用Target.SIZE_ORIGINAL关键字，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .override(Target.SIZE_ORIGINAL);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>这样的话，Glide就不会再去自动压缩图片，而是会去加载图片的原始尺寸。当然，这种写法也会面临着更高的OOM风险。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>Glide的缓存设计可以说是非常先进的，考虑的场景也很周全。在缓存这一功能上，Glide又将它分成了两个模块，一个是内存缓存，一个是硬盘缓存。</p>
<p>这两个缓存模块的作用各不相同，内存缓存的主要作用是防止应用重复将图片数据读取到内存当中，而硬盘缓存的主要作用是防止应用重复从网络或其他地方重复下载和读取数据。</p>
<h4 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h4><p>默认情况下，Glide自动就是开启内存缓存的。也就是说，当我们使用Glide加载了一张图片之后，这张图片就会被缓存到内存当中，只要在它还没从内存中被清除之前，下次使用Glide再加载这张图片都会直接从内存当中读取，而不用重新从网络或硬盘上读取了，这样无疑就可以大幅度提升图片的加载效率。比方说你在一个RecyclerView当中反复上下滑动，RecyclerView中只要是Glide加载过的图片都可以直接从内存当中迅速读取并展示出来，从而大大提升了用户体验。</p>
<p>而Glide最为人性化的是，你甚至不需要编写任何额外的代码就能自动享受到这个极为便利的内存缓存功能，因为Glide默认就已经将它开启了。</p>
<p>那么既然已经默认开启了这个功能，还有什么可讲的用法呢？只有一点，如果你有什么特殊的原因需要禁用内存缓存功能，Glide对此提供了接口，<strong>禁用内存缓存：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .skipMemoryCache(true);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>可以看到，只需要调用skipMemoryCache()方法并传入true，就表示禁用掉Glide的内存缓存功能。</p>
<h4 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h4><p>刚刚学习占位图功能的时候，我们就使用过硬盘缓存的功能了。当时为了禁止Glide对图片进行硬盘缓存而使用了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .diskCacheStrategy(DiskCacheStrategy.NONE);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>调用diskCacheStrategy()方法并传入DiskCacheStrategy.NONE，就可以禁用掉Glide的硬盘缓存功能了。</p>
<p>这个diskCacheStrategy()方法基本上就是Glide硬盘缓存功能的一切，它可以接收五种参数：</p>
<ul>
<li>DiskCacheStrategy.NONE： 表示不缓存任何内容。</li>
<li>DiskCacheStrategy.DATA： 表示只缓存原始图片。</li>
<li>DiskCacheStrategy.RESOURCE： 表示只缓存转换过后的图片。</li>
<li>DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。</li>
<li>DiskCacheStrategy.AUTOMATIC： 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。</li>
</ul>
<p>其中，DiskCacheStrategy.DATA对应Glide 3中的DiskCacheStrategy.SOURCE，DiskCacheStrategy.RESOURCE对应Glide 3中的DiskCacheStrategy.RESULT。而DiskCacheStrategy.AUTOMATIC是Glide 4中新增的一种缓存策略，并且在不指定diskCacheStrategy的情况下默认使用就是的这种缓存策略。</p>
<p>上面五种参数的解释本身并没有什么难理解的地方，但是关于转换过后的图片这个概念大家可能需要了解一下。就是当我们使用Glide去加载一张图片的时候，Glide默认并不会将原始图片展示出来，而是会对图片进行压缩和转换（我们会在稍后学习这方面的内容）。总之就是经过种种一系列操作之后得到的图片，就叫转换过后的图片。</p>
<p>关于Glide 4硬盘缓存的内容就讲到这里。想要了解更多Glide缓存方面的知识，可以参考 <a href="https://blog.csdn.net/guolin_blog/article/details/54895665" target="_blank" rel="noopener">Android图片加载框架最全解析（三）</a>，深入探究Glide的缓存机制 这篇文章。</p>
<h3 id="指定加载格式"><a href="#指定加载格式" class="headerlink" title="指定加载格式"></a>指定加载格式</h3><p>我们都知道，Glide其中一个非常亮眼的功能就是可以加载GIF图片，而同样作为非常出色的图片加载框架的Picasso是不支持这个功能的。</p>
<p>而且使用Glide加载GIF图并不需要编写什么额外的代码，Glide内部会自动判断图片格式。比如我们将加载图片的URL地址改成一张GIF图，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://guolin.tech/test.gif&quot;)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>也就是说，不管我们传入的是一张普通图片，还是一张GIF图片，Glide都会自动进行判断，并且可以正确地把它解析并展示出来。</p>
<p>但是如果我想指定加载格式该怎么办呢？就比如说，我希望加载的这张图必须是一张静态图片，我不需要Glide自动帮我判断它到底是静图还是GIF图。<br>只需要再串接一个asBitmap()方法就可以了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .asBitmap()</span><br><span class="line">     .load(&quot;http://guolin.tech/test.gif&quot;)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>asBitmap()方法，这个方法的意思就是说这里<strong>只允许加载静态图片</strong>，不需要Glide去帮我们自动进行图片格式的判断了。如果你传入的还是一张GIF图的话，Glide会展示这张GIF图的第一帧，而不会去播放它。<br>注意：在Glide 3中的语法是先load()再asBitmap()的，而在Glide 4中是先asBitmap()再load()的，写错了顺序就会报错。</p>
<p>那么类似地，既然我们能强制指定加载静态图片，就也能强制指定加载动态图片，对应的方法是asGif()。而Glide 4中又新增了asFile()方法和asDrawable()方法，分别用于强制指定文件格式的加载和Drawable格式的加载。</p>
<h3 id="回调与监听"><a href="#回调与监听" class="headerlink" title="回调与监听"></a>回调与监听</h3><h4 id="preload-方法"><a href="#preload-方法" class="headerlink" title="preload()方法"></a>preload()方法</h4><p>Glide加载图片虽说非常智能，它会自动判断该图片是否已经有缓存了，如果有的话就直接从缓存中读取，没有的话再从网络去下载。但是如果我希望提前对图片进行一个预加载，等真正需要加载图片的时候就直接从缓存中读取，不想再等待慢长的网络加载时间了，这该怎么办呢？</p>
<p>不用担心，Glide专门给我们提供了预加载的接口，也就是preload()方法，我们只需要直接使用就可以了。</p>
<p>preload()方法有两个方法重载，一个不带参数，表示将会加载图片的原始尺寸，另一个可以通过参数指定加载图片的宽和高。<br>preload()方法的用法也非常简单，直接使用它来替换into()方法即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://guolin.tech/book.png&quot;)</span><br><span class="line">     .preload();</span><br></pre></td></tr></table></figure>

<p>注：替换into()方法</p>
<p>调用了预加载之后，我们以后想再去加载这张图片就会非常快了，因为Glide会直接从缓存当中去读取图片并显示出来，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://guolin.tech/book.png&quot;)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><p>一直以来，我们使用Glide都是为了将图片显示到界面上。虽然我们知道Glide会在图片的加载过程中对图片进行缓存，但是缓存文件到底是存在哪里的，以及如何去直接访问这些缓存文件？我们都还不知道。</p>
<p>其实Glide将图片加载接口设计成这样也是希望我们使用起来更加的方便，不用过多去考虑底层的实现细节。但如果我现在就是想要去<strong>访问图片的缓存文件</strong>该怎么办呢？这就需要用到submit()方法了。</p>
<p>submit()方法其实就是对应的Glide 3中的downloadOnly()方法，和preload()方法类似，submit()方法也是可以替换into()方法的，不过submit()方法的用法明显要比preload()方法复杂不少。这个方法只会下载图片，而不会对图片进行加载。当图片下载完成之后，我们可以得到图片的存储路径，以便后续进行操作。</p>
<p>那么首先我们还是先来看下基本用法。submit()方法有两个方法重载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">submit()</span><br><span class="line">submit(int width, int height)</span><br></pre></td></tr></table></figure>

<p>其中submit()方法是用于下载<strong>原始尺寸</strong>的图片，而submit(int width, int height)则可以指定下载图片的尺寸。</p>
<p>这里就以submit()方法来举例。当调用了submit()方法后会立即返回一个FutureTarget对象，然后Glide会在后台开始下载图片文件。接下来我们调用FutureTarget的get()方法就可以去获取下载好的图片文件了，如果此时图片还没有下载完，那么get()方法就会阻塞住，一直等到图片下载完成才会有值返回。</p>
<p>下面我们通过一个例子来演示一下吧，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void downloadImage() &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String url = &quot;http://www.guolin.tech/book.png&quot;;</span><br><span class="line">                final Context context = getApplicationContext();</span><br><span class="line">                FutureTarget&lt;File&gt; target = Glide.with(context)</span><br><span class="line">                        .asFile()</span><br><span class="line">                        .load(url)</span><br><span class="line">                        .submit();</span><br><span class="line">                final File imageFile = target.get();</span><br><span class="line">                runOnUiThread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        Toast.makeText(context, imageFile.getPath(), Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码稍微有一点点长，我带着大家解读一下。首先，submit()方法必须要用在子线程当中，因为刚才说了FutureTarget的get()方法是会阻塞线程的，因此这里的第一步就是new了一个Thread。在子线程当中，我们先获取了一个Application Context，这个时候不能再用Activity作为Context了，因为会有Activity销毁了但子线程还没执行完这种可能出现。</p>
<p>接下来就是Glide的基本用法，只不过将into()方法替换成了submit()方法，并且还使用了一个asFile()方法来指定加载格式。submit()方法会返回一个FutureTarget对象，这个时候其实Glide已经开始在后台下载图片了，我们随时都可以调用FutureTarget的get()方法来获取下载的图片文件，只不过如果图片还没下载好线程会暂时阻塞住，等下载完成了才会把图片的File对象返回。</p>
<p>最后，我们使用runOnUiThread()切回到主线程，然后使用Toast将下载好的图片文件路径显示出来。这样我们就能清晰地看出来图片完整的缓存路径是什么了。</p>
<h4 id="listener-方法"><a href="#listener-方法" class="headerlink" title="listener()方法"></a>listener()方法</h4><p>其实listener()方法的作用非常普遍，它可以用来监听Glide加载图片的状态。举个例子，比如说我们刚才使用了preload()方法来对图片进行预加载，但是我怎样确定预加载有没有完成呢？还有如果Glide加载图片失败了，我该怎样调试错误的原因呢？答案都在listener()方法当中。</p>
<p>下面来看下listener()方法的基本用法吧，不同于刚才几个方法都是要替换into()方法的，listener()是结合into()方法一起使用的，当然也可以结合preload()方法一起使用。最基本的用法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://www.guolin.tech/book.png&quot;)</span><br><span class="line">     .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>这里我们在into()方法之前串接了一个listener()方法，然后实现了一个RequestListener的实例。其中RequestListener需要实现两个方法，一个onResourceReady()方法，一个onLoadFailed()方法。从方法名上就可以看出来了，当图片加载完成的时候就会回调onResourceReady()方法，而当图片加载失败的时候就会回调onLoadFailed()方法，onLoadFailed()方法中会将失败的GlideException参数传进来，这样我们就可以定位具体失败的原因了。</p>
<p>没错，listener()方法就是这么简单。不过还有一点需要处理，onResourceReady()方法和onLoadFailed()方法都有一个布尔值的返回值，返回false就表示这个事件没有被处理，还会继续向下传递，返回true就表示这个事件已经被处理掉了，从而不会再继续向下传递。举个简单点的例子，如果我们在RequestListener的onResourceReady()方法中返回了true，那么就不会再回调Target的onResourceReady()方法了。</p>
<h3 id="图片变换"><a href="#图片变换" class="headerlink" title="图片变换"></a>图片变换</h3><p>图片变换的意思就是说，Glide从加载了原始图片到最终展示给用户之前，又进行了一些变换处理，从而能够实现一些更加丰富的图片效果，如图片圆角化、圆形化、模糊化等等。</p>
<p>添加图片变换的用法非常简单，我们只需要在RequestOptions中串接transforms()方法，并将想要执行的图片变换操作作为参数传入transforms()方法即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .transforms(...);</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>至于具体要进行什么样的图片变换操作，这个通常都是需要我们自己来写的。不过Glide已经内置了几种图片变换操作，我们可以直接拿来使用，比如CenterCrop、FitCenter、CircleCrop等。</p>
<p>但所有的内置图片变换操作其实都不需要使用transform()方法，Glide为了方便我们使用直接提供了现成的API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .centerCrop();</span><br><span class="line"></span><br><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .fitCenter();</span><br><span class="line"></span><br><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .circleCrop();</span><br></pre></td></tr></table></figure>

<p>当然，这些内置的图片变换API其实也只是对transform()方法进行了一层封装而已，它们背后的源码仍然还是借助transform()方法来实现的。</p>
<p>这里我们就选择其中一种内置的图片变换操作来演示一下吧，circleCrop()方法是用来对图片进行圆形化裁剪的，我们动手试一下，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://guolin.tech/book.png&quot;;</span><br><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .circleCrop();</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>这会对图片进行圆形化裁剪。</p>
<p>当然，除了使用内置的图片变换操作之外，我们完全可以自定义自己的图片变换操作。理论上，在对图片进行变换这个步骤中我们可以进行任何的操作，你想对图片怎么样都可以。包括圆角化、圆形化、黑白化、模糊化等等，甚至你将原图片完全替换成另外一张图都是可以的。</p>
<p>不过由于这部分内容相对于Glide 3没有任何的变化，因此就不再重复进行讲解了。想学习自定义图片变换操作的朋友们可以参考这篇文章 <a href="https://blog.csdn.net/guolin_blog/article/details/71524668" target="_blank" rel="noopener">Android图片加载框架最全解析（五），Glide强大的图片变换功能</a> 。</p>
<p>关于图片变换，最后我们再来看一个非常优秀的开源库，glide-transformations。它实现了很多通用的图片变换效果，如裁剪变换、颜色变换、模糊变换等等，使得我们可以非常轻松地进行各种各样的图片变换。</p>
<p>glide-transformations的项目主页地址是 <a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="noopener">地址</a> 。</p>
<p>下面我们就来体验一下这个库的强大功能吧。首先需要将这个库引入到我们的项目当中，在app/build.gradle文件当中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;jp.wasabeef:glide-transformations:3.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以对图片进行单个变换处理，也可以将多种图片变换叠加在一起使用。比如我想同时对图片进行模糊化和黑白化处理，就可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;http://guolin.tech/book.png&quot;;</span><br><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">        .transforms(new BlurTransformation(), new GrayscaleTransformation());</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .apply(options)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>

<p>可以看到，同时执行多种图片变换的时候，只需要将它们都传入到transforms()方法中即可。</p>
<h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>自定义模块属于Glide中的高级功能，同时也是难度比较高的一部分内容。</p>
<p>这里我不可能在这一篇文章中将自定义模块的内容全讲一遍，限于篇幅的限制我只能讲一讲Glide 4中变化的这部分内容。关于Glide自定义模块的全部内容，请大家去参考 Android图片加载框架最全解析（六），探究Glide的自定义模块功能 这篇文章。</p>
<p>首先定义一个我们自己的模块类，并让它继承自AppGlideModule，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public class MyAppGlideModule extends AppGlideModule &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void applyOptions(Context context, GlideBuilder builder) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerComponents(Context context, Glide glide, Registry registry) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在MyAppGlideModule类当中，我们重写了applyOptions()和registerComponents()方法，这两个方法分别就是用来更改Glide配置以及替换Glide组件的。</p>
<p>注意在MyAppGlideModule类在上面，我们加入了一个@GlideModule的注解，这是Gilde 4和Glide 3最大的一个不同之处。在Glide 3中，我们定义了自定义模块之后，还必须在AndroidManifest.xml文件中去注册它才能生效，而在Glide 4中是不需要的，因为@GlideModule这个注解已经能够让Glide识别到这个自定义模块了。</p>
<p>这样的话，我们就将Glide自定义模块的功能完成了。后面只需要在applyOptions()和registerComponents()这两个方法中加入具体的逻辑，就能实现更改Glide配置或者替换Glide组件的功能了。详情还是请参考 Android图片加载框架最全解析（六），探究Glide的自定义模块功能 这篇文章，这里就不再展开讨论了。</p>

    </div>

    
    
    
      

        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Android图片加载/" rel="tag"># Android图片加载</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/03/18/Apollo基础课程第五课之感知-下/" rel="next" title="Apollo基础课程之感知(下)">
                  <i class="fa fa-chevron-left"></i> Apollo基础课程之感知(下)
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/04/03/Ubuntu系统下编译Android-9.0系统/" rel="prev" title="Ubuntu系统下编译Android 9.0系统">
                  Ubuntu系统下编译Android 9.0系统 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Glide基本用法及介绍"><span class="nav-number">2.</span> <span class="nav-text">Glide基本用法及介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加版本依赖库"><span class="nav-number">2.1.</span> <span class="nav-text">添加版本依赖库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加载图片"><span class="nav-number">2.2.</span> <span class="nav-text">加载图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#占位图"><span class="nav-number">2.3.</span> <span class="nav-text">占位图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定加载的图片大小"><span class="nav-number">2.4.</span> <span class="nav-text">指定加载的图片大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存机制"><span class="nav-number">2.5.</span> <span class="nav-text">缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存缓存"><span class="nav-number">2.5.1.</span> <span class="nav-text">内存缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬盘缓存"><span class="nav-number">2.5.2.</span> <span class="nav-text">硬盘缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定加载格式"><span class="nav-number">2.6.</span> <span class="nav-text">指定加载格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调与监听"><span class="nav-number">2.7.</span> <span class="nav-text">回调与监听</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#preload-方法"><span class="nav-number">2.7.1.</span> <span class="nav-text">preload()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#submit-方法"><span class="nav-number">2.7.2.</span> <span class="nav-text">submit()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#listener-方法"><span class="nav-number">2.7.3.</span> <span class="nav-text">listener()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图片变换"><span class="nav-number">2.8.</span> <span class="nav-text">图片变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义模块"><span class="nav-number">2.9.</span> <span class="nav-text">自定义模块</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/timg.jpg"
      alt="Lu Tian">
  <p class="site-author-name" itemprop="name">Lu Tian</p>
  <div class="site-description" itemprop="description">每天进步一点点</div>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ltt19921124" title="GitHub &rarr; https://github.com/ltt19921124" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://liuwangshu.cn/" title="http://liuwangshu.cn/" rel="noopener" target="_blank">刘望舒</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/singwhatiwanna/" title="https://blog.csdn.net/singwhatiwanna/" rel="noopener" target="_blank">任玉刚</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://me.csdn.net/sinyu890807" title="https://me.csdn.net/sinyu890807" rel="noopener" target="_blank">郭霖</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Tian</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数"></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共168.3k字</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>






  

  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>