<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/TiddlyWiki.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

  <meta name="description" content="一、HashMaphashmap在元素size超过负载因子对应数的时候就会扩容，但是其实还有一种情况也会扩容，那就是链表上Node数量大于等于8且tab数组长度小于64的时候的时候。HashMap的结构是哈希表，底层维护了一个Node数组(Jdk 8之后，之前是HashMap.Entry数组)，它是集合框架里非常常用的集合类，和ArrayList一样，使用非常频繁，HashMap的初始容量是16，">
<meta name="keywords" content="java,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap详解">
<meta property="og:url" content="http://yoursite.com/2019/01/08/HashMap详解/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、HashMaphashmap在元素size超过负载因子对应数的时候就会扩容，但是其实还有一种情况也会扩容，那就是链表上Node数量大于等于8且tab数组长度小于64的时候的时候。HashMap的结构是哈希表，底层维护了一个Node数组(Jdk 8之后，之前是HashMap.Entry数组)，它是集合框架里非常常用的集合类，和ArrayList一样，使用非常频繁，HashMap的初始容量是16，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/picture/lalian.png">
<meta property="og:image" content="http://yoursite.com/picture/lalian1.png">
<meta property="og:image" content="http://yoursite.com/picture/QQ%E6%88%AA%E5%9B%BE20190108044357.png">
<meta property="og:updated_time" content="2019-05-12T00:20:42.841Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HashMap详解">
<meta name="twitter:description" content="一、HashMaphashmap在元素size超过负载因子对应数的时候就会扩容，但是其实还有一种情况也会扩容，那就是链表上Node数量大于等于8且tab数组长度小于64的时候的时候。HashMap的结构是哈希表，底层维护了一个Node数组(Jdk 8之后，之前是HashMap.Entry数组)，它是集合框架里非常常用的集合类，和ArrayList一样，使用非常频繁，HashMap的初始容量是16，">
<meta name="twitter:image" content="http://yoursite.com/picture/lalian.png">
  <link rel="canonical" href="http://yoursite.com/2019/01/08/HashMap详解/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>HashMap详解 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/ltt19921124" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; 
    top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
    </path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7
     120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6
      130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm">
      </path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6
       C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1
        176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9
         216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5
          157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8
           Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover
            .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes
             octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">51</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">22</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">107</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-schedule">
      
    
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-sitemap">
      
    
      
    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/HashMap详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lu Tian">
      <meta itemprop="description" content="hhh">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">HashMap详解

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-01-08 03:59:07" itemprop="dateCreated datePublished" datetime="2019-01-08T03:59:07+08:00">2019-01-08</time>
            </span>
          
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-12 08:20:42" itemprop="dateModified" datetime="2019-05-12T08:20:42+08:00">2019-05-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构-java/" itemprop="url" rel="index"><span itemprop="name">数据结构,java</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span></span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、HashMap"><a href="#一、HashMap" class="headerlink" title="一、HashMap"></a>一、HashMap</h2><p><strong>hashmap在元素size超过负载因子对应数的时候就会扩容，但是其实还有一种情况也会扩容，那就是链表上Node数量大于等于8且tab数组长度小于64的时候的时候。</strong><br>HashMap的结构是哈希表，底层维护了一个Node数组(Jdk 8之后，之前是HashMap.Entry数组)，它是集合框架里非常常用的集合类，和ArrayList一样，使用非常频繁，HashMap的初始容量是16，加载因子是0.75，当在一个位桶发生哈希冲突(也叫哈希碰撞)的时候，添加的元素会依次存放在该位置的最后一个元素后面(形成链表)，<strong>链表数量大于8且HashMap元素大小小于64时</strong>，这条链表就会转成就会转成<strong>红黑树</strong>，注意一定两个条件都满足才会转成红黑树，不要忽略了64这个数，平时很多博客说链表大于8就转红黑树大概是因为在工程上链表大于8了基本上HashMap存储的元素大于64，否则说明这个HashMap的hash函数设计的不好，基本上算出来的值都是同一个，也就是说产生了哈希碰撞。而实际上HashMap的hash函数是已经高度优化了的，所以某条链表节点数大于8而总节点数小于64发生的概率极低，当然要知道这个逻辑。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-treeifyBin方法"><a href="#1-1-treeifyBin方法" class="headerlink" title="1.1 treeifyBin方法"></a>1.1 treeifyBin方法</h3><p>如图所示，TREEIFY_THRESHOLD值是8，它的意思是超过一条链上的Node数量大于等于8就会转成红黑树来存储元素而不是链表，然后会执行treeifyBin(tab, hash);方法，我们看看这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="line">    * table is too small, in which case resizes instead.</span><br><span class="line">    */</span><br><span class="line">   final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">       int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">           do &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">               if (tl == null)</span><br><span class="line">                   hd = p;</span><br><span class="line">               else &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; while ((e = e.next) != null);</span><br><span class="line">           if ((tab[index] = hd) != null)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>看注释，意思大概就是，把链表转换为红黑树，除非数组太小，在hashmap的实现里，是table小于64时，不转为红黑树。MIN_TREEIFY_CAPACITY是最小转为红黑树的tab大小，是64，如果满足这个条件同时链表长度大于8就执行resize()方法对数组进行扩容。</p>
<p>HashMap是容器类，存储的是键值对，jdk 1.8之前底层是 数组和链表结合在一起使用也就是 链表散列。HashMap通过key的 hashCode 经过扰动函数处理后得到hash值，然后通过(n - 1) &amp; hash判断当前元素存放的位置(n是数组的长度，HashMap默认为16，加载因子是0.75)，如果当前位置存在元素，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不同就通过拉链法解决冲突。put()方法相关源码如下：</p>
<h3 id="1-2-putVal方法"><a href="#1-2-putVal方法" class="headerlink" title="1.2 putVal方法"></a>1.2 putVal方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()/*resize方法生成一个指定容量大小的Node数组*/).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)//1,tab[i]位置没有node对象，就直接把元素放在此位置</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;//2，不为空的情况下，在这里判断是否覆盖还是通过拉链法放到别处(判断是同一个对象就覆盖)</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//3,</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-扰动函数"><a href="#1-3-扰动函数" class="headerlink" title="1.3 扰动函数"></a>1.3 扰动函数</h3><p>是HashMap的hash方法，使用hash方法也就是扰动函数时为了防止一些实现比较差的hashCode()方法，也就是说，扰动函数可以减少碰撞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//jdk 11.0.1(估计还是和jdk 8一样，因为最新的eclipse支持，jdk 11.0.1所以我直接下载的最新版本)</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">//jdk 1.7的hash方法</span><br><span class="line">static final int hash(int h) &#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，JDk 11.0.1的方法性能要好一些，jdk 7的hash方法扰动了4次。</p>
<h3 id="1-4-拉链法"><a href="#1-4-拉链法" class="headerlink" title="1.4 拉链法"></a>1.4 拉链法</h3><p>拉链法就是将链表和数组结合，也就是说创建一个链表数组，数组每一个格是一个链表，若遇到哈希冲突，则将冲突的值加到链表中即可。<br>jdk 1.7:<br><img src="/picture/lalian.png" alt><br>jdk 1.8之后<br><img src="/picture/lalian1.png" alt></p>
<h3 id="1-5-HashMap类的成员变量"><a href="#1-5-HashMap类的成员变量" class="headerlink" title="1.5 HashMap类的成员变量"></a>1.5 HashMap类的成员变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 3624988207631812</span><br><span class="line"></span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"></span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line"></span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>

<p><strong>jdk 1.8及以后put方法</strong><br>HashMap只提供了普通方法用于添加元素，putVal()方法 是在put方法调用的时候调用的，没有给用户调用。putVal方法添加元素的过程如下：</p>
<ul>
<li>如果定位到的位置没有元素就直接插入</li>
<li>如果定位到的数组位置有元素就和要插入的元素的key作比较，如果相同就直接覆盖(key不能重复，重复就覆盖)，再判断p是不是一个树节点，如果是调用 e = e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);将元素插入。如果不是就遍历链表插入。</li>
</ul>
<h3 id="1-6-Jdk-8-putVal方法的源码"><a href="#1-6-Jdk-8-putVal方法的源码" class="headerlink" title="1.6  Jdk 8 putVal方法的源码"></a>1.6  Jdk 8 putVal方法的源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        //tab未初始化就扩容</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        //(n - 1) &amp; hash是确定元素位于哪个桶中，桶为空，就生成新的节点放入桶中(此时，这//个节点是放在数组中)</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        //如果桶中已存在</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            //如果桶中第一个元素(数组中的节点)hash值与要传入的值的hash值相等且key相等，</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                //将第一个元素赋值给e,用e来记录</span><br><span class="line">                e = p;</span><br><span class="line">            //hash值不相等，即key不相等；为红黑树节点</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                //放入树中</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            //为链表节点</span><br><span class="line">            else &#123;</span><br><span class="line">                //在链表最尾端插入</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    //到达链表尾部</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        //在尾部插入节点</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        //节点数量达到阈值，转化为红黑树(并不一定就会转成红黑树，)，Node数组要大于等于 MIN_TREEIFY_CAPACITY(64)//才可以</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        //跳出循环</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //判断链表中节点的key值与插入的元素的key值是否相等</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        //相等，跳出循环</span><br><span class="line">                        break;</span><br><span class="line">                    //用于遍历桶中的链表，与前面的 e = p.next结合，可以遍历链表</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //表示在桶中找到key值、hash值与插入元素相等的节点</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                //记录e的value</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                //onlyIfAbsent值为false或者旧值为null</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    //用新值替换</span><br><span class="line">                    e.value = value;</span><br><span class="line">                //返回后回调</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                //返回旧值</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //结构性修改</span><br><span class="line">        ++modCount;</span><br><span class="line">        //满足实际容量大小大于阈值扩容条件</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        //插入后回调</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jdk1.7 put方法</strong><br>put方法的分析：</p>
<ul>
<li>如果定位到的数组位置没有元素就直接插入</li>
<li>如果定位到的数组位置有元素，遍历以这个元素为头节点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素</li>
</ul>
<h3 id="1-7-jdk-1-7get方法"><a href="#1-7-jdk-1-7get方法" class="headerlink" title="1.7 jdk 1.7get方法"></a>1.7 jdk 1.7get方法</h3><p>get方法分析：</p>
<ul>
<li>get方法返回对应键值对的value，传入key，通过key得到hash值，hash值和key传入getNode()方法中得到一个Node类型的变量，为空返回null，不为空说明hash表中有这个元素，返回这个元素对应的value(e.value)。</li>
<li>getNode()方法，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            //传入的key的hash值与数组元素的hash(其实也可以是元素中key的hash值，因为hash只与key有关)，并且 (k = first.key) == //key 和 (key != null &amp;&amp; key.equals(k))两个条件有一个为真，那么说明这个我们传入的key就是first这个元素的key，我们就是//想得到它的value值。此时返回Node，在上面的get()方法中返回这个Node对象的 value。</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            //该桶不止一个元素，也就是有链表或者红黑树</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                //在红黑树中用get()方法，</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                //在链表中调用get()方法，遍历，找到就返回</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-8-getTreeNode方法"><a href="#1-8-getTreeNode方法" class="headerlink" title="1.8 getTreeNode方法"></a>1.8 getTreeNode方法</h3><p>我们看看从红黑树中查找的方法实现</p>
<ul>
<li>return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);这里一个getTreeNode对象，也就是红黑树中节点对象，这里把Node类型的first强转为了TreeNode类型。</li>
<li>getTree方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class="line">            return ((parent != null) ? root() : this).find(h, k, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TreeNode中的find()方法，官方注释是通过这个方法找到那个元素,返回TreeNode，官方注释：</span><br><span class="line">/**</span><br><span class="line"> * Finds the node starting at root p with the given hash and key.</span><br><span class="line"> * The kc argument caches comparableClassFor(key) upon first use</span><br><span class="line"> * comparing keys.</span><br><span class="line"> */</span><br><span class="line">意思是通过传入的hash和key找到这个元素(红黑树TreeNode类型)。</span><br><span class="line"> final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = this;</span><br><span class="line">            do &#123;</span><br><span class="line">                int ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                if ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if (pl == null)</span><br><span class="line">                    p = pr;</span><br><span class="line">                else if (pr == null)</span><br><span class="line">                    p = pl;</span><br><span class="line">                else if ((kc != null ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != null) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != 0)</span><br><span class="line">                    p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">                else if ((q = pr.find(h, k, kc)) != null)</span><br><span class="line">                    return q;</span><br><span class="line">                else</span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; while (p != null);</span><br><span class="line">            return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-9-resize方法"><a href="#1-9-resize方法" class="headerlink" title="1.9 resize方法"></a>1.9 resize方法</h3><p>resize方法分析：</p>
<ul>
<li>这个方法用于进行扩容，会伴随着一次重新的hash分配，并且会遍历hash表中所有的元素，非常耗时。在编写程序时，尽量避免resize。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            //超过最大值就不再扩充了</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            //没有超过最大值，扩充为原来两倍</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        //计算新的resize上限，是为ft，还是Integer得最大值</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">            //把每个桶都移到新的桶中</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            //原索引</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //原索引 + oldCap</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        //原索引放到bucket中</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //原索引 + oldCap放到bucket中</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="以下内容学习自以下博客"><a href="#以下内容学习自以下博客" class="headerlink" title="以下内容学习自以下博客"></a>以下内容学习自以下博客</h3><p><a href="https://juejin.im/post/5c332cfff265da611e4dd216" target="_blank" rel="noopener">HashMap</a></p>
<h4 id="下面以知识点的形式对HashMap进行解析"><a href="#下面以知识点的形式对HashMap进行解析" class="headerlink" title="下面以知识点的形式对HashMap进行解析"></a>下面以知识点的形式对HashMap进行解析</h4><p><strong>1，容量和 size 分别指什么？</strong><br>答：容量并不是指 HashMap 所能存储的键值对数量，而是其内部的 table 数组的大小，而 size 是指目前已存储的键值对的数量。table 是一个 Entry 数组。 table 的每一个节点都连着一个链表或者红黑树。<br><strong>2,初始容量可以随意设置吗？</strong><br>答：可以，但是 HashMap 内部会你设置的 initialCapacity 转换为大于等于它的最小的2的n次方。比如 20 转为 32，32 转为 32等。如果不设置，则为默认值16。需要注意的是，在 Java 8的源码中，并没有在构造方法直接新建数组。而是先将处理后的容量值赋给 threshold，在第一次存储键值对时再根据这个值创建数组。<br><strong>3，HashMap为什么要将容量转换为2的n次方？</strong><br>答：这是为了提高取余的效率，存储键值对时，通过hash函数对key(键)求出key的hash值后，需要对数组的容量进行取余，余数即为key-value对在数组中的index(索引)。我们知道对于计算机而言，二进制计算的效率远远高于取余操作(%)。而容量如果是2的n次方的话，hash值对其取余就等同于hash值和容量值减1进行按位与操(&amp;)作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//capacity为2的n次方的话，下面两个操作结果相同</span><br><span class="line">hash &amp; (capacity - 1)</span><br><span class="line">值等于</span><br><span class="line">hash % capacity</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：如果一个数是2的n次方，那它的二进制就是从右往左n位都是0，第n+1位是1。2的3次方二进制是1000,2的5次方二进制是100000，这个数的倍数也满足从右往左n为0，取余的时候抛弃倍数，就等同于将n+1位及其往左的所有位都置0，剩下的n位就代表余数。<strong>也就是说，一个数对2的n次方取余，就是要取这个数二进制的最低n位。</strong>2的n次方减1的结果就是n个1，进行与操作后得到了最低n位。</p>
<p><strong>*4，HashMap的初始容量为多少？可以自己设置吗？</strong><br>答：HashMap的初始容量为16，也就是不指定容量的情况下默认为16，可以自己设置，但HashMap内部会根据我们设置的initCapacity转换为大于等于它的最小的2的n次方。比如20默认转换为32,32转换为32。如何转换看问题3。</p>
<p><strong>5，如何将一个数转换为大于等于它的最小的2的n次方呢？</strong><br>答：如下代码所示，这是HashMap的源码：<br><img src="/picture/QQ%E6%88%AA%E5%9B%BE20190108044357.png" alt><br>我们先看代码的运行过程，如果我们在实例化HashMap对象的时候，在构造函数传入一个int值，也就是我们想自己设置容量的大小，此时会调用1处的构造函数，然后又调用了2处的构造函数，这个函数有两个参数，前面的代码是一些提高代码健壮性的代码，我们暂时不看，我们看到最后一行代码：<br>        this.threshold = tableSizeFor(initialCapacity);<br>threshold是int类型，所以tableSizeFor应该返回的也是int型，我们看tableSizeFor的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析一下这两行代码，tableSizeFor函数会返回一个数，这个int类型的数是大于等于它的最小的数并且是2的n次方。<br>numberOfLeadingZeros函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int numberOfLeadingZeros(int i) &#123;</span><br><span class="line">        // HD, Count leading 0&apos;s</span><br><span class="line">        if (i &lt;= 0)</span><br><span class="line">            return i == 0 ? 32 : 0;</span><br><span class="line">        int n = 31;</span><br><span class="line">        if (i &gt;= 1 &lt;&lt; 16) &#123; n -= 16; i &gt;&gt;&gt;= 16; &#125;</span><br><span class="line">        if (i &gt;= 1 &lt;&lt;  8) &#123; n -=  8; i &gt;&gt;&gt;=  8; &#125;</span><br><span class="line">        if (i &gt;= 1 &lt;&lt;  4) &#123; n -=  4; i &gt;&gt;&gt;=  4; &#125;</span><br><span class="line">        if (i &gt;= 1 &lt;&lt;  2) &#123; n -=  2; i &gt;&gt;&gt;=  2; &#125;</span><br><span class="line">        return n - (i &gt;&gt;&gt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6，hash值是怎么计算的？</strong><br>答：hash函数的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，函数没有直接返回hashcode的返回值，而是进行了一些处理。我们通过hash函数得到的值要和Node数组容量进行按位与操作，我们已经知道这个操作的结果只与hash值的低n位有关，如果低n位时固定的或者集中在几个值，那么按位与的结果会很多相同，这就做”哈希碰撞”或”哈希冲突”，由于hashCode()函数可以重写，重写的时候可能写了一个性能不好的hashCode()函数，导致”哈希碰撞”产生。<br>为了尽量避免这种情况发生，HashMap的做法是先将hash值向右移，再进行异或操作，这样就使得高位的值和低位的值融合成一个新的值，这样可以保证后面的按位与操作受每一个二进制位的影响。</p>
<p><strong>7，扩容后元素如何进行移动</strong><br>答：为了防止元素增多后，链表越来越长，HashMap 会在元素个数达到阈值后进行扩容，新的容量为旧容量的2倍。容量变化后，每个元素用 hash 值取余的结果也会随之变化，需要在数组中重新排列。以前同一条链表上的元素，扩容后可能存在不同的链表上。</p>
<p>在 Java 7 中，重新排列实现得简单粗暴，直接用 hash 根据新容量算出下标，然后设置到新数组中，即相当于将元素重新put 了一次。但在 Java 8中，作者发现没必要重新插入，因为重新计算后，新的下标只可能有两种情况，要么是原来的值，要么是原来的值加旧容量。比如容量为16的数组扩容到32，下标为1的元素重新计算后，下标只可能为1或17。</p>
<p>这个怎么理解呢？重提一下之前的一句话，一个数对2的 n 次方取余，就是要取这个数二进制的最低 n 位。当容量为16时，取余是取最后4位的值，而扩容到32后，取余变成取最后5位的值。这里增加的1位如果为0，那么余数就没变，如果为1，那么余数就增加了16。如何取增加的这一位的值呢？直<br>接和16进行与操作即可。16的二进制是10000，与操作后如果结果为0，即表示高位为0，否则为1。</p>
<p>根据这个原理，我们只需要将原来的链表分成两条新链放到对应的位置即可，下面是具体步骤：</p>
<ul>
<li>遍历旧数组，如果元素的 next 为空，直接取余后放到新数组；</li>
<li>如果元素后面连了一个链表，那么新建两条链表，暂且成为 hi 链和 lo 链；</li>
<li>遍历链表，计算每个元素的 hash 值和旧容量与操作的结果，结果为0则将其放入 lo 链末端，不为0放入 hi 链末端；</li>
<li>将两条链的 head 放到新数组中，其中 loHead 放到原来的位置，hiHead 放到原来的下标加上旧容量处；</li>
<li>如果是红黑树，进行和上面类似的操作，只是将两条链表换成两棵树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">if (oldTab != null) &#123;</span><br><span class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">        oldTab[j] = null;</span><br><span class="line">        if (e.next == null) </span><br><span class="line">            newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">        else if (e instanceof TreeNode) //红黑树类似</span><br><span class="line">            ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">        else &#123; // preserve order</span><br><span class="line">            //新建两条链表</span><br><span class="line">            Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">            Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            do &#123;</span><br><span class="line">                next = e.next;</span><br><span class="line">                if ((e.hash &amp; oldCap) == 0) &#123; //结果为0，表示下标没变，放入 lo 链</span><br><span class="line">                    if (loTail == null)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    else</span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123; //结果为0，表示下标要加上旧容量，放入 hi 链</span><br><span class="line">                    if (hiTail == null)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    else</span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; while ((e = next) != null);</span><br><span class="line">            if (loTail != null) &#123; //lo 链放在原来的下标处</span><br><span class="line">                loTail.next = null;</span><br><span class="line">                newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            if (hiTail != null) &#123; //hi 链放在原来的下标 加旧容量处</span><br><span class="line">                hiTail.next = null;</span><br><span class="line">                newTab[j + oldCap] = hiHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((e.hash &amp; oldCap) == 0)</span><br></pre></td></tr></table></figure>

<p>这里是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位。<br>还没理解，，，</p>
<p><strong>增加元素</strong><br>往表中添加一个元素，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //先根据key，取得hash值。 再调用上一节的方法插入节点</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个hash函数也称为扰动函数，它的目的是为了让得出来的hash值更加均衡，与n-1作与运算(也就是计算元素在table表中的位置)后的值更加分散，减小哈希冲突。</p>
<p>以下内容来源于转载：<br>因为hashCode()是int类型，取值范围是40多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。但就算原本的hashCode()取得很好，每个key的hashCode()不同，但是由于HashMap的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有hashCode()的低位参加运算，发生不同的hash值，但是得到的index相同的情况的几率会大大增加，这种情况称之为hash碰撞。 即，碰撞率会增大。<br>扰动函数就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）<br><strong>9，删除元素</strong><br>以key为条件删除元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">            null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果key对应的value存在，则删除这个键值对。 并返回value。如果不存在 返回null。<br><strong>10,HashMap与Hashtable的区别</strong></p>
<ul>
<li>a,与之相比HashTable是线程安全的，且不允许key、value是null。</li>
<li>b,HashTable默认容量是11。</li>
<li>c,HashTable是直接使用key的hashCode(key.hashCode())作为hash值，不像HashMap内部使用- d,static final int hash(Object key)扰动函数对key的hashCode进行扰动后作为hash值。</li>
<li>HashTable取哈希桶下标是直接用模运算%.（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算）</li>
<li>扩容时，新容量是原来的2倍+1。int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</li>
<li>Hashtable是Dictionary的子类同时也实现了Map接口，HashMap是Map接口的一个实现类；</li>
</ul>
<p>腾讯云：<a href="https://hexoblog-1257580711.cos-website.ap-guangzhou.myqcloud.com" target="_blank" rel="noopener">https://hexoblog-1257580711.cos-website.ap-guangzhou.myqcloud.com</a></p>

    </div>

    
    
    
      

        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/java/" rel="tag"># java</a>
            
              <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/01/07/python进阶学习三-面向对象/" rel="next" title="python进阶学习三(面向对象)">
                  <i class="fa fa-chevron-left"></i> python进阶学习三(面向对象)
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/01/08/计算未来读书笔记/" rel="prev" title="计算未来读书笔记">
                  计算未来读书笔记 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、HashMap"><span class="nav-number">1.</span> <span class="nav-text">一、HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-treeifyBin方法"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 treeifyBin方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-putVal方法"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 putVal方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-扰动函数"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 扰动函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-拉链法"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 拉链法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-HashMap类的成员变量"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 HashMap类的成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Jdk-8-putVal方法的源码"><span class="nav-number">1.6.</span> <span class="nav-text">1.6  Jdk 8 putVal方法的源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-jdk-1-7get方法"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 jdk 1.7get方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-getTreeNode方法"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 getTreeNode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-resize方法"><span class="nav-number">1.9.</span> <span class="nav-text">1.9 resize方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以下内容学习自以下博客"><span class="nav-number">1.10.</span> <span class="nav-text">以下内容学习自以下博客</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#下面以知识点的形式对HashMap进行解析"><span class="nav-number">1.10.1.</span> <span class="nav-text">下面以知识点的形式对HashMap进行解析</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/timg.jpg"
      alt="Lu Tian">
  <p class="site-author-name" itemprop="name">Lu Tian</p>
  <div class="site-description" itemprop="description">hhh</div>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/ltt19921124" title="GitHub &rarr; https://github.com/ltt19921124" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://liuwangshu.cn/" title="http://liuwangshu.cn/" rel="noopener" target="_blank">刘望舒</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/singwhatiwanna/" title="https://blog.csdn.net/singwhatiwanna/" rel="noopener" target="_blank">任玉刚</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://me.csdn.net/sinyu890807" title="https://me.csdn.net/sinyu890807" rel="noopener" target="_blank">郭霖</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Tian</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数"></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共168.5k字</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>








<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>






  

  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>