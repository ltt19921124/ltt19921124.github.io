<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之责任链模式]]></title>
    <url>%2F2019%2F09%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式经常应用于java和安卓中得源码中。 什么是责任链模式责任链模式是行为设计模式之一，它有很好的灵活性，这样一种结构应用于编程中，将每一个节点都看作是一个对象，每一个对象都拥有不同的处理逻辑，将一个请求从链式的手端出发，沿着链的路径依次传递给每一个对象，直至有对象助理它为止，我们将这样的设计模式成为责任链模式。 Android中的责任链模式在Android中有经典的事件分发机制，当用户接触屏幕时，Android会将对应的事件包装成一个事件对象从ViewTree从顶向下分发传递。ViewGroup中执行事件的方法是dispatchTouchEvent，在这个方法中对事件进行了统一的分发。 12]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F09%2F03%2Ftest-1%2F</url>
    <content type="text"><![CDATA[文章kk 文章]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android9.0根activity启动流程分析]]></title>
    <url>%2F2019%2F09%2F03%2FAndroid9.0%E6%A0%B9activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[activity的启动流程activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根activity的启动过程更复杂，也更具代表性，所以这里先分析根activity的启动过程。根activity的启动分为三部分：Launcher启请求AMS(ActivityManagerService)过程、AMS到ApplicationThread的调用过程以及ActivityThread启动Activity的过程。可以在这个网站在线看9.0.0_r3源码。1，Launcher请求AMS过程 Launcher启动后会显示应用的图标于桌面上，这些应用图标就是启动根activity的入口，点击它们时就会通过Launcher类来请求AMS来启动该应用程序。Launcher的源码路径为：/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java时序图如下： 2，接下来查看ApplicationThread的scheduleLaunchActivity方法，其中ApplicationThread是ActivityThread的内部类，应用程序进程创建后会运行代表主线程的实例ActivityThread，它管理着当前应用程序进程的线程。ApplicationThread的scheduleLaunchActivity方法如下所示。1234567891011121314151617@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; ... updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; scheduleLaunchActivity方法会将启动Activity的参数封装成ActivityClientRecord ，sendMessage方法向H类发送类型为LAUNCH_ACTIVITY的消息，并将ActivityClientRecord 传递过去，sendMessage方法有多个重载方法，最终调用的sendMessage方法如下所示。 frameworks/base/core/java/android/app/ActivityThread.java:1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; 这里mH指的是H，它是ActivityThread的内部类并继承Handler，是应用程序进程中主线程的消息管理类。H的代码如下所示。 12345678910111213141516171819public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj;//1 r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo);//2 handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);//3 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case RELAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityRestart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ...&#125; 查看H的handleMessage方法中对LAUNCH_ACTIVITY的处理，在注释1处将传过来的msg的成员变量obj转换为ActivityClientRecord。在注释2处通过getPackageInfoNoCheck方法获得LoadedApk类型的对象并赋值给ActivityClientRecord 的成员变量packageInfo 。应用程序进程要启动Activity时需要将该Activity所属的APK加载进来，而LoadedApk就是用来描述已加载的APK文件。在注释3处调用handleLaunchActivity方法，代码如下所示。 frameworks/base/core/java/android/app/ActivityThread.java1234567891011121314151617181920212223242526272829private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ... WindowManagerGlobal.initialize(); //启动Activity Activity a = performLaunchActivity(r, customIntent);//1 if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; //将Activity的状态置为Resume handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2 if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; performPauseActivityIfNeeded(r, reason); if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; &#125; &#125; else &#123; try &#123; //停止Activity启动 ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125;&#125; 注释1处的performLaunchActivity方法用来启动Activity ，注释2处的代码用来将Activity 的状态置为Resume。如果该Activity为null则会通知AMS停止启动Activity。来查看performLaunchActivity方法做了什么： frameworks/base/core/java/android/app/ActivityThread.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //获取ActivityInfo类 ActivityInfo aInfo = r.activityInfo;//1 if (r.packageInfo == null) &#123; //获取APK文件的描述类LoadedApk r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);//2 &#125; ComponentName component = r.intent.getComponent();//3 ... //创建要启动Activity的上下文环境 ContextImpl appContext = createBaseContextForActivity(r);//4 Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); //用类加载器来创建该Activity的实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);//5 ... &#125; catch (Exception e) &#123; ... &#125; try &#123; //创建Application Application app = r.packageInfo.makeApplication(false, mInstrumentation);//6 ... if (activity != null) &#123; ... /** *7 初始化Activity */ activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);//8 &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; 注释1处用来获取ActivityInfo，ActivityInfo用于存储代码和AndroidManifes设置的Activity和receiver节点信息，比如Activity的theme和launchMode。在注释2处获取APK文件的描述类LoadedApk。注释3处获取要启动的Activity的ComponentName类，ComponentName类中保存了该Activity的包名和类名。注释4处用来创建要启动Activity的上下文环境。注释5处根据ComponentName中存储的Activity类名，用类加载器来创建该Activity的实例。注释6处用来创建Application，makeApplication方法内部会调用Application的onCreate方法。注释7处调用Activity的attach方法初始化Activity，attach方法中会创建Window对象（PhoneWindow）并与Activity自身进行关联。注释8处会调用Instrumentation的callActivityOnCreate方法来启动Activity，如下所示。 frameworks/base/core/java/android/app/Instrumentation.java123456final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle, persistentState); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; performCreate方法中会调用Activity的onCreate方法，讲到这里，根Activity就启动了，即应用程序就启动了。根Activity启动过程就讲到这里，下面我们来学习根Activity启动过程中涉及到的进程。 3,根Activity启动过程中涉及的进程]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>activity启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Handler内存泄漏及解决方式]]></title>
    <url>%2F2019%2F08%2F26%2FAndroid%E4%B9%8BHandler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android开发之内存泄漏此文参考自Android内存泄露在Android开发中，内存泄漏非常常见。 所谓内存泄漏，就是本来应该被回收的对象未能被回因而导致对象留在内存中。内存泄漏产生的原因：当一个对象不再被使用时，本该回收但是此时有另外一个正在使用的对象持有它的引用从而导致它不能被回收。在Android开发中，Handler内存泄漏极为常见。Handler的用法有：新建Handler子类、匿名内部类。匿名内部类使用方式： 12345678910111213141516171819//匿名内部类 Handler myHandler = new Handler() &#123; @Override public void handleMessage(@NonNull Message msg) &#123; super.handleMessage(msg); //处理业务逻辑 &#125; &#125;;//启动子线程new Thread(new Runnable() &#123; @Override public void run() &#123; //定义发送的消息 Message message = Message.obtain(); message.what = UPDATE; //向MessageQueue队列发送消息，传入主线程的Handler myHandler.sendMessage(message); &#125;&#125;).start(); 定义内部类方式 12345678910111213141516171819202122232425262728//静态Handler类配合弱引用使用 class MyHandler extends Handler &#123; @Override public void handleMessage(@NonNull Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case UPDATE: text.setText(&quot;nice&quot;); break; default: break; &#125; &#125; &#125; &#125; MyHandler myHandler = new MyHandler();//启动子线程new Thread(new Runnable() &#123; @Override public void run() &#123; //定义发送的消息 Message message = Message.obtain(); message.what = UPDATE; //向MessageQueue队列发送消息，传入主线程的Handler myHandler.sendMessage(message); &#125;&#125;).start(); 这两种方式并没有太大的区别。不过上述两种方式都有内存泄漏的风险。如上图所示，Android Studio提示Handler没有被设置为静态类的时候会造成泄漏。 Handler泄漏原因在java中，静态内部类和匿名内部类都默认持有外部类的引用。Android中Handler消息队列还有未处理的消息时(或还有正在处理的消息)，消息队列的Message会持有Handler实例的引用。而同时由于Handler的使用方式(非静态内部类和静态内部类)，又会持有外部类的引用(MainActivity实例)，这个引用链会一直保持，直到handler消息队列中的消息都被处理完。 在Handler队列还有未处理完的消息时或正在处理消息时，此时若需要销毁外部类，但是由于引用关系，GC(垃圾回收器)无法回收MainActivity，从而造成内存泄漏。 解决方法一(静态内部类+弱引用)解决这个可以用静态Handler内部类加上弱引用的方式。因为静态内部类不会持有外部类的引用，从而使得”未被处理/正在处理的消息–&gt;Handler实例–&gt;外部类”这条引用链不成立。同时还可以加上WeakReference弱引用持有Activity实例，因为弱引用对象拥有短暂的生命周期，在GC的时候一旦发现了只具有弱引用的对象，不管内存空间是否足够，都会回收它。 123456789101112131415161718192021222324252627282930313233343536373839404142//静态Handler类配合弱引用使用static class MyHandler extends Handler &#123; //定义弱引用实例 private WeakReference&lt;MainActivity&gt; mainActivityWeakReference; //在构造方法中传入需要持有的Activity实例 private MyHandler (MainActivity activity) &#123; mainActivityWeakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(@NonNull Message msg) &#123; super.handleMessage(msg); MainActivity activity = mainActivityWeakReference.get(); if (activity != null) &#123; switch (msg.what) &#123; case UPDATE: text.setText(&quot;nice&quot;); break; default: break; &#125; &#125; &#125;&#125;private MyHandler myHandler = new MyHandler(this);@Overridepublic void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.bu: new Thread(new Runnable() &#123; @Override public void run() &#123; &lt;!-- Message message = Message.obtain(); message.what = UPDATE; //发送消息 myHandler.sendMessage(message); --&gt; //code &#125; &#125;).start(); &#125;&#125; 解决方法二(外部类结束生命周期时，清空Handler内的消息队列)12345@Overrideprotected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null);&#125; 建议：为了保证Handler中消息队列所有消息都能被执行，建议使用静态Handler内部类 + 弱引用的方式。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一致性哈希原理]]></title>
    <url>%2F2019%2F08%2F25%2F%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一致性哈希原理产生的原因及应用在工程中，我们常用服务器集群来实现数据缓存，有以下常见的策略： 添加、删除、查询数据，都将数据的id通过哈希算法转换成一个哈希值，机尾key 若有N台机器，则计算key % N的值，这个值就是该条数据所属的机器编号，无论是添加、查询、删除操作，都只在这台机器上进行 很明显这种策略有问题，如果增加或减少机器数量，代价会很高，所有的数据要根据id中心计算哈希值，并将得到的哈希值重新进行取模操作，然后进行大规模的数据迁移。为了解决这个问题，一致性哈希算法诞生了。一致性哈希算法是一种很好的数据缓存方案。假设数据根据id进行哈希算法转换成的哈希值范围是0 ~ (2^32 - 1),也就是0 ~ (2^32 - 1)的数字空间，现在将这些书头尾相连形成一个闭环，在一条数据根据id生成哈希值后对应到环中的一个位置上。如下图所示： 在图2中，data1根据id计算出哈希值key1，顺时针第一台机器是machine2，所以data1归属机器2，同理，data2归属machine3，data3和data4归属machine1。 增加机器是处理步骤假设有2台机器和3条数据，数据和机器在环中结构如下图所示：此时若加入机器m3，同时计算出m3的id在m1与m2右半侧的环中，这样加入m3机器后的结构如下图所示： 在没有添加m3之前，从m1到m3这一段是m2掌管的范围，添加m3之后则归属m3，同时要把这一段旧数据从m2迁移到m3上，由此可见添加机器时的调整代价较小。删除机器时也一样，只要把删除的机器上的数据全部复制到顺时针找到的下一台机器上即可，比如在图4删除机器m2，m2上的数据data2只要把它迁移到m1上即可。 机器负载不均时的处理，很有可能造成机器在整个环上的分布不均匀，从而导致机器之间的负载不均衡，如下图两台机器，m1比m2面临更大的负载。 为了解决这种数据倾斜的问题，一致性哈希算法引入了虚拟节点，即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。具体做法可以在主机ip地址或主机名的后面加编号或者端口号来实现。如上图所示可以为每台机器计算两个虚拟节点 ，分别计算m1 - 1、m1- 2、m2 - 1、m2 - 2的哈希值，于是形成四个虚拟节点，节点数变多了，根据哈希函数的性质，平衡性会更好。 此时数据定位算法不变，只是多走了一步虚拟节点的映射，如下表 当一条数据计算出归属于某一个虚拟节点时，再根据上表的跳转，数据将最终归属于实际的机器；同样虚拟节点之间的数据迁移操作也可以根据上表的对应关系，变成实际机器之间的数据迁移操作。上述例子是给每台机器分配两个虚拟节点的情况。那么如果有三台机器A、B、C，我们给每台机器分配1万个虚拟节点，一共有3万个虚拟节点去抢占哈希环中的位置。那么在3万个虚拟节点中，有三分之一属于A、三分之一属于B、三分之一属于C，如果对外提供服务那么这三台机器实际上是负载均衡的。也就是说我们让每台机器分配较多的虚拟节点去抢占哈希环，数量多起来后，哈希函数的离散型就可以得到很好的体现，然后每台机器就可以按照虚拟节点的比例来分配负载了，这就是虚拟节点技术。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java高并发系列：4种常用的线程锁的特点，性能比较和使用场景]]></title>
    <url>%2F2019%2F08%2F23%2Fjava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[多线程的由来在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。 使用多线程的理由之一是和进程相比，它是一种非常花销小，切换快，更”节俭”的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而在进程中的同时运行多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。 多线程并发面临的问题多线程并发面临的问题： 多线程资源共享 锁的选择 线程死锁由于多个线程是共同占有所属进程的资源和地址空间的，那么就会存在一个问题：如果多个线程要同时访问某个资源，怎么处理？ Java提供了多种多线程锁机制的实现方式，常见的有： synchronized ReentrantLock Semaphore AtomicInteger每种机制都有优缺点与各自的适用场景，必须熟练掌握他们的特点才能在Java多线程应用开发时得心应手。 4种java线程锁(线程锁)1，synchronized在Java中synchronized关键字被常用于维护数据一致性。synchronized机制是给共享资源上锁，只有拿到锁的线程才可以访问共享资源，这样就可以强制使得对共享资源的访问都是顺序的。Java开发人员都认识synchronized，使用它来实现多线程的同步操作是非常简单的，只要在需要同步的对方的方法、类或代码块中加入该关键字，它能够保证在同一个时刻最多只有一个线程执行同一个对象的同步代码，可保证修饰的代码在执行过程中不会被其他线程干扰。使用synchronized修饰的代码具有原子性和可见性，在需要进程同步的程序中使用的频率非常高，可以满足一般的进程同步要求。 123synchronized &#123; //&#125; synchronized实现的机理依赖于软件层面上的JVM，因此其性能会随着Java版本的不断升级而提高。到了Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7与1.8中，均对该关键字的实现机理做了优化。 需要说明的是，当线程通过synchronized等待锁时是不能被Thread.interrupt()中断的，因此程序设计时必须检查确保合理，否则可能会造成线程死锁的尴尬境地。 最后，尽管Java实现的锁机制有很多种，并且有些锁机制性能也比synchronized高，但还是强烈推荐在多线程应用程序中使用该关键字，因为实现方便，后续工作由JVM来完成，可靠性高。只有在确定锁机制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如ReentrantLock等。 2，ReentrantLock可重入锁，顾名思义，这个锁可以被线程多次重复进入进行获取操作。 ReentantLock继承接口Lock并实现了接口中定义的方法，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。 Lock实现的机理依赖于特殊的CPU指定，可以认为不受JVM的约束，并可以通过其他语言平台来完成底层的实现。在并发量较小的多线程应用程序中，ReentrantLock与synchronized性能相差无几，但在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准。 因此我们建议在高并发量情况下使用ReentrantLock。 ReentrantLock引入两个概念：公平锁与非公平锁。 公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁。反之，JVM按随机、就近原则分配锁的机制则称为不公平锁。 ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。这是因为，非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。 ReentrantLock通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock必须在finally控制块中进行解锁操作。通常使用方式如下所示： 12345678910111213Lock lock = new ReentrantLock();try &#123; lock.lock(); //…进行任务操作5 &#125;finally &#123; lock.unlock();&#125; 3,Semaphore上述两种锁机制类型都是“互斥锁”，学过操作系统的都知道，互斥是进程同步关系的一种特殊情况，相当于只存在一个临界资源，因此同时最多只能给一个线程提供服务。但是，在实际复杂的多线程应用程序中，可能存在多个临界资源，这时候我们可以借助Semaphore信号量来完成多个临界资源的访问。 Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。 经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。 此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。 Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在finally代码块中完成。 4,AtomicInteger首先说明，此处AtomicInteger是一系列相同类的代表之一，常见的还有AtomicLong、AtomicLong等，他们的实现原理相同，区别在与运算对象类型的不同。 我们知道，在多线程程序中，诸如++i或i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock的好几倍。 java多线程总结1，synchronized在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好。 2，ReentrantLock在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍，而ReentrantLock确还能维持常态。 高并发量情况下使用ReentrantLock。 3，Atomic和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。 所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。 以上就是Java线程锁的详解，除了从编程的角度应对高并发，更多还需要从架构设计的层面来应对高并发场景，例如：Redis缓存、CDN、异步消息等。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java锁介绍：独享锁/共享锁+公平锁/非公平锁+乐观锁/ 悲观锁]]></title>
    <url>%2F2019%2F08%2F23%2Fjava%E9%94%81%E4%BB%8B%E7%BB%8D%EF%BC%9A%E7%8B%AC%E4%BA%AB%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81-%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[该文转载于java锁介绍：独享锁/共享锁+公平锁/非公平锁+乐观锁/ 悲观锁在Java并发场景中，会涉及到各种各样的锁，比如：高并发编程系列：4种常用Java线程锁的特点，性能比较、使用场景，这些锁有对应的种类：公平锁，乐观锁，悲观锁等等，这篇文章来详细介绍各种锁的分类： 公平锁/非公平锁 可重入锁 独享锁/共享锁 分段锁 自旋锁 乐观锁 VS 悲观锁1，乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。 简单来说，CAS算法有3个三个操作数： 需要读写的内存值 V 进行比较的值 A 要写入的新值 B 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。2,悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的MySQL关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。详情可以参考：阿里P8架构师谈：MySQL行锁、表锁、悲观锁、乐观锁的特点与应用 再比如上面提到的Java的同步synchronized关键字的实现就是典型的悲观锁。 3,总结 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 乐观锁 VS 悲观锁1，公平锁就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 2，非公平锁上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 3，典型应用java jdk并发包中的ReentrantLock可以指定构造函数的boolean类型来创建公平锁和非公平锁（默认）,比如：公平锁可以使用new ReentrantLock(true)实现。 独享锁 VS 共享锁1，独享锁是指该锁一次只能被一个线程所持有。2，共享锁是指该锁可被多个线程所持有。3，比较对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。4，AQS抽象队列同步器（AbstractQueuedSynchronizer，简称AQS）是用来构建锁或者其他同步组件的基础框架，它使用一个整型的volatile变量（命名为state）来维护同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。 concurrent包的实现结构如上图所示，AQS、非阻塞数据结构和原子变量类等基础类都是基于volatile变量的读/写和CAS实现，而像Lock、同步器、阻塞队列、Executor和并发容器等高层类又是基于基础类实现。 分段锁分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。 分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程系列：java线程池的使用方式，核心运行原理及注意事项]]></title>
    <url>%2F2019%2F08%2F23%2Fjava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%9Ajava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%A0%B8%E5%BF%83%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[为什么需要线程池java中为了提高并发度，可以使用多线程共同执行，但是与此同时如果有大量的线程在短时间内被创建和销毁，会占用大量的系统时间，影响系统效率。 为了解决上述问题，java引入了线程池,可以使创建好的线程在指定的时间内由系统统一管理，而不是在执行时才创建，执行后就销毁，从而避免了频繁创建、销毁线程带来的额外的系统开销。文章主要讲解线程池如何使用，以及实现原理、处理步骤，以及注意事项。 线程池的处理流程以ThreadPoolExecutor为例，当我们把一个Runnable交给线程池去执行的时候，这个线程池处理的流程是这样的： 线程池的使用(ThreadPoolExecutor)在java中，线程池是Executor这个接口，具体的实现是ThreadPoolExecutor类，它是线程池中最核心的一个类，因此要理解java中的线程池，必须先了解这个类。ThreadPoolExecutor提供了四个构造函数，它继承自AbstractExecutorService类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//5个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125;//6个参数的构造函数 ublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125;//6个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); &#125;//7个参数的构造函数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125;// 观察可发现，前面三个构造函数都是调用了最后一个构造函数的实现。 构造函数中各个参数的含义1，corePoolSize(线程池的基本大小)当一个任务提交到线程池时，线程池会创建一个线程来执行任务，即使其他的空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池就会提前创建并启动所有基本线程。2，runnableTaskQueue（任务队列）用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。 PriorityBlockingQueue：一个具有优先级得无限阻塞队列。3，maximumPoolSize（线程池最大大小）线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。 4，ThreadFactory：用于设置创建线程的工厂**可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。 5，RejectedExecutionHandler（饱和策略）当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。n AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务 DiscardPolicy：不处理，丢弃掉。 当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务 6，keepAliveTime（线程活动保持时间）线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。 7，TimeUnit（线程活动保持时间的单位）可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。 线程池的注意事项线程池能大大提高服务器的并发性能，但使用它也会存在一定风险。与所有多线程应用程序一样，用线程池构建的应用程序容易产生各种并发问题，如对共享资源的竞争和死锁。此外，如果线程池本身的实现不健壮，或者没有合理地使用线程池，还容易导致与线程池有关的死锁、系统资源不足和线程泄漏等问题。 1，建议使用new ThreadPoolExecutor(…)的方式创建线程池线程池的创建不应使用Executors 去创建，而应该通过 ThreadPoolExecutor创建，这样可以让读者更加明确地知道线程池的参数设置、运行规则，规避资源耗尽的风险，这一点在也阿里巴巴JAVA开发手册中也有明确要求。这一点不容小觑，曾有同学因为线程池使用不当导致生产的同一台机器上部署的多个应用都因无法创建线程池而出现故障。 2，合理设置线程数线程池的工作线程数设置应根据实际情况配置，CPU密集型业务（搜索、排序等）CPU空闲时间较少，线程数不能设置太多。如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1。如果是IO密集型任务，参考值可以设置为2*NCPU。 3，设置能代表具体业务的线程名称这样方便通过日志的线程名称识别所属业务。具体实现可以通过指定ThreadPoolExecutor的ThreadFactory参数，如使Spring提供的CustomizableThreadFactory。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程Synchronized同步锁]]></title>
    <url>%2F2019%2F08%2F22%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BSynchronized%E5%90%8C%E6%AD%A5%E9%94%81%2F</url>
    <content type="text"><![CDATA[java并发编程与Synchronized简介提到java并发编程我们就不得不谈到synchronized，我们现在学习synchronizd的底层原理。掌握以下知识点： 1,synchronized的底层原理 2,synchronized锁与JVM的实现 3,synchronized锁升级顺序 4,synchronized锁的优劣和应用场景synchronizedsynchronized中文意思是”同步”,或”同步锁”。synchronized的作用是保证在同一时刻，被修饰的代码块或方法只会有一个线程执行,以达到保证并发环境下的线程安全。 synchronized的使用1，synchronized的3种使用方式 修饰实例方法：作用于当前实例加锁 修饰静态方法：作用于当前类对象加锁 修饰代码块：指定加锁对象，对给定对象加锁2，synchronized代码示范123456789101112131415161718192021//实例方法public synchronized void method() &#123; // 代码 &#125;//静态方法public static synchronized void method() &#123; // 代码 &#125;//实例对象和类对象synchronized (this) &#123; // 代码 &#125;synchronized (TestSyn.Class) /*类对象*/&#123; // 代码 &#125; synchronized的底层实现synchronized的底层实现是完全依赖于java虚拟机的。所以先看看JVM内存的存储：java对象头，以及Monitor对象。1，java对象头在JVM中，对象在内存中的存储布局，可以分为三个区域： 对象头(Header) 实例数据(INstance Data) 对齐填充(Padding)Jvva对象头主要包含两部分数据： 类型指针(Mark Word)：是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 标记字段：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、线程持有的锁、偏向线程ID、偏向时间戳等等。它是实现轻量级锁和偏向锁的关键 2,java对象存储位置很明显synchronized使用的锁对象存储在java对象头里的标记字段里。 3，Monitorsynchronized的对象锁，指针指向一个monitor对象(由C++实现)的起始地址，每个对象实例都会有一个monitor。Monitor描述为对象监视器，可以类比为一个特殊的房间，这个房间里有一些被保护的数据，Monitor保证每次只能有一个线程进入这个房间进行访问被保护的数据，进入房间即为持有Monitor，退出房间即为释放Monitor。使用synchronized加锁的同步代码块在字节码引擎中执行时，主要就是通过锁对象的monitor的取用与释放来实现的。4，线程状态流转在Monitor上的实现描述为对象监视器，当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程： Contention:所有请求锁的线程将被首先放置到该竞争队列 Entry List：Contention List中的那些有资格成为候选人的线程被移到Entry List Wait List：那些调用wait方法被阻塞的线程被放置到wait list。 OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程被称为OnDeck owner:获得锁的线程称为owner !Owner:释放锁的线程 synchronized锁的升级顺序锁解决了数据的安全性问题，但是同样带来的性能的下降，hotspot虚拟机的作者经过调查发现：大部分情况下，加锁的代码不仅仅存在多线程竞争，而且总是由一个线程多次获得。所以基于这样一个概率，在JDK 6之后进行了一些优化，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁、轻量级锁、自旋锁、重量级锁，锁的状态根据竞争激烈的程度从低到高不断升级。 1，偏向锁偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其它的线程获取，则持有偏向锁的线程将永远不需要同步。2，轻量级锁如果明显存在其它线程申请锁，那么偏向锁将很快升级为轻量级锁。3，自旋锁自旋锁原理是如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等所持有锁的线程释放锁后立即获取锁，这样就避免用户线程和内核切换的消耗。4，重量级锁这就是原始的synchronized的实现，重量级锁的特点：其它线程试图获得锁的时候，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树序列化和反序列化]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[二叉树的序列化和反序列化二叉树记录成文件(一般是字符串形式)的过程叫做序列化，通过文件内容重构出一颗二叉树的过程叫做二叉树的反序列化。 方法一：通过先序遍历实现序列化和反序列化序列化： 123456789class Node &#123; public int value; public Node left; public Node right; public Node (int data) &#123; this.value = data; &#125;&#125; 1234567891011121314151617181920212223242526public class SerialByPre &#123; //序列化代码 public static String serialByPre (Node head) &#123; if (head == null) &#123; return &quot;#_&quot;; &#125; String res = head.value + &quot;!&quot;; res += serialByPre(head.left); res += serialByPre(head.right); return res; &#125; //主函数 public static void main(String[] args) &#123; // TODO Auto-generated method stub Node head = new Node(1); head.left = new Node(2); head.right = new Node(3); head.left.left = new Node(4); head.left.right= new Node(5); head.right.left= new Node(6); head.right.right= new Node(7); String str = serialByPre(head); System.out.println(str); &#125;&#125; 反序列化：反序列化函数： 12345678public static Node reconByPreString (String preStr) &#123; String[] strs = preStr.split(&quot;_&quot;); Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); for (int i = 0; i &lt; strs.length; i++) &#123; queue.offer(strs[i]); &#125; return reconPreOrder(queue);&#125; reconPreNode函数：作用是从一个字符串重构出一棵二叉树 12345678910 public static Node reconPreNode(Queue&lt;String&gt; queue) &#123; String value = queue.poll(); if (value.equals(&quot;#&quot;)) &#123; return null; &#125; Node head = new Node(Integer.valueOf(value)); head.left = reconPreNode(queue); head.right = reconPreNode(queue); return head;&#125; 方法二：通过先序遍历实现序列化和反序列化 123456789101112131415161718192021222324public static String serialByLevel (Node head) &#123; if (head == null) &#123; return &quot;#_&quot;; &#125; String res = head.value + &quot;_&quot;; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(head); while (!queue.isEmpty()) &#123; head = queue.poll(); if (head.left != null) &#123; res += head.left.value + &quot;_&quot;; queue.offer(head.left); &#125; else &#123; res += &quot;#_&quot;; &#125; if (head.right != null) &#123; res += head.right.value + &quot;_&quot;; queue.offer(head.right); &#125; else &#123; res += &quot;#_&quot;; &#125; &#125; return res;&#125; 1234567891011121314151617181920212223242526272829 public static Node reconByLevelString(String levelStr) &#123; String[] values = levelStr.split(&quot;_&quot;); int index = 0; Node head = generateNodeByString(values[index++]); Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); if (head != null) &#123; queue.offer(head); &#125; Node node = null; while (!queue.isEmpty()) &#123; node = queue.poll(); node.left = generateNodeByString(values[index++]); node.right = generateNodeByString(values[index++]); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return head;&#125; // public static Node generateNodeByString (String val) &#123; if (val.equals(&quot;#&quot;)) &#123; return null; &#125; return new Node(Integer.valueOf(val));&#125; 以上方法二是按层序列化二叉树和反序列化构造出一颗二叉树的代码。]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希函数、并查集以及布隆过滤器]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%A5%E5%8F%8A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[哈希函数也叫散列函数，一般是输入一个字符串或基本数据类型经过哈希函数得到一个唯一的固定位数的散列值。 哈希函数的特点1，经典哈希函数输入域可以是无穷大的(比如字符串，以及常见的对象)2，输出域一般是有穷的3，一个输入参数多次调用同一个哈希函数得到的结果是一样的4，会有两个参数的哈希值对应同一个哈希值，这个时候我们称发生了哈希碰撞5，这是很重要的性质：多个输入参数输入哈希函数后，它们的返回值分布是趋向均匀的，也是哈希函数的离散型如下图所示，这是这些文件的哈希码，我们一般用这个来检验我们下载下来的软件是否被篡改了： SHA-256:表示算法返回的哈希值为256位。可以用以下代码来算哈希值进而确定我们从网络下载下来的软件是否是被篡改了。 1certutil -hashfile jdk-12.exe SHA256 得到的哈希值如下：这个哈希值和我们在jdk官网显示出的一样，说明我们的文件并没有被篡改。同样对于.zip文件也得出一个哈希码，和官网的一样。且在命令行多次调用该方法得到的哈希码都是一样的(当然前提是文件没有被改动，只修改文件名不会有影响)!(/picture/QQ截图20190511180627.png) 一个小技巧：可以用一个哈希函数可以改出很多个哈希函数，并且它们还是相互独立的。相互独立的意思是一个哈希函数修改后的函数的规律不会和原哈希函数有关。方法是：把得到的哈希值劈成两半，把前128位数作为哈希函数1，后128位作为哈希函数2(即假设原来的哈希函数返回值有256位)，得到h1和h2后，我们可以 使 h3 = h1 + 1 * h2，这样得到h3这个新的哈希函数。h4 = h1 + 2 * h2, h5 = h1 + 3 * h2，以此类推可以得到多个相互独立的哈希值(然后它们对应相应的哈希函数)。甚至仅仅改变系数就可以得到很多个不同的哈希函数。 哈希表定义：散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。(来自百度百科) 12]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印二叉树边界节点]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BE%B9%E7%95%8C%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[打印二叉树边界节点打印二叉树的边界节点 对于边界点有如下定义(标准一)： 1,头节点是边界节点 2，叶节点也是边界节点 3，如果节点在其所在的层中是最左或最右的，那也是边界节点 定义二(或标准二)： 1，头节点是边界节点 2，叶节点是边界节点 3，树左边界延伸下去的路径是边界节点 4，树右边界延伸下去的路径是边界节点按照标准一打印：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Node1 &#123; public int value; public Node1 left; public Node1 right; public Node1 (int data) &#123; value = data; &#125;&#125;class PrintBinaryTreeEdge1 &#123; public static void printEdge1 (Node1 head) &#123; if (head == null) &#123; return; &#125; int height = getHeight(head, 0); Node1[][] edgeMap = new Node1[height][2]; setEdgeMap(head, 0, edgeMap); //打印左边界 for (int i = 0; i != edgeMap.length; i++) &#123; System.out.print(edgeMap[i][0].value + &quot; &quot;); &#125; //打印既不是左边界，也不是有边界的叶节点 printLeafNotInMap(head, 0, edgeMap); //打印右边界，但不是左边界的节点 for (int i = edgeMap.length - 1; i != -1; i--) &#123; if (edgeMap[i][0] != edgeMap[i][1]) &#123; System.out.print(edgeMap[i][1].value + &quot; &quot;); &#125; &#125; System.out.println(); &#125; public static int getHeight (Node1 h, int l ) &#123; if (h == null) &#123; return l; &#125; return Math.max(getHeight(h.left, l + 1), getHeight(h.right, l + 1)); &#125; public static void setEdgeMap(Node1 h, int ll, Node1[][] edgeMap) &#123; if (h == null) &#123; return; &#125; edgeMap[ll][0] = edgeMap[ll][0] == null ? h : edgeMap[ll][0]; edgeMap[ll][1] = h; setEdgeMap(h.left, ll + 1, edgeMap); setEdgeMap(h.right, ll + 1, edgeMap); &#125; public static void printLeafNotInMap (Node1 h, int l, Node1[][] m) &#123; if (h == null) &#123; return; &#125; if (h.left == null &amp;&amp; h.right == null &amp;&amp; h != m[l][0] &amp;&amp; h != m[l][1]) &#123; System.out.print(h.value + &quot; &quot;); &#125; printLeafNotInMap(h.left, l + 1, m); printLeafNotInMap(h.right, l + 1, m); &#125; //主方法 public static void main(String[] args) &#123; // TODO Auto-generated method stub Node1 head = new Node1(1); head.left = new Node1(2); head.right = new Node1(3); head.left.left = new Node1(4); head.left.right= new Node1(5); head.right.left= new Node1(6); head.right.right= new Node1(7); printEdge1(head); &#125;&#125; 按照标准二打印： 1234567891011121314151617181920212223242526272829303132333435public static void printEdge2 (Node head) &#123; if (head == null) &#123; return; &#125; System.out.print(head.value + &quot; &quot;); if (head.left != null &amp;&amp; head.right != null) &#123; printLeftEgde(head.left, true); printRightEdge(head.right, true); &#125; else &#123; printEdge2(head.left != null ? head.left : head.right); &#125; System.out.println();&#125;//打印左边界public static void printLeftEgde (Node h, boolean print) &#123; if (h == null) &#123; return; &#125; if (print || (h.left == null &amp;&amp; h.right == null)) &#123; System.out.print(h.value + &quot; &quot;); &#125; printLeftEgde(h.left, print); printLeftEgde(h.right, print &amp;&amp; h.left == null ? true : false);&#125;//打印右边界public static void printRightEdge (Node h, boolean print) &#123; if (h == null) &#123; return; &#125; printRightEdge(h.left, print &amp;&amp; h.right == null ? true : false); printLeftEgde(h.right, print); if (print || (h.left == null &amp;&amp; h.right == null)) &#123; System.out.print(h.value + &quot; &quot;); &#125;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信封嵌套问题]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[给定一个N行2列的二维数组arr，每一个小数组的两个值分别代表一个信封的长和宽，如果信封A的长和宽小于信封B，那么信封A可以放在信封B里，返回信封最多可以嵌套多少层。 例：arr = { {3,4} {2,3} {4,5} {1,3} {2,3} {3,6} {1,2} {3,2} {2,4}}信封最多可以嵌套4层，从里到外分别是{1,2} {2,3} {3,4} {4,5}，所以返回4。此问题与最长增长子序列问题思想类似。 把N个长度为2的小数组变成信封数组。然后对信封数组排序，排序的策略为：按照长度从小到大排序，长度相等的信封之间按照宽度从大到小排序，代码如下：//定义信封类以及信封的长和宽信息 123456789class Envelope &#123; public int len; public int wid; public Envelope (int len,int wid) &#123; this.len = len; this.wid = wid; &#125;&#125; //定义类进行信封的比较 12345678class EnvelopeComparator implements Comparator&lt;Envelope&gt; &#123; @Override public int compare(Envelope o1, Envelope o2) &#123; // TODO Auto-generated method stub return o1.len != o2.len ? o1.len - o2.len : o2.wid - o1.wid; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MostEnvelope &#123; public static Envelope[] getSortedEnvelopes (int[][] matrix) &#123; Envelope[] res = new Envelope[matrix.length]; for (int i = 0; i &lt; matrix.length; i++) &#123; res[i] = new Envelope(matrix[i][0], matrix[i][1]); &#125; Arrays.parallelSort(res,new EnvelopeComparator()); return res; &#125; //这是主方法 public static int maxEnvelopes(int[][] matrix) &#123; Envelope[] envelopes = getSortedEnvelopes(matrix); int[] ends = new int[matrix.length]; ends[0] = envelopes[0].wid; int right = 0; int l = 0; int r = 0; int m = 0; for (int i = 1;i &lt; envelopes.length;i++) &#123; l = 0; r = right; while (l &lt;= r) &#123; m = (l + r) / 2; if (envelopes[i].wid &gt;ends[m]) &#123; l = m + 1; &#125; else &#123; r = m - 1; &#125; &#125; right = Math.max(right, l); ends[l] = envelopes[i].wid; &#125; return right + 1; &#125; //测试代码 public static void main(String[] args) &#123; // TODO Auto-generated method stub //定义数组 int[][] matrix = &#123; &#123;2,3&#125;,&#123;4,5&#125;,&#123;3,4&#125;,&#123;2,2&#125;,&#123;2,4&#125;,&#123;3,6&#125;&#125;; System.out.println(maxEnvelopes(matrix)); &#125;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长增长子序列]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%9C%80%E9%95%BF%E5%A2%9E%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最长增长子序列给定一个数组arr，返回arr的最长增长子序列，例，arr = {7,1,9,3,8,19},最长增长子序列为 {1,3,8,19}。12345678910111213141516171819 public static int[] generateLIS (int[] arr,int[] dp) &#123; int len = 0; int index = 0; for (int i = 0;i &lt; dp.length;i ++) &#123; if (dp[i] &gt; len) &#123; len = dp[i]; index = i; &#125; &#125; int[] lis = new int[len]; lis[--len] = arr[index]; for (int i = index;i &gt;= 0;i--) &#123; if (arr[i] &lt; arr[index] &amp;&amp; dp[i] == dp[index] - 1) &#123; lis[--len] = arr[i]; index = i; &#125; &#125; return lis;&#125; 123456789101112 public static int[] getdp1 (int[] arr) &#123; int[] dp = new int[arr.length]; for (int i = 0;i &lt; arr.length;i++) &#123; dp[i] = 1; for (int j = 0;j &lt; i;j++) &#123; if (arr[i] &gt; arr[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; return dp;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换钱的方法数]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%8D%A2%E9%92%B1%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0%2F</url>
    <content type="text"><![CDATA[换钱的方法数给定数组arr，arr中的值都为正数且不重复，每一个值代表一种货币面值，每种面值的货币可使用任意张，再给定一个正数aim，代表要找的钱数，求换钱有多少种方法。 举例：arr = [5,10,25,1],aim = 0;方法有1种，即所有面值的货币都不适用，返回1。arr = [5,10,25,1],aim = 15;方法有6种，3张5元；1张10元、1张5元；1张10元、、5张1元；10张1元、1张5元；2张5元、5张1元；15张1元，所以返回6。 递归方法递归方法代码如下：主方法： 1234567 public static int coins1(int[] arr,int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; return process1(arr,0,aim);&#125; 1234567891011public static int process1 (int[] arr,int index,int aim) &#123; int res = 0; if (index == arr.length) &#123; res = aim == 0 ? 1 : 0; &#125; else &#123; for (int i = 0;arr[index] * i &lt;= aim;i++) &#123; res += process1(arr, index + 1, aim - arr[index] * i); &#125; &#125; return res; &#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换钱最少货币数]]></title>
    <url>%2F2019%2F04%2F24%2F%E6%8D%A2%E9%92%B1%E6%9C%80%E5%B0%91%E8%B4%A7%E5%B8%81%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定数组arr，arr中所有的值都为正数且不重复，每个值代表一种面值的货币，每种面的值货币可以使用任意张，再给定一个正数aim，代表要找的钱数，求组成aim的最少货币数。 举例：arr=[5,2,3]，aim = 20。4张5元可以组成20元，其它的方法都会需要更多的方法数，所以返回4。arr=[5,2,3]，aim=0。不用任何货币就可以组成0元，返回0；arr=[5,2,3]，aim=2。根本就无法组成2元，钱找不开的情况下默认返回-1。暴力递归的方法 12345678910111213141516171819202122232425262728293031 // public static int minCoins (int[] arr,int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return -1; &#125; return process(arr,0,aim);&#125; //当前考虑的是面值i，还剩rest的钱需要找零 //如果返回-1，说明使用arr[i..N-1]面值的情况下，无论如何也无法找零rest //如果返回不是-1，代表自由使用arr[i..N-1]面值的情况下，找零rest需要的最少张数public static int process (int[] arr,int i,int rest) &#123; //base case //已经没有面值能够考虑了 //如果此时剩余的钱为0，返回0张 //如果此时剩余的钱不是0，返回-1 if (i == arr.length) &#123; return rest == 0 ? 0 : -1; &#125; //最少张数，初始值为-1，还没找到有效解 int res = -1; //依次尝试使用当前的面值(arr[i])0张、1张、k张，但不能超过rest for (int k = 0;k * arr[i] &lt;= rest;k++) &#123; //使用了k张arr[i]，剩余的钱为rest - k * arr[i] //交给剩下的面值去搞定(arr[i+1...N-1]) int next = process(arr,i + 1,rest - k * arr[i]); if (next != -1) &#123;//说明后续过程有效 res = res == -1 ? next + k : Math.min(res, next + k); &#125; &#125; return res;&#125; 动态规划的方法 12345678910111213141516171819202122232425262728 public static int minCoins2 (int[] arr,int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return -1; &#125; int N = arr.length; int[][] dp = new int[N + 1][aim + 1]; //设置最后一排的值，除dp[N][0]为0外，其余都是-1 for (int col = 1;col &lt;= aim;col++) &#123; dp[N][col] = -1; &#125; for (int i = N - 1;i &gt;= 0;i++) &#123;//从底往上计算每一行 for (int rest = 0;rest &lt;= aim;rest++) &#123;//每一行都从左往右 dp[i][rest] = -1;//初始时先设置dp[i][rest]的值无效 if (dp[i + 1][rest] != -1) &#123;//下面的值如果有效 dp[i][rest] = dp[i + 1][rest];//先设置成下面的值 &#125; //如果左边的位置不越界且有效 if (rest - arr[i] &gt;= 0 &amp;&amp; dp[i][rest] - arr[i] != -1) &#123; if (dp[i][rest] == -1) &#123;//如果之前下面的值无效 dp[i][rest] = dp[i][rest - arr[i]] + 1; &#125; else &#123;//说明下面和左边的值都有效，取最小的 dp[i][rest] = Math.min(dp[i][rest], dp[i][rest - arr[i]] + 1); &#125; &#125; &#125; &#125; return dp[0][aim];&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人达到指定位置方法数]]></title>
    <url>%2F2019%2F04%2F23%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BE%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E6%95%B0%2F</url>
    <content type="text"><![CDATA[机器人达到指定位置方法数问题概述：动态规划的题目，假设有N个位置，N大于等于2。开始机器人在其中的某个位置(M位置,M一定是1到N的某一个),机器人可以往左走或往右走，在位置1则只能往右走到位置2，同理在位置N只能往左走到N-1位置。在除了这两个位置的其它位置则可以往左或往右；规定机器人走K步，最终能来到P位置(P也是1到N位置中的一个)的方法有多少种，给定四个参数N、M、K、P，返回方法数。 暴力递归的方法分析：各个参数的意义： N：位置1 ~ N，是固定参数cur：当前位置cur，可变参数rest：还剩rest步没走，可变参数P：最终的目标位置，固定参数 walk方法： 12345678910111213141516public static int walk (int N,int cur,int rest,int p) &#123; //剩余步数为0，当前位置就是最后的位置，看是否是位置P，是就找到一种方法返回1，否则就说明这种方法到不了///目标位置返回0 if (rest == 0) &#123; return cur == p ? 1 : 0; &#125; //在1位置，只能向右走，所以来到2位置 if (cur == 1) &#123; return walk(N,2,rest - 1,p); &#125; //在N位置，那么下一步只能向左走，所以来到N - 1位置 if (cur == N) &#123; return walk(N, N - 1, rest - 1, p); &#125; //在1和N位置外的其它位置，可以向右向左，要算上它们各自的方法总和 return walk(N,cur + 1,rest - 1, p) + walk(N,cur - 1,rest - 1, p);&#125; 主方法： 123456public static int ways1 (int N,int M,int K,int P) &#123; if (N &lt; 2 || K&lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123; return 0; &#125; return walk(N,M,K,P);&#125; 可以在mian方法里这样调用： 123int N = 6,M = 1,K = 8,P = 3;//返回28，说明有28种方法System.out.println(ways1(N,M,K,P)); 动态规划的方法时间复杂度:O(N * K)从暴力递归的方法来优化成动态规划，在这个过程中，一旦写出了尝试函数，后续的优化过程都是很固定的。这个例子中，首先根据walk方法的含义结合题意，分析整个过程是不是无后效性的。利用尝试方法去解决的问题，绝大多数都是无后效性的，有后效性的递归过程在面试过程中极其少见。所谓无后效性，就是指一个递归状态的返回值与怎么达到这个状态的路径无关。 本题中的walk函数N、P，任何时候都不变，说明N、P与具体的递归状态无关，忽略他们。只需要关注cur和rest两个参数，也就是当前来到的位置和剩余的步数。walk(cur,rest)的含义是：当前来到cur位置，还剩下rest位置可以走，那么有多少种方法走到目标P位置。例如walk(5,7)，代表来到5位置，还可以走7步，最终到达P有多少种方式，如下图画出了求出walk(5,7)状态的依赖树：上图walk(5,5)状态出现了两次，含义是当前来到5位置，还剩5步，有效方法有多少种。那么最终的返回值与怎么到达这个状态的路径有关系吗？没有。不管是从walk(4,6)来到walk(5,5)还是从walk(6,6)来到walk(5,5),只要是”当前来到5位置，还剩5步”这个问题，返回值都是不变的，这就是一个无后效性问题。一旦问题经论证是无后效性的就可以按一下步骤进行优化成动态规划： 1，找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了 2，把可变参数的所有组合映射成一张表，有1个可变参数就是1维表，2个就是二维表，依此类推 3，最终答案要的是表中的哪个位置，在表中标出 4，根据递归过程的base case，把这张表最简单、不需要依赖其他位置的那些位置填好值 5，根据递归过程非base case的部分，也就是分析表中的普遍位置需要怎么计算得到，那么这张表的填写顺序也就确定了 6，填好表，返回最终答案填在表中位置的值 接下来我们以N = 7，M = 4，K = 9，P = 5 为例来走一下这个过程。过程： 1，walk函数中，可变参数cur和rest一旦确定，返回值就确定了 2，有cur和rest两个可变参数，所以是一个二维表。 3,N = 7,M = 4,K = 9, P = 5的最终答案，就是dp[9][4]的值 4，递归过程的base case是指问题规模小到什么程度，就不需要再划分子问题，答案就可以直接得到了。walk函数的base case如下： 1if (rest == 0) &#123; return cur == P ? 1 : 0 &#125;。 当rest = 0，cur = pP，返回1，否则返回0，本例中P = 5，所以可以把表中的第一行填好，表中的第一行所有状态都是最简单且不需要依赖其他位置的。 5，base case之外的位置，在walk函数如下： 1234567 if (cur == 1) &#123; return walk(N,2,rest - 1,p);&#125;if (cur == N) &#123; return walk(N, N - 1, rest - 1, p);&#125; return walk(N,cur + 1,rest - 1, p) + walk(N,cur - 1,rest - 1, p); 若cur在1位置，最终返回dp[rest][cur] = dp[rest - 1][2],若在N位置，最终返回值dp[rest][cur] = dp[rest - 1][N - 1],若cur在中间位置，dp[rest][cur] = dp[rest - 1][cur - 1] + dp[rest - 1][cur + 1]。说明每一行的值都仅仅依赖上一行的值，那么有了上一行的值，就可以推出整张表整张表的值如下所示。 6,返回dp[9][4]，结果为116 动态规划方法实现代码： 12345678910111213141516171819 public static int ways2 (int N,int M,int K,int P) &#123; if (N &lt; 2 || K &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123; return 0; &#125; int[][] dp = new int[K + 1][1 + N]; dp[0][P] = 1; for (int i = 1;i &lt;= K;i++) &#123; for (int j = 1;j &lt;= N;j++) &#123; if (j == 1) &#123; dp[i][j] = dp[i - 1][2]; &#125; else if (j == N) &#123; dp[i][j] = dp[i - 1][N - 1]; &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; &#125; &#125; &#125; return dp[K][M];&#125; 动态规划+空间压缩的方法与最短路径和的空间压缩技巧一样，这就是动态规划 + 空间压缩的方法。代码如下： 1234567891011121314151617181920212223 public static int ways3 (int N,int M,int K,int P) &#123; if (N &lt; 2 || K &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N) &#123; return 0; &#125; int[] dp = new int[N + 1]; dp[P] = 1; for(int i = 1;i &lt;= K;i++) &#123; int leftUp = dp[1]; for (int j = 1;j &lt;= N;j++) &#123; int tmp = dp[j]; if (j == 1) &#123; dp[j] = dp[j +1]; &#125; else if (j == N) &#123; dp[j] = leftUp; &#125; else &#123; dp[j] = leftUp + dp[j + 1]; &#125; leftUp = tmp; &#125; &#125; return dp[M];&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态归化以及空间压缩]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%8A%A8%E6%80%81%E5%BD%92%E5%8C%96%E4%BB%A5%E5%8F%8A%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9(%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C)%2F</url>
    <content type="text"><![CDATA[动态规划类算法题动态规划相关以及动态规划的空间压缩方法。 1,矩阵的最小路径和一个矩阵n，从左上角到右下角，路径上所有的数字累加起来就是路径和，返回左右路径和中最小的值。例如，给定一个矩阵，n[0] = {1,3,5,9},n[1] = {8,1,3,4},n[2] = {5,0,6,1},n[3] = {8,8,4,0},路径1,3,1,0,6,1,0是最小的路径和所以返回12，如下所示。 12341 3 5 98 1 3 45 0 6 1 8 8 4 0 经典动态规划的解法解答：这是经典的动态规划算法，假设矩阵N大小为m*n，先生成大小和N一样的矩阵dp，dp[i][j]就是表示从左上角(0,0)位置走到(i,j)位置的最小路径和。对N的第一行位置来说，(0,j)(0 &lt;= j &lt; n)，从(0,0)位置走到(0,j)位置只能向右走，所以从(0,0)位置到(0,j)的路径和就是N[0][0…j]这些值得累加结果。同理对于N的每一列来说，即(i,0)(0 &lt;= i &lt; m),从(0,0)位置到(i,0)位置的路径和就是N[0…i][0]相加。 12341 4 9 1891422 可以发现除了第一行和第一列的位置外其它所有的位置(i,j)都有左边位置(i,j-1)和上面位置(i-1,j),从(0,0)到(i,j)的路径必经过位置(i,j)和位置(i-1,j)，所以dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + N[i][j]。最终生成的dp矩阵如下： 12341 4 9 189 5 8 12 14 5 11 1222 13 15 12 具体代码如下： 123456789101112131415161718192021222324public static int minPath (int[][] m) &#123; if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123; return 0; &#125; int row = m.length; int column = m[0].length; int[][] dp = new int[row][column]; dp[0][0] = m[0][0]; for (int i=1;i&lt;row;i++) &#123; dp[i][0] = dp[i-1][0] + m[i][0]; &#125; for (int i=1;i&lt;column;i++) &#123; dp[0][i] = dp[0][i-1] + m[0][i]; &#125; for (int i =1;i &lt; row;i++) &#123; for (int j = 1;j &lt; column;j++) &#123; dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + m[i][j]; &#125; &#125; return dp[row - 1][column - 1];&#125; 上面代码的时间复杂度为O(m * n)，dp矩阵的大小为m * n，所以额外空间复杂度为O(m * n)。 动态规划 + 空间压缩的方法经过空间压缩后的方法时间复杂度仍然是O(m * n)，但是额外空间复杂度会减小至O(min(m,n))，也就是不使用大小为m * n的矩阵，而仅仅使用大小为min(m,n)的数组，具体过程如下： 1，生成长度为min(m,n)(也就是行数和列数较小的那个值，在这个例子为4)的数组arr,初始值为arr=[0,0,0,0]，从(0,0)位置到达m中第一行的每一个位置，最小路径就是从(0,0)位置开始累加的结果，所以依次把arr设置为arr=[1,4,9,18]，此时arr[j]的值代表从(0,0)位置到(0,j)位置的最小路径和。 2，步骤1是代表的是从(0,0)到(0,j)的最小路径和，现在想把arr[j]的值更新从(0,0)到(1,j)位置的最小路径和。可知对于arr[0]来说，令arr[0] = arr[0] + m[1,0] = 9,即从(0,0)到(1,0)的最小路径和。至于(1,1)位置，此时有两种路径，从(1,0)到(1,1)、从(0,1)到(1,1)，arr[1] = min(arr[0],arr[1]) + m[1][1]，更新后arr[1]就成为dp[1][1]的值。同理arr[2] = min(arr[1],arr[2]) + m[1][2]，依次类推，最终arr可以更新成[9,5,8,12]。 3，重复步骤2，一直到arr彻底变成dp矩阵的最后一行，整个过程其实就是不听滚动更新arr数组，让arr依次变成dp矩阵每一行的值，最终变成最后一行的值。如果矩阵的列数小于行数(M&gt;N)，依然可以用上面的方法更新成dp矩阵每一行的值。但如果给定的列数大于行数(M&lt;N),那么就生成长度为M的arr，然后更新成dp矩阵的每一列值，从左到右滚动过去。代码如下：1234567891011121314151617181920212223public static int minPath2(int[][] m) &#123; if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123; return 0; &#125; int more = Math.max(m.length, m[0].length);//行数与列数较大的那个为more int less = Math.min(m.length, m[0].length);//行数与列数较小的那个为less boolean rowmore = more == m.length;//行数是不是大于或等于列数 int[] arr = new int[less]; arr[0] = m[0][0]; for (int i = 1;i &lt; less;i++) &#123; arr[i] = arr[i - 1] + (rowmore ? m[0][i] : m[i][0]); &#125; for (int i = 1;i &lt; more;i++) &#123; arr[0] = arr[0] + (rowmore ? m[i][0] : m[0][i]); for (int j = 1;j &lt; less;j++) &#123; arr[j] = Math.min(arr[j - 1], arr[j]) + (rowmore ? m[i][j] : m[j][i]); &#125; &#125; return arr[less - 1];&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态归化以及空间压缩]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%8A%A8%E6%80%81%E5%BD%92%E5%8C%96%E4%BB%A5%E5%8F%8A%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[动态规划类算法题动态规划相关以及动态规划的空间压缩方法。 1,矩阵的最小路径和一个矩阵n，从左上角到右下角，路径上所有的数字累加起来就是路径和，返回左右路径和中最小的值。例如，给定一个矩阵，n[0] = {1,3,5,9},n[1] = {8,1,3,4},n[2] = {5,0,6,1},n[3] = {8,8,4,0},路径1,3,1,0,6,1,0是最小的路径和所以返回12，如下所示。 12341 3 5 98 1 3 45 0 6 1 8 8 4 0 经典动态规划的解法解答：这是经典的动态规划算法，假设矩阵N大小为m*n，先生成大小和N一样的矩阵dp，dp[i][j]就是表示从左上角(0,0)位置走到(i,j)位置的最小路径和。对N的第一行位置来说，(0,j)(0 &lt;= j &lt; n)，从(0,0)位置走到(0,j)位置只能向右走，所以从(0,0)位置到(0,j)的路径和就是N[0][0…j]这些值得累加结果。同理对于N的每一列来说，即(i,0)(0 &lt;= i &lt; m),从(0,0)位置到(i,0)位置的路径和就是N[0…i][0]相加。 12341 4 9 1891422 可以发现除了第一行和第一列的位置外其它所有的位置(i,j)都有左边位置(i,j-1)和上面位置(i-1,j),从(0,0)到(i,j)的路径必经过位置(i,j)和位置(i-1,j)，所以dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + N[i][j]。最终生成的dp矩阵如下： 12341 4 9 189 5 8 12 14 5 11 1222 13 15 12 具体代码如下： 123456789101112131415161718192021222324public static int minPath (int[][] m) &#123; if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123; return 0; &#125; int row = m.length; int column = m[0].length; int[][] dp = new int[row][column]; dp[0][0] = m[0][0]; for (int i=1;i&lt;row;i++) &#123; dp[i][0] = dp[i-1][0] + m[i][0]; &#125; for (int i=1;i&lt;column;i++) &#123; dp[0][i] = dp[0][i-1] + m[0][i]; &#125; for (int i =1;i &lt; row;i++) &#123; for (int j = 1;j &lt; column;j++) &#123; dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + m[i][j]; &#125; &#125; return dp[row - 1][column - 1];&#125; 上面代码的时间复杂度为O(m * n)，dp矩阵的大小为m * n，所以额外空间复杂度为O(m * n)。 动态规划 + 空间压缩的方法经过空间压缩后的方法时间复杂度仍然是O(m * n)，但是额外空间复杂度会减小至O(min(m,n))，也就是不使用大小为m * n的矩阵，而仅仅使用大小为min(m,n)的数组，具体过程如下： 1，生成长度为min(m,n)(也就是行数和列数较小的那个值，在这个例子为4)的数组arr,初始值为arr=[0,0,0,0]，从(0,0)位置到达m中第一行的每一个位置，最小路径就是从(0,0)位置开始累加的结果，所以依次把arr设置为arr=[1,4,9,18]，此时arr[j]的值代表从(0,0)位置到(0,j)位置的最小路径和。 2，步骤1是代表的是从(0,0)到(0,j)的最小路径和，现在想把arr[j]的值更新从(0,0)到(1,j)位置的最小路径和。可知对于arr[0]来说，令arr[0] = arr[0] + m[1,0] = 9,即从(0,0)到(1,0)的最小路径和。至于(1,1)位置，此时有两种路径，从(1,0)到(1,1)、从(0,1)到(1,1)，arr[1] = min(arr[0],arr[1]) + m[1][1]，更新后arr[1]就成为dp[1][1]的值。同理arr[2] = min(arr[1],arr[2]) + m[1][2]，依次类推，最终arr可以更新成[9,5,8,12]。 3，重复步骤2，一直到arr彻底变成dp矩阵的最后一行，整个过程其实就是不听滚动更新arr数组，让arr依次变成dp矩阵每一行的值，最终变成最后一行的值。如果矩阵的列数小于行数(M&gt;N)，依然可以用上面的方法更新成dp矩阵每一行的值。但如果给定的列数大于行数(M&lt;N),那么就生成长度为M的arr，然后更新成dp矩阵的每一列值，从左到右滚动过去。代码如下：1234567891011121314151617181920212223public static int minPath2(int[][] m) &#123; if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) &#123; return 0; &#125; int more = Math.max(m.length, m[0].length);//行数与列数较大的那个为more int less = Math.min(m.length, m[0].length);//行数与列数较小的那个为less boolean rowmore = more == m.length;//行数是不是大于或等于列数 int[] arr = new int[less]; arr[0] = m[0][0]; for (int i = 1;i &lt; less;i++) &#123; arr[i] = arr[i - 1] + (rowmore ? m[0][i] : m[i][0]); &#125; for (int i = 1;i &lt; more;i++) &#123; arr[0] = arr[0] + (rowmore ? m[i][0] : m[0][i]); for (int j = 1;j &lt; less;j++) &#123; arr[j] = Math.min(arr[j - 1], arr[j]) + (rowmore ? m[i][j] : m[j][i]); &#125; &#125; return arr[less - 1];&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Morris遍历]]></title>
    <url>%2F2019%2F04%2F20%2FMorris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Morris遍历是一种时间复杂度O(n)的二叉树遍历。 Morris遍历与递归版本的二叉树遍历的关系(或者相似之处)，如果一个节点有左子树那么Morris遍历可以回到左子树两次(递归方法是3次)，Morris模拟了递归的过程。对于没有左子树的节点只会到达依一次。Morris遍历(先序)的代码： 123456789101112131415161718192021222324252627 public static void morrisPre(Node head) &#123; if (head == null) &#123; return; &#125; Node cur1 = head; Node cur2 = null; while (cur1 != null) &#123; cur2 = cur1.left; if (cur2 != null) &#123; while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123; cur2 = cur2.right; &#125; if (cur2.right == null) &#123; cur2.right = cur1; System.out.print(cur1.value + &quot; &quot;); cur1 = cur1.left; continue; &#125; else &#123; cur2.right = null; &#125; &#125; else &#123; System.out.print(cur1.value + &quot; &quot;); &#125; cur1 = cur1.right; &#125; System.out.println();&#125; Morris遍历(中序)的代码： 12345678910111213141516171819202122232425 public static void morrisIn(Node head) &#123; if (head == null) &#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null) &#123; mostRight = cur.left; if (mostRight != null) &#123; while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123; mostRight = mostRight.right; &#125; if (mostRight.right == null) &#123; mostRight.right = cur; cur = cur.left; continue; &#125; else &#123; mostRight.right = null; &#125; &#125; System.out.print(cur.value + &quot; &quot;); cur = cur.right; &#125; System.out.println();&#125; 注：后序遍历有点麻烦，因为Morris遍历最多只能回到一个节点两次并不会回到第三次。采用下面的方法打印后序遍历：所有会回到两次的节点，在它第二次回到的时候逆序打印它的左子树右边界，打印完后，单独打印整棵树的右边界，这就后序遍历。只关注能来到两次的节点。Morris遍历(后序)的代码： 123456789101112131415161718192021222324252627282930313233343536 public static void morrisPos(Node head) &#123; if (head == null) &#123; return; &#125; Node cur1 = head; Node cur2 = null; while (cur1 != null) &#123; cur2 = cur1.left; if (cur2 != null) &#123; while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123; cur2 = cur2.right; &#125; if (cur2.right == null) &#123; cur2.right = cur1; cur1 = cur1.left; continue; &#125; else &#123; cur2.right = null; printEdge(cur1.left); &#125; &#125; cur1 = cur1.right; &#125; printEdge(head); System.out.println();&#125; public static void printEdge(Node head) &#123; Node tail = reverseEdge(head); Node cur = tail; while (cur != null) &#123; System.out.print(cur.value + &quot; &quot;); cur = cur.right; &#125; reverseEdge(tail);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler消息机制]]></title>
    <url>%2F2019%2F04%2F17%2FHandler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Handler消息机制 消息机制的工作原理消息队列在安卓中指的是MessageQueue，MessageQueue主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取的方法分别是enqueueMessage和next，enqueueMessage往消息队列中插入一条消息，next是从消息队列中取出一条消息并把它从消息队列中移除。MessageQueue叫消息队列，但是它的内部数据结构并不是用的队列，而是用一个单链表维护消息列表，单链表在插入和删除上比较有优势，下面看看enqueueMessage和next的实现。enqueueMessage远吗： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; // synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; enqueueMessage的功能是实现单链表的插入操作。next方法源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; //无限循环 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); // synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; next是一个无限循环方法，如果消息队列没有消息，next方法就会一直阻塞，当有新的消息到来时，next方法会返回这条消息并把它从列表中删除。 Looper的工作原理Looper会不停从消息队列中查看是否有新的消息，如果有新的消息就会立刻处理，否则就一直阻塞在那里。Looper的构造方法。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 构造方法里创建了一个MessageQueue消息队列，然后将当前线程的对象保存起来。Handler需要Looper，没有Looper就会抛出异常，如何为线程创建一个Looper呢，用Looper.prepare()方法，紧接着Looper.loop()方法开启消息循环。 12345678new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); handler.sendMessage(message); Looper.loop(); &#125;&#125;).start(); Looper还提供了prepareMainLooper方法，它主要是给主线程也就是ActivityThread创建Looper的，其本质也是通过prepare()方法来实现的。还有一点注意：Looper提供了一个getMainLooper方法，通过它可以在子线程中获取到主线程的Looper。Looper也是可以退出的，quit和quitAafely来退出任何一个Looper，二者的区别是：quit会直接退出Looper，quitSafely只是设定一个退出标记，然后把消息队列中已有的消息处理完才安全退出。Looper退出后，再通过Handler发送消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper。那么在所有的消息处理完后应该调用quit方法来终止消息循环，否则这个子线程会一直处于等待的状态，而Looper退出以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。Looper的loop方法，这是Looper最重要的一个方法。只有调用了loop方法消息循环系统才会真正起作用，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos; final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); boolean slowDeliveryDetected = false; for (;;) &#123; Message msg = queue.next(); // might block //唯一跳出死循环的情况 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (slowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); slowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot;· + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; loop方法就是一个死循环，唯一跳出死循环的情况就是当next返回了null。next是一个阻塞操作，没有消息时，next方法会一直阻塞，如果next返回了新消息，Looper就会处理这条消息，msg.target.dispatchMessage()，这里的msg.target是发送这条消息的Handler对象，这样Handler发送的消息又最终交给它的dispatchMessage来处理了。但是这里不同的是Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行的，这样就成功地将代码逻辑切换到指定的线程中去执行了。 Handler的工作原理Handler工作主要包括发送和接收过程，消息的发送可以通过post的一系列方法以及send的一系列方法实现，post方法最终也是通过send的一系列方法来实现的。发送一条消息的代码： 12345678910111213141516171819202122232425262728293031public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 发送消息过程就是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由looper处理，Handler的dispatchMessage方法会调用，这时Handler就进入了处理消息的阶段，dispatchMessage源码： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; Handler处理消息过程如下：首先检查Message的callBack是否为null，不为null就通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。HandleBack逻辑也很简单，代码： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 其次，检查mCallback是否为null，不为bull就调用mCallback的handleMessage方法来处理消息，CallBack是接口，定义如下： 123public interface CallBack &#123; public boolean handleMessage(Message msg);&#125; 通过CallBack可以采用如下方式来创建Handler对象：Handler handler = new Handler(callBack);CallBack的意义是什么呢？可以用来创建一个Handler的实例但并不需要派生Handler的子类。在日常开发中，创建Handler最常见的方式是派生一个Handler子类并重写其handleMessage方法来处理具体的消息，而CallBack给我们提供了另一种使用Handler的方式，当我们不想派生子类时，就可以用CallBack来实现。最后调用Handler的handleMessage方法来处理消息。 handler的默认构造方法 public Handler()，它最终会调用下面的构造方法： 1234567891011121314151617181920public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 可以看到，如果当前线程没有Looper的话，就会抛出 “Can’t create handler inside thread “ +Thread.currentThread() that has not called Looper.prepare()”这个异常，这也解释了在没有Looper的子线程创建Handler会引发程序异常的原因了。 主线程的消息循环Android中的主线程是ActivityThread，入口方法为main()方法，在main方法中会通过Looper.prepareMainLooper()来处理主线程的Looper以及MessageQueue，并通过Looper.loop()来开启主线程的消息循环。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 主线程消息循环开始后，ActivityThread还 需要一个Handler来和消息队列进行交互，这个Handler就是HandlerThread，它内部定义了一组消息类型，主要包含了四大组件的启动和停止过程等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274class H extends Handler &#123; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122; public static final int DUMP_SERVICE = 123; public static final int LOW_MEMORY = 124; public static final int PROFILER_CONTROL = 127; public static final int CREATE_BACKUP_AGENT = 128; public static final int DESTROY_BACKUP_AGENT = 129; public static final int SUICIDE = 130; public static final int REMOVE_PROVIDER = 131; public static final int ENABLE_JIT = 132; public static final int DISPATCH_PACKAGE_BROADCAST = 133; public static final int SCHEDULE_CRASH = 134; public static final int DUMP_HEAP = 135; public static final int DUMP_ACTIVITY = 136; public static final int SLEEPING = 137; public static final int SET_CORE_SETTINGS = 138; public static final int UPDATE_PACKAGE_COMPATIBILITY_INFO = 139; public static final int DUMP_PROVIDER = 141; public static final int UNSTABLE_PROVIDER_DIED = 142; public static final int REQUEST_ASSIST_CONTEXT_EXTRAS = 143; public static final int TRANSLUCENT_CONVERSION_COMPLETE = 144; public static final int INSTALL_PROVIDER = 145; public static final int ON_NEW_ACTIVITY_OPTIONS = 146; public static final int ENTER_ANIMATION_COMPLETE = 149; public static final int START_BINDER_TRACKING = 150; public static final int STOP_BINDER_TRACKING_AND_DUMP = 151; public static final int LOCAL_VOICE_INTERACTION_STARTED = 154; public static final int ATTACH_AGENT = 155; public static final int APPLICATION_INFO_CHANGED = 156; public static final int RUN_ISOLATED_ENTRY_POINT = 158; public static final int EXECUTE_TRANSACTION = 159; public static final int RELAUNCH_ACTIVITY = 160; String codeToString(int code) &#123; if (DEBUG_MESSAGES) &#123; switch (code) &#123; case BIND_APPLICATION: return &quot;BIND_APPLICATION&quot;; case EXIT_APPLICATION: return &quot;EXIT_APPLICATION&quot;; case RECEIVER: return &quot;RECEIVER&quot;; case CREATE_SERVICE: return &quot;CREATE_SERVICE&quot;; case SERVICE_ARGS: return &quot;SERVICE_ARGS&quot;; case STOP_SERVICE: return &quot;STOP_SERVICE&quot;; case CONFIGURATION_CHANGED: return &quot;CONFIGURATION_CHANGED&quot;; case CLEAN_UP_CONTEXT: return &quot;CLEAN_UP_CONTEXT&quot;; case GC_WHEN_IDLE: return &quot;GC_WHEN_IDLE&quot;; case BIND_SERVICE: return &quot;BIND_SERVICE&quot;; case UNBIND_SERVICE: return &quot;UNBIND_SERVICE&quot;; case DUMP_SERVICE: return &quot;DUMP_SERVICE&quot;; case LOW_MEMORY: return &quot;LOW_MEMORY&quot;; case PROFILER_CONTROL: return &quot;PROFILER_CONTROL&quot;; case CREATE_BACKUP_AGENT: return &quot;CREATE_BACKUP_AGENT&quot;; case DESTROY_BACKUP_AGENT: return &quot;DESTROY_BACKUP_AGENT&quot;; case SUICIDE: return &quot;SUICIDE&quot;; case REMOVE_PROVIDER: return &quot;REMOVE_PROVIDER&quot;; case ENABLE_JIT: return &quot;ENABLE_JIT&quot;; case DISPATCH_PACKAGE_BROADCAST: return &quot;DISPATCH_PACKAGE_BROADCAST&quot;; case SCHEDULE_CRASH: return &quot;SCHEDULE_CRASH&quot;; case DUMP_HEAP: return &quot;DUMP_HEAP&quot;; case DUMP_ACTIVITY: return &quot;DUMP_ACTIVITY&quot;; case SLEEPING: return &quot;SLEEPING&quot;; case SET_CORE_SETTINGS: return &quot;SET_CORE_SETTINGS&quot;; case UPDATE_PACKAGE_COMPATIBILITY_INFO: return &quot;UPDATE_PACKAGE_COMPATIBILITY_INFO&quot;; case DUMP_PROVIDER: return &quot;DUMP_PROVIDER&quot;; case UNSTABLE_PROVIDER_DIED: return &quot;UNSTABLE_PROVIDER_DIED&quot;; case REQUEST_ASSIST_CONTEXT_EXTRAS: return &quot;REQUEST_ASSIST_CONTEXT_EXTRAS&quot;; case TRANSLUCENT_CONVERSION_COMPLETE: return &quot;TRANSLUCENT_CONVERSION_COMPLETE&quot;; case INSTALL_PROVIDER: return &quot;INSTALL_PROVIDER&quot;; case ON_NEW_ACTIVITY_OPTIONS: return &quot;ON_NEW_ACTIVITY_OPTIONS&quot;; case ENTER_ANIMATION_COMPLETE: return &quot;ENTER_ANIMATION_COMPLETE&quot;; case LOCAL_VOICE_INTERACTION_STARTED: return &quot;LOCAL_VOICE_INTERACTION_STARTED&quot;; case ATTACH_AGENT: return &quot;ATTACH_AGENT&quot;; case APPLICATION_INFO_CHANGED: return &quot;APPLICATION_INFO_CHANGED&quot;; case RUN_ISOLATED_ENTRY_POINT: return &quot;RUN_ISOLATED_ENTRY_POINT&quot;; case EXECUTE_TRANSACTION: return &quot;EXECUTE_TRANSACTION&quot;; case RELAUNCH_ACTIVITY: return &quot;RELAUNCH_ACTIVITY&quot;; &#125; &#125; return Integer.toString(code); &#125; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case EXIT_APPLICATION: if (mInitialApplication != null) &#123; mInitialApplication.onTerminate(); &#125; Looper.myLooper().quit(); break; case RECEIVER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastReceiveComp&quot;); handleReceiver((ReceiverData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceCreate: &quot; + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UNBIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceUnbind&quot;); handleUnbindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SERVICE_ARGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (&quot;serviceStart: &quot; + String.valueOf(msg.obj))); handleServiceArgs((ServiceArgsData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceStop&quot;); handleStopService((IBinder)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CONFIGURATION_CHANGED: handleConfigurationChanged((Configuration) msg.obj); break; case CLEAN_UP_CONTEXT: ContextCleanupInfo cci = (ContextCleanupInfo)msg.obj; cci.context.performFinalCleanup(cci.who, cci.what); break; case GC_WHEN_IDLE: scheduleGcIdler(); break; case DUMP_SERVICE: handleDumpService((DumpComponentInfo)msg.obj); break; case LOW_MEMORY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;lowMemory&quot;); handleLowMemory(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PROFILER_CONTROL: handleProfilerControl(msg.arg1 != 0, (ProfilerInfo)msg.obj, msg.arg2); break; case CREATE_BACKUP_AGENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;backupCreateAgent&quot;); handleCreateBackupAgent((CreateBackupAgentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case DESTROY_BACKUP_AGENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;backupDestroyAgent&quot;); handleDestroyBackupAgent((CreateBackupAgentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SUICIDE: Process.killProcess(Process.myPid()); break; case REMOVE_PROVIDER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;providerRemove&quot;); completeRemoveProvider((ProviderRefCount)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case ENABLE_JIT: ensureJitEnabled(); break; case DISPATCH_PACKAGE_BROADCAST: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;broadcastPackage&quot;); handleDispatchPackageBroadcast(msg.arg1, (String[])msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SCHEDULE_CRASH: throw new RemoteServiceException((String)msg.obj); case DUMP_HEAP: handleDumpHeap((DumpHeapData) msg.obj); break; case DUMP_ACTIVITY: handleDumpActivity((DumpComponentInfo)msg.obj); break; case DUMP_PROVIDER: handleDumpProvider((DumpComponentInfo)msg.obj); break; case SLEEPING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;sleeping&quot;); handleSleeping((IBinder)msg.obj, msg.arg1 != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SET_CORE_SETTINGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;setCoreSettings&quot;); handleSetCoreSettings((Bundle) msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UPDATE_PACKAGE_COMPATIBILITY_INFO: handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData)msg.obj); break; case UNSTABLE_PROVIDER_DIED: handleUnstableProviderDied((IBinder)msg.obj, false); break; case REQUEST_ASSIST_CONTEXT_EXTRAS: handleRequestAssistContextExtras((RequestAssistContextExtras)msg.obj); break; case TRANSLUCENT_CONVERSION_COMPLETE: handleTranslucentConversionComplete((IBinder)msg.obj, msg.arg1 == 1); break; case INSTALL_PROVIDER: handleInstallProvider((ProviderInfo) msg.obj); break; case ON_NEW_ACTIVITY_OPTIONS: Pair&lt;IBinder, ActivityOptions&gt; pair = (Pair&lt;IBinder, ActivityOptions&gt;) msg.obj; onNewActivityOptions(pair.first, pair.second); break; case ENTER_ANIMATION_COMPLETE: handleEnterAnimationComplete((IBinder) msg.obj); break; case START_BINDER_TRACKING: handleStartBinderTracking(); break; case STOP_BINDER_TRACKING_AND_DUMP: handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj); break; case LOCAL_VOICE_INTERACTION_STARTED: handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2); break; case ATTACH_AGENT: &#123; Application app = getApplication(); handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null); break; &#125; case APPLICATION_INFO_CHANGED: mUpdatingSystemConfig = true; try &#123; handleApplicationInfoChanged((ApplicationInfo) msg.obj); &#125; finally &#123; mUpdatingSystemConfig = false; &#125; break; case RUN_ISOLATED_ENTRY_POINT: handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2); break; case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); if (isSystem()) &#123; // Client transactions inside system process are recycled on the client side // instead of ClientLifecycleManager to avoid being cleared before this // message is handled. transaction.recycle(); &#125; // TODO(lifecycler): Recycle locally scheduled transactions. break; case RELAUNCH_ACTIVITY: handleRelaunchActivityLocally((IBinder) msg.obj); break; &#125; Object obj = msg.obj; if (obj instanceof SomeArgs) &#123; ((SomeArgs) obj).recycle(); &#125; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what)); &#125; &#125;]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折纸问题]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[折纸问题，也就是一张纸由下往上对折，它会有一条痕迹，铺开这张纸，痕迹是往下凸的。现在的问题是我们不止折一次，而是折几次，每次都是按照一样的规则，从下往上对折，对折n次，最后铺开纸张，就会有很多条折痕，从上往下依次的折痕方向是怎么样的？用”up”表示向上，”down”表示向下。 代码如下所示： 123456789101112public static void printAllFolds(int N) &#123; printProcess(1, N, true);&#125;public static void printProcess(int i, int N, boolean down) &#123; if (i &gt; N) &#123; return; &#125; printProcess(i + 1, N, true); System.out.println(down ? &quot;down &quot; : &quot;up &quot;); printProcess(i + 1, N, false);&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求完全二叉树的节点个数]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%B1%82%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[求完全二叉树的节点个数。完全二叉树要么是满二叉树(满二叉树：节点个数为2^n - 1个)要么最后一层的节点都是从左往右都是齐全的。 用递归的方法来解决问题： 123456789public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125;&#125; 主代码： 12345678910111213141516171819202122232425public static int nodeNum(Node head) &#123; if (head == null) &#123; return 0; &#125; return bs(head, 1, mostLeftLevel(head, 1));&#125;public static int bs(Node node, int l, int h) &#123; if (l == h) &#123; return 1; &#125; if (mostLeftLevel(node.right, l + 1) == h) &#123; return (1 &lt;&lt; (h - l)) + bs(node.right, l + 1, h); &#125; else &#123; return (1 &lt;&lt; (h - l - 1)) + bs(node.left, l + 1, h); &#125;&#125;public static int mostLeftLevel(Node node, int level) &#123; while (node != null) &#123; level++; node = node.left; &#125; return level - 1;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断是否是二叉搜索树]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[判断一棵树是否是二叉搜索树。 二叉搜索树：二叉树的一个节点的值都比它的左子树的所有节点的值都大，它的右子树的所有节点的值都比它大，它的子树也满足这些条件。 123456789101112131415161718192021222324252627282930public static boolean isBST(Node head) &#123; if (head == null) &#123; return true; &#125; boolean res = true; Node pre = null; Node cur1 = head; Node cur2 = null; while (cur1 != null) &#123; cur2 = cur1.left; if (cur2 != null) &#123; while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123; cur2 = cur2.right; &#125; if (cur2.right == null) &#123; cur2.right = cur1; cur1 = cur1.left; continue; &#125; else &#123; cur2.right = null; &#125; &#125; if (pre != null &amp;&amp; pre.value &gt; cur1.value) &#123; res = false; &#125; pre = cur1; cur1 = cur1.right; &#125; return res;&#125; 完全二叉树：定义：一个节点的左右孩子有以下四种情况： 1，左右双全 2，有左没右 3，没左有右 4，左右都没有如果情况3，则直接返回false。如果是1、4情况，则后面的所有节点都是叶节点才是完全二叉树，否则返回false。 123456789101112131415161718192021222324252627public static boolean isCBT(Node head) &#123; if (head == null) &#123; return true; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); boolean leaf = false; Node l = null; Node r = null; queue.offer(head); while (!queue.isEmpty()) &#123; head = queue.poll(); l = head.left; r = head.right; if ((leaf &amp;&amp; (l != null || r != null)) || (l == null &amp;&amp; r != null)) &#123; return false; &#125; if (l != null) &#123; queue.offer(l); &#125; if (r != null) &#123; queue.offer(r); &#125; else &#123; leaf = true; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归及非递归遍历二叉树]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的遍历(递归及非递归方式)二叉树的先序、中序、后序遍历，递归以及非递归方式。 1,递归方式的先序、中序、后序如下代码所示，是递归的方式，区别就是打印输出的时机，分别对应着先序、中序、后序。 123456789101112131415161718192021222324252627282930313233343536 public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125;&#125;public static void preOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; System.out.print(head.value + &quot; &quot;); preOrderRecur(head.left); preOrderRecur(head.right);&#125;public static void inOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; inOrderRecur(head.left); System.out.print(head.value + &quot; &quot;); inOrderRecur(head.right);&#125;public static void posOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; posOrderRecur(head.left); posOrderRecur(head.right); System.out.print(head.value + &quot; &quot;);&#125; 2，非递归方式先序遍历： 123456789101112131415161718192021222324 public static void preOrderUnRecur(Node head) &#123; System.out.print(&quot;pre-order: &quot;); if (head != null) &#123; //new一个栈 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); //把头结点压栈 stack.add(head); //循环，当栈不为空的时 while (!stack.isEmpty()) &#123; //弹出头结点并打印 head = stack.pop(); System.out.print(head.value + &quot; &quot;); //这是主要的处理逻辑，当右孩子不为空时，右孩子压栈，即&quot;有右先压右&quot; if (head.right != null) &#123; stack.push(head.right); &#125; //当左孩子不为空时左孩子压栈，这一步在右孩子压栈之后，即&quot;有左后压左&quot; if (head.left != null) &#123; stack.push(head.left); &#125; &#125; &#125; System.out.println();&#125; 中序遍历： 1234567891011121314151617181920212223 public static void inOrderUnRecur(Node head) &#123; System.out.print(&quot;in-order: &quot;); if (head != null) &#123; //new一个栈 Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); //当栈不为空或者二叉树不为空 while (!stack.isEmpty() || head != null) &#123; //左孩子存在，那就一溜把左孩子压栈 if (head != null) &#123; stack.push(head); head = head.left; &#125; else &#123; //从栈中弹出一个结点并打印 head = stack.pop(); System.out.print(head.value + &quot; &quot;); head = head.right; &#125; &#125; &#125; System.out.println();&#125; 后序遍历： 1234567891011121314151617181920212223242526272829 public static void posOrderUnRecur1(Node head) &#123; System.out.print(&quot;pos-order: &quot;); if (head != null) &#123; //new两个栈，一个作为辅助使用 Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;(); //s1栈压入头结点 s1.push(head); //s1不为空 while (!s1.isEmpty()) &#123; //弹出s1的结点 head = s1.pop(); //压入s2中 s2.push(head); //左孩子不为空，就把它压入s1栈中 if (head.left != null) &#123; s1.push(head.left); &#125; //右孩子不为空，也把它压入s1栈中 if (head.right != null) &#123; s1.push(head.right); &#125; &#125; while (!s2.isEmpty()) &#123; System.out.print(s2.pop().value + &quot; &quot;); &#125; &#125; System.out.println();&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断二叉树是否是平衡二叉树]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[判断一颗二叉树是否是平衡二叉树平衡二叉树是左右子树的高度差不大于1的树，它的每一个子树都要满足这个条件。递归的方法如下(java)： 代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839 public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125;&#125;public static boolean isBalance(Node head) &#123; boolean[] res = new boolean[1]; res[0] = true; int h = getHeight(head, 1, res); System.out.println(h); return res[0];&#125;public static int getHeight(Node head, int level, boolean[] res) &#123; if (head == null) &#123; return level; &#125; //递归求出左子树的高度 int lH = getHeight(head.left, level + 1, res); if (!res[0]) &#123; return level; &#125; //递归求出右子树的高度 int rH = getHeight(head.right, level + 1, res); if (!res[0]) &#123; return level; &#125; //如果左子树和右子树的高度差大于1，则认为这棵树不是平衡的 if (Math.abs(lH - rH) &gt; 1) &#123; res[0] = false; &#125; //也可以返回树的高度 return Math.max(lH, rH);&#125;]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统下编译Android 9.0系统]]></title>
    <url>%2F2019%2F04%2F03%2FUbuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%BC%96%E8%AF%91Android-9.0%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言在Ubuntu系统下编译Android系统。哎呀不知道是不是换了新电脑的缘故，这次编译居然从安装JDK和配置环境下载源码他喵的一次成功了，想之前真的是那台破电脑一堆问题最后好不容易才成功，不知道是不是跟我这台电脑配置的关系以及内存还有安装ubuntu的时候那几个分区的大小有没有关系。几乎每个分区的大小都是推荐大小的好几倍，尤其是那个交换空间分区不知道是不是。记录一下编译的过程。 安装JDK编译Android系统需要JDK，可以在命令行安装： 1sudo apt install openjdk-8-jdk 没有换源，一次成功，有的时候因为墙的原因可能会安装不了可以换阿里的源。 下载源码下载源码是用的清华的镜像，以下几个步骤： 下载 repo 工具: 1234mkdir ~/binPATH=~/bin:$PATHcurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repochmod a+x ~/bin/repo 建立工作目录: 12mkdir android_9.0_r3cd android_9.0_r3 安装python: 1sudo apt-get install python 初始化仓库： 1repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest 如果需要某个特定的 Android 版本(列表)： 1repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android_9.0_r3 同步源码树（以后只需执行这条命令来同步）： 1repo sync 编译源码在AOSP的根目录，输入如下的命令： 1source build/envsetup.sh 选择编译目标: 1lunch lunch命令是envsetup.sh里定义的一个命令，用来让用户选择编译目标。会有以下信息输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455You&apos;re building on LinuxLunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_mips-eng 4. aosp_mips64-eng 5. aosp_x86-eng 6. aosp_x86_64-eng 7. aosp_car_arm-userdebug 8. aosp_car_arm64-userdebug 9. aosp_car_x86-userdebug 10. aosp_car_x86_64-userdebug 11. mini_emulator_arm64-userdebug 12. m_e_arm-userdebug 13. m_e_mips64-eng 14. m_e_mips-userdebug 15. mini_emulator_x86_64-userdebug 16. mini_emulator_x86-userdebug 17. uml-userdebug 18. aosp_cf_x86_auto-userdebug 19. aosp_cf_x86_phone-userdebug 20. aosp_cf_x86_tablet-userdebug 21. aosp_cf_x86_tablet_3g-userdebug 22. aosp_cf_x86_tv-userdebug 23. aosp_cf_x86_wear-userdebug 24. aosp_cf_x86_64_auto-userdebug 25. aosp_cf_x86_64_phone-userdebug 26. aosp_cf_x86_64_tablet-userdebug 27. aosp_cf_x86_64_tablet_3g-userdebug 28. aosp_cf_x86_64_tv-userdebug 29. aosp_cf_x86_64_wear-userdebug 30. cf_x86_auto-userdebug 31. cf_x86_phone-userdebug 32. cf_x86_tablet-userdebug 33. cf_x86_tablet_3g-userdebug 34. cf_x86_tv-userdebug 35. cf_x86_wear-userdebug 36. cf_x86_64_auto-userdebug 37. cf_x86_64_phone-userdebug 38. cf_x86_64_tablet-userdebug 39. cf_x86_64_tablet_3g-userdebug 40. cf_x86_64_tv-userdebug 41. cf_x86_64_wear-userdebug 42. aosp_marlin-userdebug 43. aosp_marlin_svelte-userdebug 44. aosp_sailfish-userdebug 45. aosp_walleye-userdebug 46. aosp_walleye_test-userdebug 47. aosp_taimen-userdebug 48. hikey-userdebug 49. hikey64_only-userdebug 50. hikey960-userdebugWhich would you like? [aosp_arm-eng] 选择42，按回车。这可以安装到pixel设备(之前的nexus也是)编译的几种不同的类型： user：用来正式发布到市场的版本，权限受限，如没有 root 权限，不能 dedug，adb默认处于停用状态。 userdebug：在user版本的基础上开放了 root 权限和 debug 权限，adb默认处于启用状态。一般用于调试真机。 eng：开发工程师的版本，拥有最大的权限(root等)，具有额外调试工具的开发配置。一般用于模拟器。 开始编译: 1make -j16 编译好后的状态，会有一个out文件夹，因为只有nexus 6p没有pixel手机了，所以没有刷进手机，想来跟nexus刷这些镜像文件没什么大的区别吧。![](/picture/2019-03-15 23-52-10.png) 一个小时两分钟编译好，想之前用笔记本用了半天还不止。。。编译后产生的文件： system.img：系统镜像，里面包含了Android系统主要的目录和文件，通过init.c进行解析并mount挂载到/system目录下。 userdata.img：用户镜像，是Android系统中存放用户数据的，通过init.c进行解析并mount挂载到/data目录下。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide使用及分析]]></title>
    <url>%2F2019%2F04%2F01%2FGlide%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言Glide是Android中使用非常频繁的图片加载框架，在平时开发中使用非常频繁。现在Android的图片加载框架也是非常成熟了，其中Glide应该是非常流行的一个了。 Glide基本用法及介绍添加版本依赖库1234dependencies &#123; implementation &apos;com.github.bumptech.glide:glide:4.9.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.9.0&apos;&#125; 相比于Glide 3，这里要多添加一个compiler的库，这个库是用于生成Generated API的。另外记得添加网络权限： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 加载图片添加完了依赖库后我们就可以使用了，在布局当中加入一个Button和一个ImageView，点击Button然后加载图片到ImageView中。onClick方法的代码如下： 1234public void onClick(View v) &#123; String url = &quot;http://p1.pstatp.com/large/166200019850062839d3&quot;; Glide.with(this).load(url).into(imageView);&#125; Glide.with(this).load(url).into(imageView)就是Glide加载图片的核心代码。 占位图会发现点击”加载图片”按钮之后，要稍微等一会图片才会显示出来，因为从网络上下载图片本来需要时间，不过这样的用户体验就不太好了，我们可以用占位图的方式优化体验，就是在图片加载完成之前先用一张本地图片占住这个位置，不至于屏幕是空白的。先准备好一张loading.jpg图片，放在资源文件夹中。修改onClick方法中加载图片的代码。 123456RequestOptions options = new RequestOptions() .placeholder(R.drawable.loading);Glide.with(this) .load(url) .apply(options) .into(imageView); 这里我们先创建了一个RequestOptions对象，然后调用它的placeholder()方法来指定占位图，再将占位图片的资源id传入到这个方法中。最后，在Glide的三步走之间加入一个apply()方法，来应用我们刚才创建的RequestOptions对象。不过如果你现在重新运行一下代码并点击”加载图片”很可能是根本看不到占位图效果的。因为Glide有非常强大的缓存机制，我们刚才加载图片的时候Glide自动就已经将它缓存下来了，下次加载的时候将会直接从缓存中读取，不会再去网络下载了，因而加载的速度非常快，所以占位图可能根本来不及显示。因此这里我们还需要稍微做一点修改，来让占位图能有机会显示出来，修改代码如下所示： 1234567RequestOptions options = new RequestOptions() .placeholder(R.drawable.loading) .diskCacheStrategy(DiskCacheStrategy.NONE);Glide.with(this) .load(url) .apply(options) .into(imageView); 增加了diskCacheStrategy(DiskCacheStrategy.NONE);这一行代码，diskCacheStrategy方法传入了DiskCacheStrategy.NONE参数，这样就可以禁用掉Glide的缓存功能。当再次点击”加载图片”按钮之后会立即显示一张占位图，然后等真正的图片加载完成之后会将占位图替换掉。 除了这种加载占位图之外，还有一种异常占位图。异常占位图就是指，如果因为某些异常情况导致图片加载失败，比如说手机网络信号不好，这个时候就显示这张异常占位图。准备一张error.jpg图片，然后修改Glide加载部分的代码，如下所示： 12345678RequestOptions options = new RequestOptions() .placeholder(R.drawable.ic_launcher_background) .error(R.drawable.error) .diskCacheStrategy(DiskCacheStrategy.NONE);Glide.with(this) .load(url) .apply(options) .into(imageView); 如上代码所示，这里又串接了一个error()方法就可以指定异常占位图了。 其实看到这里，如果你熟悉Glide 3的话，相信你已经掌握Glide 4的变化规律了。在Glide 3当中，像placeholder()、error()、diskCacheStrategy()等等一系列的API，都是直接串联在Glide三步走方法中使用的。而Glide 4(这里用的是Glide 4.9)中引入了一个RequestOptions对象，将这一系列的API都移动到了RequestOptions当中。这样做的好处是可以使我们摆脱冗长的Glide加载语句，而且还能进行自己的API封装，因为RequestOptions是可以作为参数传入到方法中的。 比如你就可以写出这样的Glide加载工具类： 12345678910111213public class GlideUtil &#123; public static void load(Context context, String url, ImageView imageView, RequestOptions options) &#123; Glide.with(context) .load(url) .apply(options) .into(imageView); &#125;&#125; 这样就会很方便，可以让Glide的加载语句不至于变得冗长。 指定加载的图片大小实际上，使用Glide在大多数情况下我们都是不需要指定图片大小的，因为Glide会自动根据ImageView的大小来决定图片的大小，以此保证图片不会占用过多的内存从而引发OOM。不过，如果你真的有这样的需求，必须给图片指定一个固定的大小，Glide仍然是支持这个功能的。修改Glide加载部分的代码，如下所示： 123456RequestOptions options = new RequestOptions() .override(200, 100);Glide.with(this) .load(url) .apply(options) .into(imageView); 仍然非常简单，这里使用override()方法指定了一个图片的尺寸。也就是说，Glide现在只会将图片加载成200*100像素的尺寸，而不会管你的ImageView的大小是多少了。如果你想加载一张图片的原始尺寸的话，可以使用Target.SIZE_ORIGINAL关键字，如下所示： 123456RequestOptions options = new RequestOptions() .override(Target.SIZE_ORIGINAL);Glide.with(this) .load(url) .apply(options) .into(imageView); 这样的话，Glide就不会再去自动压缩图片，而是会去加载图片的原始尺寸。当然，这种写法也会面临着更高的OOM风险。 缓存机制Glide的缓存设计可以说是非常先进的，考虑的场景也很周全。在缓存这一功能上，Glide又将它分成了两个模块，一个是内存缓存，一个是硬盘缓存。 这两个缓存模块的作用各不相同，内存缓存的主要作用是防止应用重复将图片数据读取到内存当中，而硬盘缓存的主要作用是防止应用重复从网络或其他地方重复下载和读取数据。 内存缓存默认情况下，Glide自动就是开启内存缓存的。也就是说，当我们使用Glide加载了一张图片之后，这张图片就会被缓存到内存当中，只要在它还没从内存中被清除之前，下次使用Glide再加载这张图片都会直接从内存当中读取，而不用重新从网络或硬盘上读取了，这样无疑就可以大幅度提升图片的加载效率。比方说你在一个RecyclerView当中反复上下滑动，RecyclerView中只要是Glide加载过的图片都可以直接从内存当中迅速读取并展示出来，从而大大提升了用户体验。 而Glide最为人性化的是，你甚至不需要编写任何额外的代码就能自动享受到这个极为便利的内存缓存功能，因为Glide默认就已经将它开启了。 那么既然已经默认开启了这个功能，还有什么可讲的用法呢？只有一点，如果你有什么特殊的原因需要禁用内存缓存功能，Glide对此提供了接口，禁用内存缓存： 123456RequestOptions options = new RequestOptions() .skipMemoryCache(true);Glide.with(this) .load(url) .apply(options) .into(imageView); 可以看到，只需要调用skipMemoryCache()方法并传入true，就表示禁用掉Glide的内存缓存功能。 硬盘缓存刚刚学习占位图功能的时候，我们就使用过硬盘缓存的功能了。当时为了禁止Glide对图片进行硬盘缓存而使用了如下代码： 123456RequestOptions options = new RequestOptions() .diskCacheStrategy(DiskCacheStrategy.NONE);Glide.with(this) .load(url) .apply(options) .into(imageView); 调用diskCacheStrategy()方法并传入DiskCacheStrategy.NONE，就可以禁用掉Glide的硬盘缓存功能了。 这个diskCacheStrategy()方法基本上就是Glide硬盘缓存功能的一切，它可以接收五种参数： DiskCacheStrategy.NONE： 表示不缓存任何内容。 DiskCacheStrategy.DATA： 表示只缓存原始图片。 DiskCacheStrategy.RESOURCE： 表示只缓存转换过后的图片。 DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。 DiskCacheStrategy.AUTOMATIC： 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。 其中，DiskCacheStrategy.DATA对应Glide 3中的DiskCacheStrategy.SOURCE，DiskCacheStrategy.RESOURCE对应Glide 3中的DiskCacheStrategy.RESULT。而DiskCacheStrategy.AUTOMATIC是Glide 4中新增的一种缓存策略，并且在不指定diskCacheStrategy的情况下默认使用就是的这种缓存策略。 上面五种参数的解释本身并没有什么难理解的地方，但是关于转换过后的图片这个概念大家可能需要了解一下。就是当我们使用Glide去加载一张图片的时候，Glide默认并不会将原始图片展示出来，而是会对图片进行压缩和转换（我们会在稍后学习这方面的内容）。总之就是经过种种一系列操作之后得到的图片，就叫转换过后的图片。 关于Glide 4硬盘缓存的内容就讲到这里。想要了解更多Glide缓存方面的知识，可以参考 Android图片加载框架最全解析（三），深入探究Glide的缓存机制 这篇文章。 指定加载格式我们都知道，Glide其中一个非常亮眼的功能就是可以加载GIF图片，而同样作为非常出色的图片加载框架的Picasso是不支持这个功能的。 而且使用Glide加载GIF图并不需要编写什么额外的代码，Glide内部会自动判断图片格式。比如我们将加载图片的URL地址改成一张GIF图，如下所示： 123Glide.with(this) .load(&quot;http://guolin.tech/test.gif&quot;) .into(imageView); 也就是说，不管我们传入的是一张普通图片，还是一张GIF图片，Glide都会自动进行判断，并且可以正确地把它解析并展示出来。 但是如果我想指定加载格式该怎么办呢？就比如说，我希望加载的这张图必须是一张静态图片，我不需要Glide自动帮我判断它到底是静图还是GIF图。只需要再串接一个asBitmap()方法就可以了，如下所示： 1234Glide.with(this) .asBitmap() .load(&quot;http://guolin.tech/test.gif&quot;) .into(imageView); asBitmap()方法，这个方法的意思就是说这里只允许加载静态图片，不需要Glide去帮我们自动进行图片格式的判断了。如果你传入的还是一张GIF图的话，Glide会展示这张GIF图的第一帧，而不会去播放它。注意：在Glide 3中的语法是先load()再asBitmap()的，而在Glide 4中是先asBitmap()再load()的，写错了顺序就会报错。 那么类似地，既然我们能强制指定加载静态图片，就也能强制指定加载动态图片，对应的方法是asGif()。而Glide 4中又新增了asFile()方法和asDrawable()方法，分别用于强制指定文件格式的加载和Drawable格式的加载。 回调与监听preload()方法Glide加载图片虽说非常智能，它会自动判断该图片是否已经有缓存了，如果有的话就直接从缓存中读取，没有的话再从网络去下载。但是如果我希望提前对图片进行一个预加载，等真正需要加载图片的时候就直接从缓存中读取，不想再等待慢长的网络加载时间了，这该怎么办呢？ 不用担心，Glide专门给我们提供了预加载的接口，也就是preload()方法，我们只需要直接使用就可以了。 preload()方法有两个方法重载，一个不带参数，表示将会加载图片的原始尺寸，另一个可以通过参数指定加载图片的宽和高。preload()方法的用法也非常简单，直接使用它来替换into()方法即可，如下所示： 123Glide.with(this) .load(&quot;http://guolin.tech/book.png&quot;) .preload(); 注：替换into()方法 调用了预加载之后，我们以后想再去加载这张图片就会非常快了，因为Glide会直接从缓存当中去读取图片并显示出来，代码如下所示： 123Glide.with(this) .load(&quot;http://guolin.tech/book.png&quot;) .into(imageView); submit()方法一直以来，我们使用Glide都是为了将图片显示到界面上。虽然我们知道Glide会在图片的加载过程中对图片进行缓存，但是缓存文件到底是存在哪里的，以及如何去直接访问这些缓存文件？我们都还不知道。 其实Glide将图片加载接口设计成这样也是希望我们使用起来更加的方便，不用过多去考虑底层的实现细节。但如果我现在就是想要去访问图片的缓存文件该怎么办呢？这就需要用到submit()方法了。 submit()方法其实就是对应的Glide 3中的downloadOnly()方法，和preload()方法类似，submit()方法也是可以替换into()方法的，不过submit()方法的用法明显要比preload()方法复杂不少。这个方法只会下载图片，而不会对图片进行加载。当图片下载完成之后，我们可以得到图片的存储路径，以便后续进行操作。 那么首先我们还是先来看下基本用法。submit()方法有两个方法重载： 12submit()submit(int width, int height) 其中submit()方法是用于下载原始尺寸的图片，而submit(int width, int height)则可以指定下载图片的尺寸。 这里就以submit()方法来举例。当调用了submit()方法后会立即返回一个FutureTarget对象，然后Glide会在后台开始下载图片文件。接下来我们调用FutureTarget的get()方法就可以去获取下载好的图片文件了，如果此时图片还没有下载完，那么get()方法就会阻塞住，一直等到图片下载完成才会有值返回。 下面我们通过一个例子来演示一下吧，代码如下所示： 123456789101112131415161718192021222324public void downloadImage() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; String url = &quot;http://www.guolin.tech/book.png&quot;; final Context context = getApplicationContext(); FutureTarget&lt;File&gt; target = Glide.with(context) .asFile() .load(url) .submit(); final File imageFile = target.get(); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(context, imageFile.getPath(), Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125; 这段代码稍微有一点点长，我带着大家解读一下。首先，submit()方法必须要用在子线程当中，因为刚才说了FutureTarget的get()方法是会阻塞线程的，因此这里的第一步就是new了一个Thread。在子线程当中，我们先获取了一个Application Context，这个时候不能再用Activity作为Context了，因为会有Activity销毁了但子线程还没执行完这种可能出现。 接下来就是Glide的基本用法，只不过将into()方法替换成了submit()方法，并且还使用了一个asFile()方法来指定加载格式。submit()方法会返回一个FutureTarget对象，这个时候其实Glide已经开始在后台下载图片了，我们随时都可以调用FutureTarget的get()方法来获取下载的图片文件，只不过如果图片还没下载好线程会暂时阻塞住，等下载完成了才会把图片的File对象返回。 最后，我们使用runOnUiThread()切回到主线程，然后使用Toast将下载好的图片文件路径显示出来。这样我们就能清晰地看出来图片完整的缓存路径是什么了。 listener()方法其实listener()方法的作用非常普遍，它可以用来监听Glide加载图片的状态。举个例子，比如说我们刚才使用了preload()方法来对图片进行预加载，但是我怎样确定预加载有没有完成呢？还有如果Glide加载图片失败了，我该怎样调试错误的原因呢？答案都在listener()方法当中。 下面来看下listener()方法的基本用法吧，不同于刚才几个方法都是要替换into()方法的，listener()是结合into()方法一起使用的，当然也可以结合preload()方法一起使用。最基本的用法如下所示： 1234567891011121314Glide.with(this) .load(&quot;http://www.guolin.tech/book.png&quot;) .listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123; return false; &#125; &#125;) .into(imageView); 这里我们在into()方法之前串接了一个listener()方法，然后实现了一个RequestListener的实例。其中RequestListener需要实现两个方法，一个onResourceReady()方法，一个onLoadFailed()方法。从方法名上就可以看出来了，当图片加载完成的时候就会回调onResourceReady()方法，而当图片加载失败的时候就会回调onLoadFailed()方法，onLoadFailed()方法中会将失败的GlideException参数传进来，这样我们就可以定位具体失败的原因了。 没错，listener()方法就是这么简单。不过还有一点需要处理，onResourceReady()方法和onLoadFailed()方法都有一个布尔值的返回值，返回false就表示这个事件没有被处理，还会继续向下传递，返回true就表示这个事件已经被处理掉了，从而不会再继续向下传递。举个简单点的例子，如果我们在RequestListener的onResourceReady()方法中返回了true，那么就不会再回调Target的onResourceReady()方法了。 图片变换图片变换的意思就是说，Glide从加载了原始图片到最终展示给用户之前，又进行了一些变换处理，从而能够实现一些更加丰富的图片效果，如图片圆角化、圆形化、模糊化等等。 添加图片变换的用法非常简单，我们只需要在RequestOptions中串接transforms()方法，并将想要执行的图片变换操作作为参数传入transforms()方法即可，如下所示： 123456RequestOptions options = new RequestOptions() .transforms(...);Glide.with(this) .load(url) .apply(options) .into(imageView); 至于具体要进行什么样的图片变换操作，这个通常都是需要我们自己来写的。不过Glide已经内置了几种图片变换操作，我们可以直接拿来使用，比如CenterCrop、FitCenter、CircleCrop等。 但所有的内置图片变换操作其实都不需要使用transform()方法，Glide为了方便我们使用直接提供了现成的API： 12345678RequestOptions options = new RequestOptions() .centerCrop();RequestOptions options = new RequestOptions() .fitCenter();RequestOptions options = new RequestOptions() .circleCrop(); 当然，这些内置的图片变换API其实也只是对transform()方法进行了一层封装而已，它们背后的源码仍然还是借助transform()方法来实现的。 这里我们就选择其中一种内置的图片变换操作来演示一下吧，circleCrop()方法是用来对图片进行圆形化裁剪的，我们动手试一下，代码如下所示： 1234567String url = &quot;http://guolin.tech/book.png&quot;;RequestOptions options = new RequestOptions() .circleCrop();Glide.with(this) .load(url) .apply(options) .into(imageView); 这会对图片进行圆形化裁剪。 当然，除了使用内置的图片变换操作之外，我们完全可以自定义自己的图片变换操作。理论上，在对图片进行变换这个步骤中我们可以进行任何的操作，你想对图片怎么样都可以。包括圆角化、圆形化、黑白化、模糊化等等，甚至你将原图片完全替换成另外一张图都是可以的。 不过由于这部分内容相对于Glide 3没有任何的变化，因此就不再重复进行讲解了。想学习自定义图片变换操作的朋友们可以参考这篇文章 Android图片加载框架最全解析（五），Glide强大的图片变换功能 。 关于图片变换，最后我们再来看一个非常优秀的开源库，glide-transformations。它实现了很多通用的图片变换效果，如裁剪变换、颜色变换、模糊变换等等，使得我们可以非常轻松地进行各种各样的图片变换。 glide-transformations的项目主页地址是 地址 。 下面我们就来体验一下这个库的强大功能吧。首先需要将这个库引入到我们的项目当中，在app/build.gradle文件当中添加如下依赖： 123dependencies &#123; implementation &apos;jp.wasabeef:glide-transformations:3.0.1&apos;&#125; 我们可以对图片进行单个变换处理，也可以将多种图片变换叠加在一起使用。比如我想同时对图片进行模糊化和黑白化处理，就可以这么写： 1234567String url = &quot;http://guolin.tech/book.png&quot;;RequestOptions options = new RequestOptions() .transforms(new BlurTransformation(), new GrayscaleTransformation());Glide.with(this) .load(url) .apply(options) .into(imageView); 可以看到，同时执行多种图片变换的时候，只需要将它们都传入到transforms()方法中即可。 自定义模块自定义模块属于Glide中的高级功能，同时也是难度比较高的一部分内容。 这里我不可能在这一篇文章中将自定义模块的内容全讲一遍，限于篇幅的限制我只能讲一讲Glide 4中变化的这部分内容。关于Glide自定义模块的全部内容，请大家去参考 Android图片加载框架最全解析（六），探究Glide的自定义模块功能 这篇文章。 首先定义一个我们自己的模块类，并让它继承自AppGlideModule，如下所示： 1234567891011121314@GlideModulepublic class MyAppGlideModule extends AppGlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; &#125; @Override public void registerComponents(Context context, Glide glide, Registry registry) &#123; &#125;&#125; 可以看到，在MyAppGlideModule类当中，我们重写了applyOptions()和registerComponents()方法，这两个方法分别就是用来更改Glide配置以及替换Glide组件的。 注意在MyAppGlideModule类在上面，我们加入了一个@GlideModule的注解，这是Gilde 4和Glide 3最大的一个不同之处。在Glide 3中，我们定义了自定义模块之后，还必须在AndroidManifest.xml文件中去注册它才能生效，而在Glide 4中是不需要的，因为@GlideModule这个注解已经能够让Glide识别到这个自定义模块了。 这样的话，我们就将Glide自定义模块的功能完成了。后面只需要在applyOptions()和registerComponents()这两个方法中加入具体的逻辑，就能实现更改Glide配置或者替换Glide组件的功能了。详情还是请参考 Android图片加载框架最全解析（六），探究Glide的自定义模块功能 这篇文章，这里就不再展开讨论了。]]></content>
      <categories>
        <category>图片加载</category>
      </categories>
      <tags>
        <tag>Android图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo基础课程之感知(下)]]></title>
    <url>%2F2019%2F03%2F18%2FApollo%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%BA%94%E8%AF%BE%E4%B9%8B%E6%84%9F%E7%9F%A5-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[一、卷积神经网络卷积神经网络CNN是一种人工神经网络，它对感知问题特别有效，CNN接受多维输入包括定义大多数传感器数据的二维和三维形状。如果使用标准神经网络对图像进行分类，则需要通过一种方法将图像连接到网络的第一层，这属于一维。标准做法是通过将图像矩阵重塑为一个矢量，并在一个大行中连接所有列，将图像“展开”为一维像素阵列。。。 然而这种方法打破了图像中所嵌入的空间信息，如果图像中有车轮，则车轮中的所有像素将散布在整个像素阵列中。如果将其散布在一个维度上，神经网络很难从图像中提取车轮。CNN通过维持输入像素之间的空间关系来解决这个问题，CNN通过将过滤器连续滑过图像来收集信息，每次收集信息时，只对整个图像的一小部分区域进行分析，称为卷积。当在整个输入图像上对一个过滤器进行卷积时，将该信息与下一个卷积层相关联。例如CNN识别第一个卷积层中的基本边缘和颜色信息，然后通过在第一层上卷积新过滤器，CNN使用边缘和颜色信息来归纳更复杂的结构如车轮、车门、挡风玻璃；而另一个卷积可使用车轮、车门、挡风玻璃识别整个车辆；最后神经网络可使用这一高阶信息对车辆进行分类。CNN根据其任务查找真正需要的特征，任务可能是图像检测、分类、分割、其他类型的目标。 二、检测与分类感知任务中，首先是障碍物检测和分类，在驾驶过程中会遇到许多障碍物，静态障碍物包括墙壁、树木、杆子、建筑物；动态障碍物包括行人、自行车、汽车。计算机首先需要知道障碍物的位置，然后进行分类。在路中行驶的无人驾驶车可能会探测到许多不同的物体，汽车根据所感知的物体类型来确定路径和速度。如果感知到前方有一辆自行车，汽车可能会决定减速和变道，以便安全驶过自行车。但是如果感知到前方有另一辆车，并预测到前方车辆也将以接近限速的速度行驶，可能会保持其速度和车道。将另一个示例为交通信号灯检测分类，首先将使用计算机视觉对图像中的交通信号灯进行定位，然后根据灯光显示颜色对交通信号灯进行分类。无人驾驶中，使用什么算法来对障碍物进行检测和分类？可以先使用检测CNN来查找图像中的对象的位置，在对图像中的对象进行定位后，可以将图像发送给另一个CNN进行分类。也可以使用单一CNN体系结构对对象进行检测和分类，一种通常的做法为在单个网络体系结构的末端附加几个不同的“头”，一个头可能执行检测，另一个则可能执行分类。经典体系结构为 R-CNN、Fast R-CNN、Faster R-CNN、YOLO、SSD等。 三，跟踪检测完对象后，需要追踪它们追踪的意义是什么？如果我们对每个帧中的每个对象进行检测并用边界框对每个对象进行标识，那么跨帧追踪对象会带来哪些好处？ 首先追踪在检测失败时是至关重要的，如果你在运行检测算法时，对象被其他对象遮挡一部分，则检测算法可能会失败，但追踪可以解决遮挡问题。另一个原因在于追踪可以保留身份，障碍物检测的输出为包含对象的边界框，但是对象没有与任何身份关联，单独使用对象检测时，计算机不知道一个帧中的哪些对象与下一帧中的哪些对象相对应，该任务对人类来说很简单，但对汽车来说很困难。追踪的第一步为确认身份，通过查找特征相似度最高的对象，将在之前的帧中检测到的所有对象与在当前的帧中检测到的对象进行匹配。对象具有各种特征，可能基于颜色、基于形状，计算机视觉算法可以计算出复杂的图像特征，如局部二值模式和方向梯度直方图。当然也需要考虑连续视频帧中，两个障碍物之间的位置和速度，由于两帧之间的对象位置和速度没有太大变化，该信息也可以帮助快速找到匹配的对象。在确定身份后，可以使用对象的位置并结合预测算法以估计在下一个时间步的速度和位置，该预测可帮助识别下一帧中的相应对象。 四、分割语义分割涉及对图像的每个像素进行分类，用于尽可能详细地了解环境并确定车辆可驾驶区域。语义分割依赖于一种特殊类型的CNN，被称为全卷积网络FCN。FCN用卷积层来替代传统CNN体系结构末端的平坦层，现在网络中的每一层都是卷积层，因此名称为“全卷积网络”。FCN提供了可在原始输入图像之上叠加的逐像素输出，必须考虑的一个复杂因素是大小。在典型的CNN中经过多次卷积之后所产生的输出比原始输入图像小得多。然而为了分割像素，输出尺寸必须与原始图像的尺寸相匹配。为了完成，可以对中间输出进行上采样处理，直到最终输出的大小与原始输出图像的大小相匹配。网络的前半部分通常被称为编码器，因为这部分网络对输入图像的特征进行了提取和编码。网络的后半部分通常被称为解码器，因为它对这些特征进行了解码并将其应用于输出。激光雷达数据提供了用于构建世界视觉表征的足够空间信息，计算机视觉技术不仅可以使用摄像头图像进行对象分类，还可以使用点云和其他类型的空间相关数据进行对象分类。 五、Apollo 感知Apollo 开放式软件栈可感知障碍物、交通信号灯、车道。对于三维对象检测，Apollo 在高精度地图上使用感兴趣区域ROI来重点关注相关对象。Apollo将ROI过滤器应用于点云和图像数据，以缩小搜索范围并加快感知。然后通过检测网络馈送已过滤的点云，输出用于构建围绕对象的三维边界框。最后使用被称为检测跟踪关联的算法来跨时间步识别单个对象，该算法先保留在每个时间步要跟踪的对象列表，然后在下一个时间步中找到每个对象的最佳匹配。对于交通信号灯的分类，Apollo先使用高精度地图来确定前方是否存在交通信号灯。如果前方有交通信号灯，则高精度地图会返回灯的位置。后续根据位置，摄像头搜索范围，在摄像头捕获到交通信号灯图像后。Apollo使用检测网络对图像中的灯进行定位，然后从较大的图像中提取交通信号灯。将裁剪的交通灯图像提供给分类网络以确定灯颜色，如果有许多灯则系统需要选择哪些灯与其车道相关。Apollo使用 YOLO 网络来检测车道线、动态物体其中包括车辆、卡车、骑自行车的人、行人。在经过YOLO网络检测后，在线检测模块会并入来自其他传感器的数据对车道线预测进行调整，车道线最终被并入名为“虚拟车道”的单一数据结构中。同样也通过其他传感器的数据对YOLO网络所检测到的动态对象进行调整，以获得每个对象的类型、位置、速度、前进方向。虚拟通道和动态对象均被传递到规划与控制模块。 六、传感器数据比较感知通常依赖于摄像头、激光雷达、雷达，如图显示了这三种传感器的优缺点。摄像头非常适用于分类，在Apollo中摄像头主要用于交通信号灯分类、车道检测。激光雷达的优势在于障碍物检测，即使在夜间仍能准确地检测障碍物。雷达在探测范围和应对恶劣天气方面占优势，通过融合这三种传感器的数据可实现最佳聚合性能，被称为“传感器融合”。雷达已经在汽车上使用很多年，在各种系统中都需要雷达，如自适应巡航控制、盲点警告、碰撞警告和碰撞预防系统等。尽管雷达技术已经成熟，它仍在不断进步，作用不断提升。其他传感器测量速度的方法是计算两次读数之间的差距，而雷达则通过多普勒效应来直接测量速度。多普勒效应根据对象在远离还是接近你，测量出雷达的频率变化。就像消防车警报器一样，当车辆正在远离你和驶向你时，听起来声是不一样的。多普勒效应对传感器融合至关重要。因为它可以把速度作为独立的测量参数，从而提升了融合算法的收敛速度。雷达还可以生成环境的雷达地图，进而实现定位。因为雷达波在坚硬表面会回弹。因此，它可以直接测量对象距离，无需在视线范围内也可以。雷达可以看到其他车辆底部。并发现可能会被阻挡的建筑物和对象。在车上的所有传感器中，雷达是不容易受雨雾影响的。而且视野宽阔，可达 150 度，距离可达 200 多米。与激光雷达和摄像头相比，雷达分辨率较低，尤其是在垂直方向，分辨率非常有限。分辨率低意味着来自静态物体的反射可能产生问题。例如，街道上检修孔盖或汽水罐，可能产生很高的雷达反射率，但他们并不大。我们将其称为雷达杂波。因此，当前的车载雷达通常会忽视静态物体。 激光雷达是激光探测与测量的简称，而雷达则是无线电探测与测量的简称。雷达使用无线电波，而激光雷达则使用红激光束来确定传感器和附近对象的距离。目前的激光雷达大多使用 900 纳米光波长度的光源。但部分激光雷达使用的光波长度更长，在雨雾中性能更好。当前的激光雷达使用旋转座架发射激光，扫描周边环境。激光室脉冲式的，脉冲被对象反射，然后返回一个点云，来代表这些物体。激光雷达的空间分辨率远远高于雷达。因为激光束越聚焦，垂直方向的扫描层数量就越多，因此每层的激光雷达的密度也越高。目前，激光雷达还不能直接测量对象的速度，必须使用两次或多次扫描之间的位置差来确定。激光雷达受天气和传感器清洁程度影响也很大，因此需要保持清洁。它们块头也比其他传感器更大，因此也很难安装，除非你只想在车顶安装一个大的激光扫描器。 七、感知融合策略Apollo使用激光雷达和雷达来检测障碍物，用于融合输出的主要算法为卡尔曼滤波。卡尔曼滤波有两个步骤：第一步为预测状态，第二步是更新测量结果。设想正在跟踪一名行人，这里的状态表示行人的位置和速度，从已经掌握的行人状态开始，使用这些信息来执行卡尔曼滤波的第一步，即预测行人在将来的状态；下一步为误差结果更新，使用新的传感器来更新所认为的行人状态，卡尔曼滤波算法是预测和更新步骤的无限循环。实际上有两种测量结果更新步骤：同步和异步。同步融合同时更新来自不同传感器的测量结果，而异步融合则逐个更新所收到的传感器测量结果。传感器融合可提高感知性能，因为各传感器相辅相成，融合也可以减少跟踪误差。]]></content>
      <categories>
        <category>无人驾驶</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apllo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo基础课程之无人驾驶概览]]></title>
    <url>%2F2019%2F03%2F18%2FApollo%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE%E4%B9%8B%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[这是学习Apollo基础课程的第一课，课程从自动驾驶核心技术模块出发，讲解高精地图、定位、感知、预测、规划、控制等模块知识，帮助零基础开发人员了解无人驾驶的基本原理与整体框架，初步掌握并运用 Apollo 自动驾驶开放平台所使用的自动驾驶算法。 一、全面了解自动驾驶主要模块Apollo 技术框架由四个层面组成，参考车辆平台、参考硬件平台、开源软件平台、云服务平台。其中主要模块包括高精度地图、定位、感知、预测、规划、控制等模块。要学习的课程也将围绕这些模块展开。在高精地图课程中我们将为大家介绍无人车的核心模块，高精地图几乎支持着软件栈的所有其他模块，尤其是定位、感知、规划和决策。在定位课程中，我们将讨论车辆如何确认所在位置。车辆利用激光和雷达数据将这些传感器感知内容与高分辨率地图进行对比，这种对比使车辆能够以个位数厘米级精度进行定位。感知课程将带大家了解无人驾驶车如何感知这个世界，深度学习是一个重要且强有力的感知工具，卷积神经网络构成深度学习分支，对感知任务至关重要，如分类、检测和分割。预测课程将概述几种不同的方式，用于预测其他车辆或行人可能如何移动一种方法称为递归神经网络，可对其他物体随时间的运动进行跟踪，并使用该时间序列数据预测未来。 二、无人车的运作方式首先了解无人驾驶车包括五个核心部件，计算机视觉、传感器融合、定位、路径规划、控制。无人驾驶车的工作原理计算机视觉和传感器融合,获取一幅关于我们在世界上的位置的丰富画面并确定我们在这个世界的精确位置。然后使用路径规划来绘制一条通过这个世界到达目的地的路径，通过控制转动方向盘、打开油门、然后踩制动器，沿着该轨迹行驶并最终移动车辆。从本质上讲，其他一切无人车都是这些核心功能更复杂的实现。 1简言之,就是先通过摄像头或其与其它传感器融合，得到无人车的具体位置，一般是与高精地图相比较以得出地址，相当于看路的过程。 三、开放式软件栈Apollo开放式软件层分为三个子层，实时操作系统、运行时框架、应用程序模块层。实时操作系统（RTOS），可确保在给定时间内完成特定任务，“实时”是指无人车的操作系统，能够及时进行计算，分析并执行相应的操作，是在车辆传感器收集到外界数据后的短时间内完成的。实时性能是确保系统稳定性和驾驶安全性的重要要求。注：Apollo最新的3.5版本已经取代了RTOS，用了自研的Cycer平台作为底层的通讯与调度平台。运行时框架，是Apollo的操作环境，是ROS的定制版即机器人操作系统。为了使ROS适应无人车，Apollo团队改进了共享内存的功能和性能、去中心化和数据兼容性。核心内容–应用程序模块层，Apollo软件平台具有各种模块，这些模块包括 MAP引擎、定位、感知、规划、控制、端到端驾驶以及人机接口（HMI）。每个模块都有自己的算法库，之间的关系也非常复杂，我们将在整个课程中对这些模块及其关联方式进行研究。 四，本节其他重点参考车辆与硬件平台、云服务进阶拓展阅读学习：《自动驾驶汽车硬件系统概述》《Apollo“云+端”研发迭代新模式实战》 自动驾驶汽车硬件系统概述：与人做比较的话，如果说人工智能技术将是自动驾驶汽车的大脑，那么硬件系统就是它的神经与四肢。从自动驾驶汽车周边环境信息的采集、传导、处理、反应再到各种复杂情景的解析，硬件系统的构造与升级对于自动驾驶汽车至关重要。来自百度自动驾驶技术部高级产品经理—王石峰的分享。有关自动驾驶汽车硬件系统的内容。分为五个方面，学习的总结如下： 1，自动驾驶系统的硬件架构去年Uber无人车测试撞死人案相信大家都知道，毕竟是无人车测试撞死人第一案，先抛开谁的责任不说先说说这个无人驾驶为什么识别到行人没有？识别到了的话有没有做刹车的决策？做了的话有没有做相应的控制，或者有什么其它的问题导致汽车没有刹车。题外话这是用的沃尔沃的XC90改装的，哎，号称最安全的车如今出事了，感觉沃尔沃被Uber坑了一把啊。最后的事故调查显示：事故的主要原因是车辆不在环和司机不在环造成的。Uber在改造原车加装自动驾驶系统时，将原车自带的AEB功能执行部分截断造成原车ADAS功能失效。自动驾驶系统感知到受害者确定要执行应急制动时，并没有声音或图像警报，此时司机正低头看手机也没有及时接管刹车。据说测试员之前还做过牢，居然还让他在晚上来测试无人车，Uber真的是。目前绝大多数自动驾驶研发车都是改装车辆，相关传感器加装到车顶，改变车辆的动力学模型；改装车辆的刹车和转向系统，也缺乏不同的工况和两冬一夏的测试。图中Uber研发用车是SUV车型自身重心就较高，车顶加装的设备进一步造成重心上移，在避让转向的过程中转向过急过度，发生碰撞时都会比原车更容易侧翻。 在自动驾驶中，安全是自动驾驶技术开发的第一天条，我记得陆奇博士在首个pollo开发者大会时候说过，一辆无人车如果失去控制，可以变成一个武器。当时没有明白，现在想他说的是这个意思，的确是。安全真的很重要，特别重要。 2，自动驾驶的传感器3，自动驾驶传感器的产品定义4，自动驾驶的大脑5，自动驾驶汽车的线控系统]]></content>
      <categories>
        <category>无人驾驶</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apllo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo基础课程之高精地图]]></title>
    <url>%2F2019%2F03%2F18%2FApollo%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%BA%8C%E8%AF%BE%E4%B9%8B%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一、高精地图与传统地图当我们开车时，打开导航地图通常会给我们推荐几条路线，甚至会显示道路是否拥堵以及每条路线将花费多长时间、交通管制，例如交通信号灯或限速标志等，我们会根据地图提供的信息来决定是在行驶中直行、左转还是右转以及对周围驾驶环境的评估。而无人驾驶车缺乏人类驾驶员固有的视觉和逻辑能力。如我们可以利用所看到的东西和GPS来确定自己的位置，还可以轻松准确地识别障碍物、其他车辆、行人、交通信号灯等，但要想让无人车变得和人类一样聪明，可是一项非常艰巨的任务。 这时就需要高精地图了，高精地图是当前无人驾驶车技术不可或缺的一部分。它包含了大量的驾驶辅助信息，最重要是包含道路网的精确三维表征，例如交叉路口布局和路标位置。无人车就是靠这个信息而得以知道自己的确切位置，不然无人驾驶也就无从谈起。实际上高精地图还包含很多语义信息，地图上可能会报告交通灯不同颜色的含义，也可能指示道路的速度限制，及左转车道开始的位置。既然是”高精”地图，那么它最重要特征之一是精度，手机上的导航地图只能达到米级精度，而高精地图可以使车辆能够达到厘米级(个位数厘米级)的精度，这对确保无人车的安全性至关重要。 二、高精地图与定位、感知规划的关系2.1 高精地图用于定位高精地图是Apollo平台的核心，许多无人驾驶车模块都有赖于高精地图，有了高精地图车辆就可以在地图上进行自定位。这意味，需要弄清我们在地图上的位置，这就是定位——无人驾驶车辆在地图上的确切位置。首先车辆可能会寻找地标，我们可以使用从各类传感器收集的数据，如摄像机图像数据、激光雷达收集的三维点云数据来查找地标。车辆将其收集的数据与其在高精地图上的已知地标进行比较，这一匹配过程是需要预处理、坐标转换、数据融合的复杂过程。无人车的整个定位过程取决于高精地图，所以车辆需要通过高精地图明确它处于什么位置。 2.2 高精地图用于感知无人车也可以使用高精地图来帮助感知，就像人的眼睛和耳朵会受到环境因素的影响一样，无人车的传感器也是如此。摄像机、激光雷达、雷达探测物体的能力，在超过一定距离后都会受到限制。在恶劣的天气条件下或在夜间，传感器识别障碍物的能力可能会受到进一步限制。另外当车辆遇到障碍物时，传感器无法透过障碍物来确定障碍物后面的物体。这时，就需要借助高精地图的帮助了。即使传感器尚未检测到交通信号灯，高精地图也可以将交通信号灯的位置提供给软件栈的其余部分，帮助车辆做下一个决策。另一个好处在于，高精地图可帮助传感器缩小检测范围，如高精地图可能会告知我们在特定位置寻找停车标志，传感器就可以集中在该位置检测停车标志，被称为感兴趣区域ROI。ROI可帮助我们提高检测精确度和速度，并节约计算资源。 2.3 高精地图用于规划正如定位和感知依赖高精地图那样，规划也是如此。高精地图可帮助车辆找到合适的行车空间，还可以帮助规划器确定不同的路线选择，来帮助预测模块预测道路上其他车辆将来的位置。如高精地图可帮助车辆识别车道的确切中心线，这样车辆可以尽可能地靠近中心行驶。在具有低速限制、人行横道或减速带的区域，高精地图可以使车辆能够提前查看并预先减速。如果前方有障碍物，车辆可能需要变道，可帮助车辆缩小选择范围，以便选择最佳方案。 三、Apollo高精度地图与构建3.1 Apollo高精地图Apollo高精地图专为无人车设计，里面包含了道路定义、交叉路口、交通信号、车道规则，及用于汽车导航的其他元素。高精度地图可在许多方面为无人车提供帮助，如高精度地图通常会记录交通信号灯的精确位置和高度，从而大大降低了感知难度。高精地图不仅可以减少计算需求，还可以通过提供有关驾驶环境的详细信息，来确保无人车的安全。保持这些地图的更新是一项重大任务，测试车队需要不断地对高精度地图进行验证和更新。此外，这些地图可能达到几厘米的精度，这是水准最高的制图精度。Apollo 高精地图是最懂自动驾驶的高精地图，也是业界精细化程度最高、生产率最高、覆盖面最广的高精地图。目前，Apollo 高精地图的自动化程度已经达到了90%、准确识别率达到了95%以上，预计2020年可以覆盖全国所有的重点道路。高精地图有很多种格式，为了方便数据共享，Apollo高精地图采用了OpenDRIVE格式，这是一种行业制图标准。同时，Apollo也对OpenDRIVE做出了改进，进而产生了Apollo OpenDRIVE标准，以便更适合无人车。 3.2 Apollo高精地图的构建高精度地图的构建由五个过程组成：数据采集、数据处理、对象检测、手动验证和地图发布。数据采集是一项庞大的密集型任务，近300辆Apollo测试车辆负责收集用于制作地图的源数据，以便确保每次道路发生改变时，地图均会得到快速更新。测试车辆使用了多种传感器，如GPS、IMU、激光雷达、摄像机。Apollo定义了一个硬件框架，将这些传感器集成到单个自主系统中，通过支持多种类的传感器，Apollo收集各类数据将这些数据融合，最终生成高精度地图。数据处理指的是Apollo如何对收集到的数据进行整理、分类和精简，以获得没有任何语义信息或注释的初始地图模板。对于对象检测，Apollo使用人工智能来检测静态对象并对其进行分类，其中包括车道线、交通标志、甚至是电线杆，手动验证可确保自动地图创建过程正确进行并及时发现问题。Apollo使手动验证团队能够高效标记和编辑地图，在经过数据采集、数据处理、对象检测、手动验证之后，高精地图才能发布。除高精地图外，Apollo还发布了采用自上而下视图的相应定位地图、三维点云地图。在构建和更新地图的过程中，Apollo使用众包向公众发布其数据采集工具，以便任何人都可以参与制作高精度地图的任务，这加快了高精地图制作和维护的过程。]]></content>
      <categories>
        <category>无人驾驶</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apllo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo基础课程之感知(上)]]></title>
    <url>%2F2019%2F03%2F18%2FApollo%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E7%AC%AC%E5%9B%9B%E8%AF%BE%E4%B9%8B%E6%84%9F%E7%9F%A5-%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[在开车时，我们用眼睛来判断速度、车道位置、转弯位置。在无人驾驶车中，情况类似，只不过需要使用静态摄像头和其他传感器来感知环境，使用大量计算机视觉技术。 一、感知的概述对于无人驾驶车辆它们有雷达和激光雷达，可以帮助测量原始距离，可以得到与周围环境物体的距离。对于每个无人驾驶汽车，它的核心竞争力之一是利用海量的传感器数据，来模仿人脑理解这个世界。谈论传感器时也会涉及到神经网络、深度学习、人工智能。 二、计算机视觉图像中的物体对于计算机而言图像只是红、绿、蓝色值的集合，无人驾驶车有四个感知世界的核心任务：检测——指找出物体在环境中的位置；分类——指明确对象是什么；跟踪——指随时间的推移观察移动物体；语义分割——将图像中的每个像素与语义类别进行匹配如道路、汽车、天空。将分类作为作为研究计算机视觉一般数据流程的例子。图像分类器是一种将图像作为输入，并输出标识该图像的标签的算法，例如交通标志分类器查看停车标志并识别它是停车标志、让路标志、限速标志、其他标志。分类其甚至可以识别行为，比如一个人是在走路还是在跑步。分类器有很多种，但它们都包含一系列类似的步骤。首先计算机接收类似摄像头等成像设备的输入。然后通过预处理发送每个图像，预处理对每个图像进行了标准化处理，常见的预处理包括调整图像大小、旋转图像、将图像从一个色彩空间转换为另一个色彩空间，比如从全彩到灰度，处理可帮助我们的模型更快地处理和学习图像。接下来，提取特征，特征有助于计算机理解图像，例如将汽车与自行车区分开来的一些特征，汽车通常具有更大的形状并且有四个轮子而不是两个，形状和车轮将是汽车的显著特征。最后这些特征被输入到分类模型中。此步骤使用特征来选择图像类别，例如分类器可以确定图像是否包含汽车、自行车、行人、不包含这样的对象。 三、摄像头图像不论计算机在执行什么识别任务，通常在开始时将摄像头图像作为输入。摄像头图像是最常见的计算机视觉数据，以这张汽车照片为例，让我们看看计算机如何认为这实际上是一辆汽车的图像。从计算机的角度来看，图像只是一个二维网格被称为矩阵，矩阵中的每个单元格都包含一个值，数字图像全部由像素组成，其中包含非常小的颜色或强度单位，我们可以对其中的数字做出非常多的处理。通常这些数字网格是许多图像处理技术的基础，多数颜色和形状转换都只是通过对图像进行数学运算以及逐一像素进行更改来完成。以上是我们将一个图像分解为二维灰度像素值网络，彩色照片是相似的，但是更复杂一些。彩色图像被构建为值的三维立方体，每个立方体都有高度、宽度和深度，深度为颜色通道数量。大多数彩色图像以三种颜色组合表示红色、绿色、蓝色，称为RGB图像。对于RGB图像来说，深度值是3，因此可用立方体来表示。 四、LiDAR图像感知扩展到传感器，而不仅仅是摄像头。激光雷达传感器创建环境的点云表征，提供了难以通过摄像头图像获得的信息如距离和高度。激光雷达传感器使用光线尤其是激光来测量与环境中反射该光线的物体之间的距离，激光雷达发射激光脉冲并测量物体，将每个激光脉冲反射回传感器所花费的时间,反射需要的时间越长，物体离传感器越远，激光雷达正是通过这种方式来构建世界的视觉表征。激光雷达通过发射光脉冲来检测汽车周围的环境，蓝色点表示反射激光脉冲的物体，中间的黑色区域是无人驾驶车本身占据的空间。由于激光雷达测量激光反射束，它收集的数据形成一团云或“点云”，点云中的每个点代表反射回传感器的激光束，可以告诉我们关于物体的许多信息例如其形状和表面纹理。这些数据提供了足够的对象检测、跟踪、分类信息。正如我们所看，在点云上执行的检测和分类结果为红点为行人，绿点表示其他汽车。 激光雷达数据提供了用于构建世界视觉表征的足够空间信息，计算机视觉技术不仅可以使用摄像头图像进行对象分类，还可以使用点云和其他类型的空间相关数据进行对象分类。 五、机器学习机器学习是使用特殊算法来训练计算机从数据中学习的计算机科学领域。通常，这种学习结果存放在一种被称为“模型”的数据结构中，有很多种模型，事实上“模型”只是一种可用于理解和预测世界的数据结构。机械学习诞生于20世纪60年代，但随着计算机的改进，在过去的20年中才真正的越来越受到欢迎。机器学习涉及使用数据和相关的真值标记来进行模型训练，例如可能会显示车辆和行人的计算机图像以及告诉计算机哪个是哪个的标签。我们让计算机学习如何最好地区分两类图像，这类机器学习也称为监督式学习，因为模型利用了人类创造的真值标记。可以假想一个类似的学习过程，但这次使用的是没有真值标记的车辆与行人图像，让计算机自行决定哪些图像相似、哪些图像不同，这被称为无监督学习。不提供真值标记，而是通过分析输入的数据，计算机凭借自行学习找到区别。半监督式学习是将监督学习和无监督学习的特点结合在一起，该方法使用少量的标记数据和大量的未标记数据来训练模型。强化学习是另一种机器学习，强化学习涉及允许模型通过尝试许多不同的方法来解决问题，然后衡量哪种方法最为成功，计算机将尝试许多不同的解决方案，最终使其方法与环境相适应。例如在模拟器中，强化学习智能体可训练汽车进行右转，智能体将在初始位置发动车辆，然后以多种不同的方向和速度进行实验性驾驶，如果车辆实际完成了右转，智能体会提高奖励即得分。起初车辆可能无法找到执行转弯的方法，然而就像人类那样，车辆最终会从一些成功的右转经验中学习，最后学会如何完成任务。 六、神经网络人工神经网络用于无人驾驶车，受到构成人类神经系统的生物神经元启发，生物神经元通过相互连接构成了神经元网络或神经网络，通过类似的方式将人工神经元层连接起来以创建用于机器学习的人工神经网络。生物神经人工神经网络是通过数据来学习复杂模式的工具，神经网络由大量的神经元组成，人工神经元负责传递和处理信息，也可以对这些神经元进行训练。可以将这些图像识别为车辆，无论它们是黑是白、或大或小，你甚至可能不知道自己如何知道它们是车辆，也许是某些特征触发了你的反应，如车轮、车灯、车窗。人工神经网络具有类似的运作方式。人工神经网络通过密集训练，计算机可以辨别汽车、行人、交通信号灯、电线杆。它们学习了用于执行任务的模型，只是我们可能很难直观地理解该数学模型。元通过相互连接构成了神经元网络或神经网络，通过类似的方式将人工神经元层连接起来以创建用于机器学习的人工神经网络。当看到该图像时，你的大脑如何工作？你的大脑可能会将图像分为几部分然后识别特征如车轮、车窗、颜色，然后大脑将使用这些特征对图像进行检测和分类。例如在确定图像是否为车辆时，大脑可能不会认为颜色是关键特征。因为汽车有多种颜色，所以大脑会将更多权重放在其他特征上并降低颜色的重要性。同样，神经网络也会从图像中提取许多特征，但这些特征可能是我们人类无法描述或甚至无法理解的特征。但我们最终并不需要理解，计算机将调整这些特征的权重，以完成神经网络的最终任务。 七、反向波算法学习有时称为训练，由三步循环组成——前馈、误差测定、反向传播。首先随机分配初始权重即人工神经元的值，通过神经网络来馈送每个图像产生输出值，这被称为前馈。继续开车可以发现，有些点右边只有一棵树，也可以排除。下一步为误差测定，误差是真值标记与与前馈过程所产生输出之间的偏差。下一步是反向传播，通过神经网络反向发送误差，此过程类似前馈过程，只是以相反方向进行。每个人工神经元都对其值进行微调，这是基于通过神经网络后向传播的误差，可生成更准确的网络。一个训练周期：包括前馈、误差测定、反向传播还远远不够。为了训练网络，通常需要数千个这样的周期，最终结果应该是模型能够根据新数据做出准确预测。]]></content>
      <categories>
        <category>无人驾驶</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apllo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apollo基础课程之定位]]></title>
    <url>%2F2019%2F03%2F15%2FApollo%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%B8%89%E8%AF%BE%E4%B9%8B%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[学习百度Apollo无人驾驶课程之定位教程。本周学习定位模块的知识，了解车辆如何以个位数厘米级别的精度进行自定位。定位是让无人车自己知道自身确切的位置，定位对无人驾驶尤其重要，对于无人车来讲不仅仅要找出自身的大概位置，而是要以10厘米级别，将车感信息与高精地图信息相比对来精确地位置寻找。 定位的描述在日常生活中，假设你有一张高精地图，定位的任务是确定你的车辆在这张高精地图上的位置。 大多数时候我们用GPS来定位，我们用手机导航，手机中的app用我们的位置信息也是用GPS来定位，比如常用的外卖app，这已经足够了。但是PS对于无人车来讲是远远不够远远不够精确的。因此我们需要找到别的方式来进行更加准确的定位，确定车辆在地图上的位置，最常用的方法是将汽车传感器所看到的内容与地图上所显示的内容相比较。车辆传感器可测量车辆与静态障碍物之间的距离。车子就在自身的坐标系中测量这些距离以及这些静态障碍物的方向。在这个坐标系中，汽车的前进方向始终与车头保持一致，但不一定与地图坐标系保持一致。当车辆传感器测量到地图上的物体，会将传感器的地标观测值，与地标在地图上的位置匹配，转换到地图自带坐标系，反之亦然，从而达到地图与车感数据的对比。接下来介绍几种可选择的方法，每种都有自己的优劣，接下来介绍几种主流的定位方法。 定位方法介绍1，GNNS RTK如果你在野外迷路，然后看到一棵离自己75米远的树，你现在只知道你自己在以这棵树为圆心半径是75米的一个圆上。但是如果你还知道你你离一个房子64米远，你就知道你在这以这栋房子为圆心半径为64米的圆与刚刚那个圆的交点，此时两个圆的交点有两个，我们还不能完全确定自己的位置。如果我们又看到了第三个路标，假设它是路灯，并且我们离它55米远，那我们就知道了自己相对于这些地标位置的确切值。首先假设现在有一个世界地图标注了这三个地标在世界上的确切位置，那么就可以知道自己的确切位置了，这就称为三角测量。GPS就是这样的工作原理，只是参照物是卫星(同步卫星，和地球公转的角速度一样)。三颗卫星再加上一颗用来定位高度的卫星，4颗卫星就可以知道自身的确切位置了。GPS这类系统的名称为全球导航卫星系统或GNNS，GPS是其中使用最为广泛的GNNS系统。GPS分为三部分： 1,卫星，在任何特定时间大约有30颗GPS卫星在太空运行，它们距离地球的距离约为2万公里 2，由各地的控制站组成，控制站用于监视和控制卫星，主要目的是让系统保持运行并验证GPS广播信号的精确度 3，GSP接收器，这部分我们可能最熟悉，它位于手机、电脑、汽车、船只以及许多电子设备中GPS实际上并不直接测量你与卫星之间的距离，而时首先测量信号的飞行时间即TOF原理。通过将光速乘这个飞行时间，来计算距离卫星的距离。由于光的速度很大，所以即使是很小的时间误差也会在计算距离的时候造成巨大的误差。为了减小这个误差，每颗卫星都配置了原子钟。为进一步减小误差，使用实时运动定位(RTK)。RTK需要在地面上建几个基站，每个基站都知道自己精确的地面”实况位置”，但是每个基站同时也通过GSP测量自己的位置。已知的”地面实况”位置与通过GPS测量的位置之间的偏差，为GPS测量结果中的误差。然后将这个误差传递给其他GPS接收器以供其调整自身的位置计算。在RTK的帮助下，GPS可以将定位误差限制在10厘米以内。不过GSP有个缺点，就是高楼大厦和其他障碍物可能会阻挡GPS信号，这个问题在城市尤为明显，而无人车将来的商用化肯定是城市是主战场，这就使得定位会变得困难或极端情况下根本无法定位，这对于无人车来讲肯定是无法接受的。至于原因，你懂得。还有一个缺点，GPS更新频率很低，大概是10赫兹，由于无人车在快速移动可能需要更加频繁的更新位置信息。2， 惯性导航假设汽车以匀速行驶，如果提供了汽车的初始位置、速度、行驶时长，那么汽车的位置也随即从初始位置开始，然后速度乘以时间。假设给了初始速度，并给予加速度和驾驶时间，就可以使用加速度、初始速度、初始位置来计算汽车在任何时间点的车速和位置。加速度需要三轴加速度计的传感器来测量，有三种不同类型的三轴加速度计，它们采用不同的方法，但共同的目的都是精确测量加速度。加速度计根据车辆的坐标系记录测量结果，还需要陀螺仪传感器将这些测量值转换为全局坐标系测量值。三轴螺仪的三个外部平衡环一直在旋转，但三轴陀螺仪中的旋转轴始终固定在世界坐标系中，在坐标系中的位置是通过测量旋转轴和三个外部平衡环的相对位置来计算的。加速度计和陀螺仪是惯性测量单元(IMU)的主要组成组件，IMU可以以高频率更新，可达100赫兹，所以IMU可以提供接近实时的位置信息。但是缺点是在于IMU的误差随时间的增加而增加，我们只能依靠惯性测量单元(IMU)在短时间范围内进行定位。不过我们可以结合GPS和IMU来进行定位。IMU弥补了GPS更新频率低的不足；GPS纠正了IMU的运动误差。不过即使将GPS和IMU结合起来也不能完全解决定位的问题，比如在山里面的隧道或峡谷中行驶那么可能很长时间没有GPS信号，我们需要考虑的极端情况。3， 激光雷达定位重磅产品登场，目前比较贵。不过相信随着商业化的步伐推进，逐渐会降价到普通消费者能接受的地步。 激光雷达是利用点云匹配来对汽车进行定位。该方法是将来自激光雷达传感器的数据与预先存在的高精地图之间进行匹配(所以地图采集很重要，在后面会学习高精地图采集的相关知识，当然地图数据的更新也很重要)。通过这种方式来确定汽车在高精地图上的精确位置和行驶方向，匹配点云有很多方法，迭代最近点就是其中的一种。 1, 迭代最近点对于第一次扫描的每个点，需要找到另一次扫描中最接近的匹配点，最终会找到许多匹配点对，把每个点的距离误差相加，然后计算平均距离误差。假设我们对两次点云扫描进行匹配。我们的目标是通过点云旋转和平移来最大限度地降低这一平均距离误差，就可以在传感器扫描和地图之间找到匹配，将通过传感器扫描到的车辆位置转换为全球地图上的位置并计算出在地图上的位置。 2, 滤波算法滤波算法是另一种雷达定位算法。将扫描到的车辆位置转换为全球地图上的位置并计算出在地图上的精确位置，滤波算法是另一种雷达定位算法。它可以消除冗余信息并在地图上找到最可能的车辆位置。Apollo使用了直方图滤波算法，它有时也被称为误差平方和算法(SSD)。为了应用直方图滤波，将通过传感器扫描的点云数据滑过地图上的每个位置，在每个位置上计算扫描的点与高精地图上的对应点之间的误差或距离然后对误差的平方求和，求得的和越小说明扫描结果与地图之间的匹配越好。在事例中，蓝色表示较好，红色较差，绿色一般。 3,卡尔曼滤波卡尔曼滤波是另一种雷达定位算法，卡尔曼滤波用于根据我们在过去的状态和新的传感器测量结果预测我们当前的状态。它使用了预测更新周期，我们根据之前的状态及对移动距离和方向的改变来估计我们的位置。当然运动估计并不完美，所以需要通过传感器测量我们的位置并加以纠正。一旦测量出了新的位置，我们就利用概率规则将不完美的测量结果与现有的位置匹配起来。一直遵循这个预测更新周期，只要我们需要对车辆进行定位，先预测我们的新位置，然后用传感器测量我们的位置。雷达定位的主要优势在于稳定性，只要从高精地图开始并存在有效的传感器，就始终能进行定位。主要缺点在于难以构建高精地图并使其保持最新，事实上几乎不可能让地图完全保持最新，因为几乎每个地图均包含瞬态元素，汽车、行人、停放车辆、垃圾等等。 1学到一个新的概念:瞬态元素。看上下文也比较好理解，就是这些信息会随时变化，比如在某个位置的行人，会走开，也有可能会有新的人过来，这很正常，所以说不存在完全最新的高精地图。但是不变(或者变化周期稍长的信息)的元素可以确定，比如说道路的宽度，位置，路口。这些信息会变，但是变化周期较长，一旦变化也可以用地图采集车去进行重新采集数据并制作新的高精地图。 4, 视觉定位图像是要收集的最简单的数据类型，摄像头便宜且种类繁多、易于使用。但是实际上通过图像实现精确定位却非常困难，实际上摄像头图像通常与其他传感器的数据相结合以准确定位车辆。比如与GPS 数据相结合来定位。比单独使用摄像头定位效果更好。假设一辆车正在路上行驶，感知到右边有树，但是地图显示道路右侧有几棵树有很多不同的点位置。如何知道车辆现在看到哪棵树？我们可以使用概率来确定哪个点最可能代表我们的实际位置。有些点是无法看到右边有树，可以先排除。继续开车可以发现，有些点右边只有一棵树，也可以排除。这个过程称为粒子滤波。当然树木在许多道路上比较稀少，但是车道线在许多道路上却很常见，可以使用相同的粒子滤波原理对车道线进行拍照，然后使用拍摄的图像来确定车辆在道路中的位置，可以将道路摄像头图像与地图进行比较。如图所示，蓝色代表地图上两个不同位置的车道线，红色代表车辆摄像头观察到的车道线，红线与右侧蓝线的匹配度要比与左侧蓝线的匹配度高得多，更有可能位于右侧图像位置上。 1粒子滤波观察车道线 视觉定位的优点在于图像数据很容易获得，缺点在于缺乏三维信息和对三维地图的依赖。高精地图不仅可以减少计算需求，还可以通过提供有关驾驶环境的详细信息，来确保无人车的安全。保持这些地图的更新是一项重大任务，测试车队需要不断地对高精度地图进行验证和更新。此外，这些地图可能达到几厘米的精度，这是水准最高的制图精度。 Apollo定位接下来学习Apollo定位。首先定义Apollo定位：Apollo使用基于GPS、IMU、激光雷达的多传感器融合定位系统，这种方法利用了不同传感器的互补优势，也提高了稳定性和准确性。Apollo定位模块依赖于IMU、GPS、激光雷达、雷达高精地图，这些传感器同时支持GNSS定位和LiDAR定位，GNSS定位输出位置和速度信息，LiDAR定位输出位置和行进方向信息。融合框架通过卡尔曼滤波将这些输出结合在一起。以提高定位精度。 卡尔曼滤波建立在两步预测测量周期之上，在Apollo中，惯性导航解决方案用于卡尔曼滤波的预测步骤，GNSS 和 LiDAR 定位用于卡尔曼滤波的测量结果更新步骤。附Apollo官方的自动驾驶发展路线图：现在是2019年3月，看样子有限制的自动驾驶很快就会到来，Robin在两会接受采访的时候说下半年会在长沙试水商业化运营。到时候应该会看到消息，我觉得那一天就将会是中国自动驾驶历史上值得纪念的一天，也会拉开中国汽车史上的新篇章。无人驾驶很可能是我们进入新智能时代的一个重要标志。]]></content>
      <categories>
        <category>无人驾驶</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apllo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayMap]]></title>
    <url>%2F2019%2F03%2F14%2FArrayMap%2F</url>
    <content type="text"><![CDATA[ArrayMap源码的分析，ArrayMap实现了Map接口，所以它也是一个数组加链表(或红黑树)，结构也是哈希表。它是线程不安全的，它允许key为null,value为null。相比于HashMap，ArrayMap空间效率更高。ArrayMap内部维护了两个数组， 1，一个int[]数组，用户保存每个item的hashCode值 2，一个Object[]数组，用于保存key–value对。容量上是一个数组的两倍它可以避免在将数据插入Map中时额外的空间消耗(相比于HashMap）。它的扩容只需要进行数组拷贝，不需要重建哈希表(相比于HashMap的扩容)。 和HashMap相比，ArrayMap不仅仅有扩容功能，在删除时，如果集合剩余元素少于一定阈值时，还有收缩功能，这样可以减少空间的浪费。毕竟是Android团队专门为Android新增的api，肯定考虑了移动设备内存很珍贵的因素。 对于哈希碰撞的解决方式，ArrayMap用的是开放地址法，ArrayMap不适用于大容量的数据存储，存储大量数据时，它的性能将退化至少50%，比传统的HashMap时间效率低。因为其会对key从小到大排序，使用二分法查询key对应在数组中的下标，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作。所以其是按照key的大小排序存储的。ArrayMap的使用场景： 数据量不大 空间比时间重要的场景 需要使用Map 在Android平台，相对来说，内存容量更宝贵。而且数据量不大。所以当需要使用key是Object类型的Map时，可以考虑使用ArrayMap来替换HashMap一、构造函数12]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客教程(转载)]]></title>
    <url>%2F2019%2F03%2F06%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[主要是记录一些有用的Hexo教程，以后方便查询。 安卓技术博客Hexo主题配置博客HexoFontAwesome鼠标点击出桃心效果Next主题Github地址安卓技术博客技术博客李瑞豪下位子文章置顶]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap源码(Jdk11.0.2)]]></title>
    <url>%2F2019%2F03%2F05%2FLinkedHashMap%E6%BA%90%E7%A0%81-Jdk11.0.2%2F</url>
    <content type="text"><![CDATA[LinkedHashMap源码分析。源码基于最新的Jdk 11.0.2，不过好像和Jdk 8没什么大区别。本文参考于链接 LinkedHashMap简介 1，LinkedHashMap是线程不安全的，它是一个关联数组、哈希表, 2，LinkedHashMap允许key为null,value为null 3，它继承自HashMap，实现了Map&lt;K,V&gt;接口。其内部还维护了一个双向链表，在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序，以决定迭代时输出的顺序 默认情况，遍历时的顺序是按照插入节点的顺序。这也是其与HashMap最大的区别。也可以在构造时传入accessOrder参数，使得其遍历顺序按照访问的顺序输出。因继承自HashMap,所以HashMap上文分析的特点，除了输出无序，其他LinkedHashMap都有，比如扩容的策略，哈希桶长度一定是2的N次方等等。LinkedHashMap在实现时，就是重写override了几个方法。以满足其输出序列有序的需求。 示例代码： 123456789101112131415LinkedHashMap lkh = new LinkedHashMap();lkh.put(&quot;xiao&quot;, 19);lkh.put(&quot;明&quot;, 18);lkh.put(&quot;小红&quot;, 17);lkh.put(&quot;小黑&quot;, 16);Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;输出结果为：xiao=19明=18小红=17小黑=16 以下则是accessOrder=true的情况： 123456789101112131415161718192021LinkedHashMap lkh = new LinkedHashMap(10,0.75f,true); lkh.put(&quot;xiao&quot;, 19); lkh.put(&quot;明&quot;, 18); lkh.put(&quot;小红&quot;, 17); lkh.put(&quot;小黑&quot;, 16); lkh.get(&quot;明&quot;);//这个元素会移动到内部链表的末尾 lkh.put(&quot;小红&quot;,20);//这个元素调整至末尾 lkh.get(&quot;小黑&quot;);//这个元素调整至末尾 lkh.put(null,null);//插入新的节点 lkh.put(&quot;小张&quot;,21);//插入新的节点 Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = lkh.entrySet().iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;输出结果：xiao=19明=18小红=17小黑=16null=null小张=21 如上代码所示， LinkedHashMap的节点LinkedHashMap的节点Entry&lt;K,V&gt;继承自HashMap.Node&lt;K,V&gt;，在其基础上扩展了一下。改成了一个双向链表。 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 这两个变量分别代表双向链表的头尾。 12transient LinkedHashMap.Entry&lt;K,V&gt; head;transient LinkedHashMap.Entry&lt;K,V&gt; tail; 构造函数 12345final boolean accessOrder;public LinkedHashMap() &#123; super(); accessOrder = false;&#125; accessOrder默认是false，默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。为true时，可以在这基础之上构建一个LruCach。这是LinkedHashMap的一个重要应用。指定初始化容量值得构造函数 1234public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125; 指定初始容量，指定加载因子的构造函数 1234public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125; 指定初始容量，指定加载因子以及迭代输出节点的顺序的构造函数 123456public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 利用另一个LinkedHashMap来构建一个新的LinkedHashMap 12345public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125; 小结：构造函数和HashMap相比，就是增加了一个accessOrder参数。用于控制迭代时的节点顺序。 增加元素LinkedHashMap并没有重写任何put方法。但是其重写了构建新节点的newNode()方法，但是其重写了构建新节点的newNode()方法.newNode()会在HashMap的putVal()方法里被调用，putVal()方法会在批量插入数据putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)或者插入单个数据public V put(K key, V value)时被调用。LinkedHashMap重写了newNode(),在每次构建新节点时，通过linkNodeLast(p);将新节点链接在内部双向链表的尾部。 1234567//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`.Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125; 12345678910111213 //将新增的节点，连接在链表的尾部 private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; //集合之前是空的 if (last == null) head = p; else &#123; //将新节点连接在链表的尾部 p.before = last; last.after = p; &#125;&#125; 以及还重写了HashMap专门预留给LinkedHashMap的afterNodeAccess() afterNodeInsertion() afterNodeRemoval() 方法。 12345678910111213//回调函数，新节点插入之后回调 ， 根据evict 和 判断是否需要删除最老插入的节点。如果实现LruCache会用到这个方法。 void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; //LinkedHashMap 默认返回false 则不删除节点 if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;//LinkedHashMap 默认返回false 则不删除节点。 返回true 代表要删除最早的节点。通常构建一个LruCache会在达到Cache的上限是返回trueprotected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; void afterNodeInsertion(boolean evict)以及boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)是构建LruCache需要的回调。 删除元素LinkedHashMap也没有重写remove()方法，因为它的删除逻辑和HashMap并无区别。但它重写了afterNodeRemoval()这个回调方法。该方法会在Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)方法中回调，removeNode()会在所有涉及到删除节点的方法中被调用，上文分析过，是删除节点操作的真正执行者。 1234567891011121314151617//在删除节点e时，同步将e从双向链表上删除 void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; //待删除节点 p 的前置后置节点都置空 p.before = p.after = null; //如果前置节点是null，则现在的头结点应该是后置节点a if (b == null) head = a; else//否则将前置节点b的后置节点指向a b.after = a; //同理如果后置节点时null ，则尾节点应是b if (a == null) tail = b; else//否则更新后置节点a的前置节点为b a.before = b;&#125; 查询LinkedHashMap重写了get()和getOrDefault()方法： 1234567891011121314151617public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125;public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return defaultValue; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 对比HashMap中的实现,LinkedHashMap只是增加了在成员变量(构造函数时赋值)accessOrder为true的情况下，要去回调void afterNodeAccess(Node&lt;K,V&gt; e)函数。在afterNodeAccess()函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。 12345678910111213141516171819202122232425262728293031void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last;//原尾节点 //如果accessOrder 是true ，且原尾节点不等于e if (accessOrder &amp;&amp; (last = tail) != e) &#123; //节点e强转成双向链表节点p LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; //p现在是尾节点， 后置节点一定是null p.after = null; //如果p的前置节点是null，则p以前是头结点，所以更新现在的头结点是p的后置节点a if (b == null) head = a; else//否则更新p的前直接点b的后置节点为 a b.after = a; //如果p的后置节点不是null，则更新后置节点a的前置节点为b if (a != null) a.before = b; else//如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b last = b; if (last == null) //原本尾节点是null 则，链表中就一个节点 head = p; else &#123;//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p p.before = last; last.after = p; &#125; //尾节点的引用赋值成p tail = p; //修改modCount。 ++modCount; &#125;&#125; 值得注意的是，afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。containsValue它重写了该方法，相比HashMap的实现，更为高效 123456789 public boolean containsValue(Object value) &#123; //遍历一遍链表，去比较有没有value相等的节点，并返回 for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) &#123; V v = e.value; if (v == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; return false;&#125; 对比HashMap，是用两个for循环遍历，相对低效。 12345678910111213public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false;&#125; 遍历重写了entrySet()方法如下： 12345public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; //返回LinkedEntrySet return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;&#125; 1234567891011121314151617181920212223242526272829303132333435363738final class LinkedEntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; LinkedHashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new LinkedEntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return Spliterators.spliterator(this, Spliterator.SIZED | Spliterator.ORDERED | Spliterator.DISTINCT); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; if (action == null) throw new NullPointerException(); int mc = modCount; for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) action.accept(e); if (modCount != mc) throw new ConcurrentModificationException(); &#125;&#125; 最终的的EntryIterator: 1234final class LinkedEntryIterator extends LinkedHashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051abstract class LinkedHashIterator &#123; //下一个节点 LinkedHashMap.Entry&lt;K,V&gt; next; //当前节点 LinkedHashMap.Entry&lt;K,V&gt; current; int expectedModCount; LinkedHashIterator() &#123; //初始化时，next 为 LinkedHashMap内部维护的双向链表的扁头 next = head; //记录当前modCount，以满足fail-fast expectedModCount = modCount; //当前节点为null current = null; &#125; //判断是否还有next public final boolean hasNext() &#123; //就是判断next是否为null，默认next是head 表头 return next != null; &#125; //nextNode() 就是迭代器里的next()方法 。 //该方法的实现可以看出，迭代LinkedHashMap，就是从内部维护的双链表的表头开始循环输出。 final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123; //记录要返回的e。 LinkedHashMap.Entry&lt;K,V&gt; e = next; //判断fail-fast if (modCount != expectedModCount) throw new ConcurrentModificationException(); //如果要返回的节点是null，异常 if (e == null) throw new NoSuchElementException(); //更新当前节点为e current = e; //更新下一个节点是e的后置节点 next = e.after; //返回e return e; &#125; //删除方法 最终还是调用了HashMap的removeNode方法 public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125;&#125; 值得注意的就是：nextNode() 就是迭代器里的next()方法 。该方法的实现可以看出，迭代LinkedHashMap，就是从内部维护的双链表的表头开始循环输出。而双链表节点的顺序在LinkedHashMap的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。 总结LinkedHashMap相对于HashMap的源码比，是很简单的。因为大树底下好乘凉。它继承了HashMap，仅重写了几个方法，以改变它迭代遍历时的顺序。这也是其与HashMap相比最大的不同。在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。 accessOrder ,默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。为true时，可以在这基础之上构建一个LruCache. LinkedHashMap并没有重写任何put方法。但是其重写了构建新节点的newNode()方法.在每次构建新节点时，将新节点链接在内部双向链表的尾部 accessOrder=true的模式下,在afterNodeAccess()函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。值得注意的是，afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。 nextNode() 就是迭代器里的next()方法 。该方法的实现可以看出，迭代LinkedHashMap，就是从内部维护的双链表的表头开始循环输出。而双链表节点的顺序在LinkedHashMap的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。 它与HashMap比，还有一个小小的优化，重写了containsValue()方法，直接遍历内部链表去比对value值是否相等。 12codehsjsskl]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码分析]]></title>
    <url>%2F2019%2F03%2F04%2FLinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LinkedList源码分析(基于Jdk 11.0.2)LinkedList和ArrayList都是实现了List接口，这两个类也经常拿来作比较。 总体来讲，它们有以下不同： 1，ArrayList底层是数组，LinkedList底层是双向链表 2，ArrayList由于底层是数组，所以查找和修改元素快，因为它可以直接操作角标，但是增加、删除操作就慢些，因为要移动大量元素；LinkedList则恰恰相反，因为是用指针指向下一个元素，所以增删只要修改指针的指向就可以达到，而且只需要修改一个，但是LinkedList查找和修改就效率低一些，因为要定位到元素，对于LinkedList来说会慢一些(不想数组一样有下标可以直接操作) 3，LinkedList和ArrayList都不是线程安全的 12345678public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 构造函数没做什么。Node节点： 123456789101112private static class Node&lt;E&gt; &#123; //元素值 E item; Node&lt;E&gt; next;//下一个节点 Node&lt;E&gt; prev;//前一个节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 可以看出它是双向链表。 1，增加元素1234//addAll ,在尾部批量增加public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);//以size为插入下标，插入集合c中所有元素&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//以index为插入下标，插入集合c中所有元素public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index);//检查越界 [0,size] 闭区间 //检查越界 [0,size] 闭区间 Object[] a = c.toArray(); //新增元素的数量 int numNew = a.length; //如果新增元素数量为0，则不增加，并返回false if (numNew == 0) return false; //index节点的前置节点，后置节点 Node&lt;E&gt; pred, succ; //在链表尾部追加数据 if (index == size) &#123; //size节点（队尾）的后置节点一定是null succ = null; //前置节点是队尾 pred = last; &#125; else &#123; //取出index节点，作为后置节点 succ = node(index); //前置节点是，index节点的前一个节点 pred = succ.prev; &#125; //链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。对比ArrayList是通过 //System.arraycopy完成批量增加的 for (Object o : a) &#123;//遍历要添加的节点 @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);//以前置节点 和 元素值e，构建new一个新节点， if (pred == null)//如果前置节点是空，说明是头结点 first = newNode; else//否则 前置节点的后置节点设置问新节点 pred.next = newNode; pred = newNode;//当前的节点为前置节点了，为下次添加节点做准备 &#125; if (succ == null) &#123;//循环结束后，判断，如果后置节点是null。 说明此时是在队尾append的 last = pred;//则设置尾节点 &#125; else &#123; pred.next = succ;// 否则是在队中插入的节点 ，更新前置节点 后置节点 succ.prev = pred;//更新后置节点的前置节点 &#125; // 修改数量size size += numNew; //修改modCount modCount++; return true; &#125; 12345//检查index是否越界(0,size)private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 1234//如果没有越界返回trueprivate boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125; 插入单个节点12345//在尾部插入一个节点： addpublic boolean add(E e) &#123; linkLast(e); return true;&#125; 12345678910111213141516171819//生成新节点 并插入到 链表尾部， 更新 last/first 节点void linkLast(E e) &#123; //记录原尾部节点 final Node&lt;E&gt; l = last; //以原尾部节点为新节点的前置节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //更新尾部节点 last = newNode; //若原链表为空链表，需要额外更新头结点 if (l == null) first = newNode; else //否则更新原尾节点的后置节点为现在的尾节点（新节点） l.next = newNode; //链表size加1 size++; ////修改modCount modCount++;&#125; 删除节点123456public E remove(int index) &#123; //先检查index是否越界 checkElementIndex(index); //删除元素 return unlink(node(index));&#125; 12345678910111213141516171819202122232425262728293031323334E unlink(Node&lt;E&gt; x) &#123; // assert x != null; //当前节点的元素值 final E element = x.item; //当前节点的后置节点 final Node&lt;E&gt; next = x.next; //当前节点的前置节点 final Node&lt;E&gt; prev = x.prev; //如果前置节点为空(说明当前节点原本是头结点) if (prev == null) &#123; //则头结点等于后置节点 first = next; &#125; else &#123; //这里跳过了x节点 prev.next = next; x.prev = null;//将当前节点的 前置节点置空 &#125; //如果后置节点为空（说明当前节点原本是尾节点） if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; //将当前节点的 后置节点置空 x.next = null; &#125; //将当前元素值置空 x.item = null; //数量减1 size--; //修改modCount modCount++; //返回被删除的元素值 return element;&#125; ##]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kk]]></title>
    <url>%2F2019%2F03%2F04%2Fkk%2F</url>
    <content type="text"><![CDATA[支持pdf文件]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课三]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%AE%97%E6%B3%95%E8%AF%BE%E4%B8%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2019%2F03%2F04%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[java源码分析之ArrayList源码分析，ArrayList是常用的集合框架类之一。现在来先简单分析它的源码，占坑先。 构造函数12345678 /** * Constructs an empty list with an initial capacity of ten. */ 表示构建一个数组，长度为10public ArrayList() &#123; //DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个Object类型数组的引用 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 常用的方法1，添加元素 12345678public boolean add(E e) &#123; //modCount加1 modCount++; // add(e, elementData, size); return true;&#125;`` private void add(E e, Object[] elementData, int s) { // if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1;} 1grow() private Object[] grow() { return grow(size + 1);} 1grow(int minCapacity ) private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));} 1关键代码：newCapacity() private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity);} 1copyOf public static T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass());} 1copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { @SuppressWarnings(“unchecked”) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;} 123分析：以上就是add()方法走的流程，这是基于JDK 11.0.2的。简而言之就是调用无参的构造函数会创建一个大小为0的Object型数组， this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; 1而DEFAULTCAPACITY_EMPTY_ELEMENTDATA就是一个大小为0的Object数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 1在新增了一个元素的时候，逐步调用会调用到grow()函数，grow()又继续调用grow(int minCapacity)函数，grow(int minCapacity)返回一个Object类型的数组，这个数组又是怎么生成以及大小是什么呢？这时候到copyOf(T[] original, int newLength)方法：Arrays.copyOf(elementData，newCapacity(minCapacity));第一个参数先不看，第二个参数是newCapacity(minCapacity)，返回一个int型的值，这个值是多少呢？这就到了newCapacity(int minCapacity)方法，minCapacity是grow(int minCapacity)中minCapacity传入的，而grow(int minCapacity)是被grow()调用的，传入的参数是size + 1，size正是数组中元素的个数，添加第一个元素的时候size还是为0，所以这里grow(size + 1)的size为0，size + 1为1，也就是minCapacity的值为1，newCapacity(minCapacity)中的minCapacity为1，而初始化数组就是在调用newCapacity(int minCapacity)函数的时候，看代码： private int newCapacity(int minCapacity) { // overflow-conscious code //oldCapacity = 0 int oldCapacity = elementData.length; //newCapacity = 0 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //满足这个条件 if (newCapacity - minCapacity &lt;= 0) { //满足这个条件 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) //minCapacity值为1，所以这里显然返回DEFAULT_CAPACITY的值 return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity); } 1return Math.max(DEFAULT_CAPACITY, minCapacity);DEFAULT_CAPACITY的值是10，是一个常量。所以这样就生成了一个初始容量大小为10的数组。紧接着把第一个元素赋值给数组的第一个位置。 elementData[s] = e; 1这样就完成初始化了，jdk这样改进后能或多或少节约一点资源，这和HashMap初始化一样，在添加了元素才会在内存开辟空间生成默认大小的数组，一开始是生成了一个引用。比如HashMap的默认构造函数： public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted} 1并没有数组实例，只是确认了加载因子。调用了put方法添加元素进去的时候再初始化创建数组。put方法代码： public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445```final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //(tab = table) == null 为true，所以执行1处的代码 if ((tab = table) == null || (n = tab.length) == 0) // resize()， n = (tab = resize()).length;//1 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 执行resize()方法，生成一个大小为16，加载因子为0.75的Node数组。 2，删除元素123456789public E remove(int index) &#123; Objects.checkIndex(index, size); final Object[] es = elementData; @SuppressWarnings(&quot;unchecked&quot;) E oldValue = (E) es[index]; fastRemove(es, index); return oldValue;&#125; 3，修改元素12345678910public E set(int index, E element) &#123; //检查是否越界 Objects.checkIndex(index, size); //找到要覆盖的元素 E oldValue = elementData(index); //覆盖这个值 elementData[index] = element; //返回旧值 return oldValue;&#125; 查询不同修改modCount，相对于增删效率要高一些 123456public E get(int index) &#123; //检查是否越界 Objects.checkIndex(index, size); // return elementData(index);&#125; 清空元素123456public void clear() &#123; modCount++; final Object[] es = elementData; for (int to = size, i = size = 0; i &lt; to; i++) es[i] = null;&#125; 包含某个元素1234//返回一个boolean值，可知indexOf(o)的值大于等于0方法返回的值就为true，就说明包含该元素public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; indexOf方法 1234public int indexOf(Object o) &#123; // return indexOfRange(o, 0, size);&#125; indexOfRange方法 123456789101112131415161718192021222324252627//返回一个int值，从start到end范围内，对应到上面的代码就是从0到list列表的大小(size)。 int indexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; //如果o为null， if (o == null) &#123; for (int i = start; i &lt; end; i++) &#123; //注意，ArrayList是可以添加null元素的，且可以添加多个，如果列表中有null //元素，找到一个就返回，返回该元素的下标，它当然大于等于0，所以此时 //indexOfRange(o, 0, size)返回值大于等于0，走到最后indexOf(o)也是大于等 //于0，所以返回true。 if (es[i] == null) &#123; return i; &#125; &#125; &#125; //否则，也就是o不为null， else &#123; for (int i = start; i &lt; end; i++) &#123; //如果o和数组中某个元素相等，返回该元素下标，最终contains也是返回true if (o.equals(es[i])) &#123; return i; &#125; &#125; &#125; //都不满足以上条件，返回-1，小于0，所以contains方法返回false return -1;&#125; 判空这里很简单，就是看size是否为0，是就返回true，否则返回false 123public boolean isEmpty() &#123; return size == 0;&#125; 迭代器 Iterator123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95--JAVA%2F</url>
    <content type="text"><![CDATA[去年就花了几百参加了左神的算法科，现在准备找工作，于是把之前的学习总结一下push上来，这个博客会继续维护，记录自己的学习路径。先从简单的排序开始，下面总结一下几种不同的排序算法的java版本。 1，选择排序选择排序的思想：从数组中选出一个数(一般是第一个数)，然后后面的数依次与arr[0]作比较，若后面的数大于第一个数不做交换，否则就交换两个数的位置，依次进行指导后面的数到数组末尾，这样就选出了最小的数并且它在第一个位置；下一轮比较开始选第二个数参与与后面的数的比较(对应的外层循环加1，)，依次类推，指导选出第二小的数位于第二个位置….，直到数组有序。选择排序算法时间复杂度是O(n^2),这是经典算法吧，实际上在工程上几乎不用了，不过还是要学毕竟这是基础。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 //选择排序的代码1(左程云左神算法初级课代码) public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; &#125; swap(arr, i, minIndex); &#125;&#125; //选择排序的代码2 public static void selectionSort_2(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i]) &#123; swap(arr, i, j); &#125; &#125; &#125;&#125; //交换两个位置上的数public static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;&#125; //打印数组public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println();&#125; //主函数中测试代码：public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] arr = &#123;2,56,12,34,8,67,100&#125;; printArray(arr); selectionSort(arr); printArray(arr); &#125; 自己写的是selectionSort_2，感觉这样稍微更好理解一点。 2，冒泡排序冒泡排序，指每次选出最大的一个值往后沉。解释：第一次从数组中选出最大的那个值往后沉，以此类推，每一次都将这次排序的数中最大的值往后沉，知道最后有序。此后只写出主代码。这就像数一个一个往后冒，因此得名冒泡排序。方法一： 123456789101112public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int e = arr.length - 1; e &gt; 0; e--) &#123; for (int i = 0; i &lt; e; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; swap(arr, i, i + 1); &#125; &#125; &#125;&#125; 方法二： 123456789101112public static void bubbleSort_2(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int j = 0; j &lt; arr.length - 1; j++) &#123; for (int i = 0; i &lt; arr.length - j - 1; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; swap(arr, i, i + 1); &#125; &#125; &#125;&#125; 3，插入排序类似于打牌的情形，我们拿牌后都会从左到右按从小到大的方式排序。它是假设第一个数已经排好序，然后后面的数依次作比较进行排序。 12345678910public static void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; 4，堆排序先理解一下堆，大根堆和小根堆，大根堆就是堆的根节点是最大值，大根堆左子树和右子树也是大根堆；小根堆相反。 1234567891011121314151617181920212223242526272829303132333435public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i); &#125; int size = arr.length; swap(arr, 0, --size); while (size &gt; 0) &#123; heapify(arr, 0, size); swap(arr, 0, --size); &#125; &#125;public static void heapInsert(int[] arr, int index) &#123; while (arr[index] &gt; arr[(index - 1) / 2]) &#123; swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; public static void heapify(int[] arr, int index, int size) &#123; int left = index * 2 + 1; while (left &lt; size) &#123; int largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; largest = arr[largest] &gt; arr[index] ? largest : index; if (largest == index) &#123; break; &#125; swap(arr, largest, index); index = largest; left = index * 2 + 1; &#125; &#125; 1，heapInsert过程：这是建立大根堆，实际上这里是数组，不过我们常用数组来表示大根堆。建立大根堆的过程。heapInsert(arr, i);就是在0–&gt;i位置实现大根堆的代码。每加入一个数，都计算它的下标，然后与父节点(这里没有树结构，但是我们通常都用数组表示树结构，所以可以根据数组的下标模拟树结构)的值比较，比父节点大就交换，把index设置为父节点的位置，然后继续这个操作，直到不满足条件了就结束。时间复杂度是O(log(1)+…+log(n-1)+logn)=O(n)，也就是O(n)。2，heapfy过程：假设数组中有一个数变小了，记住它的位置(下标)，那调整数组让它成为大根堆的过程。这个过程就是heapfy的过程。找到该节点的左右孩子中较大的那个与它比较，若比这个变化后的节点值大，那么该值往下沉，与较大值交换。如果左右孩子中最大的点都不必index处的值大，说明已经不需要调整了，这时候break。堆排序就是，先形成一个大根堆，然后堆顶元素和最后一个元素交换，这样数组的最后一个元素就是最大值，然后对于堆来讲大小减一，而我们用最后一个数与堆顶交换，这个数肯定不是最大的，所以我们继续heapfy的过程，再形成大根堆，再把最大值与最后位置的值交换，堆的大小减一；依次类推直到堆的大小为0。这样也就完成排序了。 5，快速排序先讲荷兰国旗问题，荷兰国旗问题的引申，就是把一列数排成左边小于等于某个划分值，中间等于这个划分值，右边大于这个划分值。这就是快排partition的过程。NetherlandsFlag主代码： 1234567891011121314public static int[] partition(int[] arr, int l, int r, int p) &#123; int less = l - 1; int more = r + 1; while (l &lt; more) &#123; if (arr[l] &lt; p) &#123; swap(arr, ++less, l++); &#125; else if (arr[l] &gt; p) &#123; swap(arr, --more, l); &#125; else &#123; l++; &#125; &#125; return new int[] &#123; less + 1, more - 1 &#125;;&#125; l和r指的是从数组的l位置到数组的r位置进行partition的过程，p是指划分值。举例：p = 5，arr = {4,6，7,3}。步骤：1，先设定一个小于区域，最初小于区域没有数，小于区域的最后一个位置是-1。2，第一个数和p比较，4小于5，所以4和小于等于区域的下一个数交换，然后小于区域向右扩一个位置，在这里也就是4和4交换(因为4是第一个数)。3，下一个数为6，大于5，所以跳到下一个数。4，7大于5，跳到下一个数5，3小于5，3和小于区域后一个数交换，数组变为：{4,3,6，7}返回的是一个数组，返回的等于区域的下标。经典快排：是把最后一个数作为划分值。通过比较交换使得左部分小于等于划分值，右部分大于划分值；对于第一次划分好的两部分，左(小于等于部分)右(大于部分)部分继续分别按照同样的规则划分，知道数组整体有序。这就是经典快排。改进：利用荷兰国旗问题代码改进，等于的当左边，等于的区域放中间，大于的区域放右边。这样中间部分就不需要继续参与运算了。然后递归划分，最终整体有序。 随机快排：快排代码： 1234567891011121314151617181920212223242526272829303132public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; quickSort(arr, 0, arr.length - 1);&#125;public static void quickSort(int[] arr, int l, int r) &#123; if (l &lt; r) &#123; swap(arr, l + (int) (Math.random() * (r - l + 1)), r); int[] p = partition(arr, l, r); quickSort(arr, l, p[0] - 1); quickSort(arr, p[1] + 1, r); &#125;&#125;public static int[] partition(int[] arr, int l, int r) &#123; int less = l - 1; int more = r; while (l &lt; more) &#123; if (arr[l] &lt; arr[r]) &#123; swap(arr, ++less, l++); &#125; else if (arr[l] &gt; arr[r]) &#123; swap(arr, --more, l); &#125; else &#123; l++; &#125; &#125; swap(arr, more, r); return new int[] &#123; less + 1, more &#125;;&#125; quickSort(arr, 0, arr.length - 1);这是指从arr数组的0位置到最后位置进行快排。quickSort代码： 123456789public static void quickSort(int[] arr, int l, int r) &#123; if (l &lt; r) &#123; //随机快排 swap(arr, l + (int) (Math.random() * (r - l + 1)), r); int[] p = partition(arr, l, r); quickSort(arr, l, p[0] - 1); quickSort(arr, p[1] + 1, r); &#125;&#125; 如上代码所示，经典快排分析 1，选择最后的数作为划分值，然后用partition代码将数组划分为小于等于大于的三个区域 2，递归调用quickSort，实际上是递归调用partition方法，也就是分别对步骤1产生的左右部分进行partition的过程(这里不包含等于部分) 3，直到l小于r，递归终止随机快排随机快排实际上就是每次quickSort之前，都用数组的前面的所有数随机选一个与最后的数交换，swap(arr, l + (int) (Math.random() * (r - l + 1)), r);所以随机快排的划分值很均匀，随机快排比经典快排效率高，原因：经典快排划出来的区域很可能不是等规模的。经典快排的时间复杂度O(n^2),随机快排的时间复杂度长期期望为O(nlogn)。 6，归并排序1234567891011121314151617181920212223242526272829303132333435public static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; mergeSort(arr, 0, arr.length - 1);&#125; public static void mergeSort(int[] arr, int l, int r) &#123; if (l == r) &#123; return; &#125; int mid = l + ((r - l) &gt;&gt; 1); mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); merge(arr, l, mid, r); &#125; public static void merge(int[] arr, int l, int m, int r) &#123; int[] help = new int[r - l + 1]; int i = 0; int p1 = l; int p2 = m + 1; while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; while (p1 &lt;= m) &#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= r) &#123; help[i++] = arr[p2++]; &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i]; &#125; &#125; 7,桶排序1234567891011121314151617181920public static void bucketSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int max = Integer.MIN_VALUE; //找到数组最大值 for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); &#125; int[] bucket = new int[max + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; bucket[arr[i]]++; &#125; int i = 0; for (int j = 0; j &lt; bucket.length; j++) &#123; while (bucket[j]-- &gt; 0) &#123; arr[i++] = j; &#125; &#125;&#125; 桶排序思想：首先找到数组最大值，然后新建一个数组长度为最大值加1，也就是bucket数组，找到最大值后遍历数组，把原数组的数据放入bucket数组的下标中，也就是bucket[i]，每当有一个i加入bucket[i]的值就加1，遍历结束后，所有的数据已经加入桶中。最后遍历桶，如果bucket[i]– 大于0就说明这个桶有数据，然后排序arr[i++] = j(j是bucket数组的下标，实际上就是原数组的值)。 8，基数排序12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 11 ZGC]]></title>
    <url>%2F2019%2F03%2F02%2FJAVA-11-ZGC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法--图]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图基本概念，图结构对元素的限定更少，因此它描述应用问题的能力棍儿更强。 一、术语：G=(V;E)，两个要素，V:顶点；存在对应关系就顶点相连，这些连边构成了图的第二个要素:边集。E:边的总数。彼此之间存在这种关系并且存在连边的任何两个点，我们成为彼此邻接关系。还有一个关系：关联(顶点与某条边的关系)，注意区分邻接关系(顶点与顶点关系)。 V-V:邻接V-E:关联树也是图的特列，只是图更一般化。是否允许顶点与自己连接(为了简便暂时不考虑)。无向边：点与点之间无方向。有向边：边有方向。相对应的称为无向图和有向图。有的边有向有的没有就称为混合图，我们主要讨论有向图。如上图左图，我们说C-&gt;A-&gt;D-&gt;B(简单路径，没有重复节点)经过了一条长度为3的路径。同样如上图右图，这里我们说，C-&gt;A-&gt;B-&gt;A-&gt;D(复杂路径或者一般路径，有重复顶点)。且路径起点和终点可以重合的(这种路径我们称为环路)。有向无换图(没有任何环路)。经过所有的边一次且恰好一次的环路称为欧拉环路。经过每个顶点一次且恰好一次，称为汉密尔顿环路 二、实现：对图的接口和操作规范做一个定义： 12 邻接矩阵与关联矩阵。邻接矩阵：表示顶点之间的关系。如下图：注意：在有向边中，矩阵表示的规则是：权重写在指向的那个顶点，比如A顶点指向B顶点，权重为3，那3就是写在矩阵中A的那边。当然，无向边是对称的。至于双向边， 三、算法：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法]]></title>
    <url>%2F2019%2F03%2F01%2FLeetCode%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[LeetCode算法1，TwoSum问题给定数组arr = {2,3,5,7,12};一个target(int型，例如target=9)，求数组中两个元素之后等于target的两个元素的下表，并把它们的下标以一个二元数组的形式返回，在这题中，2 + 7等于9，也就是0下标和3下标的元素之和为9。所以返回 target_arr = {0,3};我们用打印数组元素的方式输出更直观。代码如下： 主代码(求下表数组的代码)： 123456789101112131415161718class Solution &#123; public static int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); int[] res = new int[2]; for (int i = 0; i &lt; nums.length; ++i) &#123; m.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; int t = target - nums[i]; if (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123; res[0] = i; res[1] = m.get(t); break; &#125; &#125; return res; &#125;&#125; 这里用了HashMap(哈希表结构)。主方法中调用： 123456789101112131415161718192021printArr函数代码：public static void printArr(int[] arr) &#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if (i != arr.length - 1) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; else &#123; System.out.print(arr[i] + &quot;]&quot;); &#125; &#125; System.out.println();&#125;public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] arr = &#123;2,3,5,7,12&#125;; int target = 9; int [] target_arr = Solution.twoSum(arr, target); printArr(target_arr);&#125; 注：这里有一个printArr函数，其实就是一个打印数组元素的函数，可以理解为code的定制。代码如上所示。主函数输出结果为： 1[0 3] 还有一个更直接暴力的算法，时间复杂度为O(n^2)，不过面试不要这样写，面试会直接挂的。暴力方法： 12345678910111213141516class Solution_2 &#123; public static int[] twoSum (int[] nums,int target) &#123; int[] res = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if ((nums[i] + nums[j]) == target) &#123; res[0] = i; res[1] = j; &#125; &#125; &#125; return res; &#125;&#125; 2，Three_Sum问题和原题意思差不多，不过变成了三个数相加等于target。暴力代码： 123456789101112131415161718class Solution_4 &#123; public static int[] threeSum (int[] arr,int target) &#123; int[] res = new int[3]; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; for (int j2 = j+1; j2 &lt; arr.length; j2++) &#123; if ((arr[i] + arr[j]+ arr[j2] )== target) &#123; res[0] = i; res[1] = j; res[2] = j2; &#125; &#125; &#125; &#125; return res; &#125;&#125; 3,]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java回调机制]]></title>
    <url>%2F2019%2F03%2F01%2Fjava%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在安卓与源码中，很多地方用到了回调机制，最近学习java，接触到了回调机制(CallBack)，理解它很有必要。循序渐进来理解java的回调机制。 一、普通的功能和方法调用我们用一个加法的实现功能来引出并理解回调。模拟一个低年级的小朋友去做老师布置的加法题目，简单的加法题目。比如，这里先是1+1。小明很容易就算出答案，我们也写出最简单的代码。 1234567891011121314151617181920212223242526 1 public class Student 2 &#123; 3 private String name = null; 4 5 public Student(String name) 6 &#123; 7 // TODO Auto-generated constructor stub 8 this.name = name; 9 &#125;10 11 public void setName(String name)12 &#123;13 this.name = name;14 &#125;15 16 private int calcADD(int a, int b)17 &#123;18 return a + b;19 &#125;20 21 public void fillBlank(int a, int b)22 &#123;23 int result = calcADD(a, b);24 System.out.println(name + &quot;心算:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result);25 &#125;26 &#125; 客户端代码： 12345678910 1 public class Test 2 &#123; 3 public static void main(String[] args) 4 &#123; 5 int a = 1; 6 int b = 1; 7 Student s = new Student(&quot;小明&quot;); 8 s.fillBlank(a, b); 9 &#125;10 &#125; 运行结果： 1小明心算:1 + 1 = 2 二、改进后的代码假设老师布置的是189 + 231呢？小明怎么办呢？我们假设小明没有学过三位数的加法，他最多学到来能位数的，这时小明可能要借助计算器来帮助他算。如果把计算的功能单独抽出来，并修改Student类，如下：新增一个计算器类： 12345671 public class Calculator2 &#123;3 public int add(int a, int b)4 &#123;5 return a + b;6 &#125;7 &#125; 修改后的Student类： 123456789101112131415161718192021222324252627282930313233 1 public class Student 2 &#123; 3 private String name = null; 4 5 public Student(String name) 6 &#123; 7 // TODO Auto-generated constructor stub 8 this.name = name; 9 &#125;10 11 public void setName(String name)12 &#123;13 this.name = name;14 &#125;15 16 @SuppressWarnings(&quot;unused&quot;)17 private int calcADD(int a, int b)18 &#123;19 return a + b;20 &#125;21 22 private int useCalculator(int a, int b)23 &#123;24 return new Calculator().add(a, b);25 &#125;26 27 public void fillBlank(int a, int b)28 &#123;29 int result = useCalculator(a, b);30 System.out.println(name + &quot;使用计算器:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result);31 &#125;32 &#125; 如上所示。客户端代码如下： 12345678910 1 public class Test 2 &#123; 3 public static void main(String[] args) 4 &#123; 5 int a = 189; 6 int b = 231; 7 Student s = new Student(&quot;小明&quot;); 8 s.fillBlank(a, b); 9 &#125;10 &#125; 运行结果： 1小明使用计算器:189 + 231 = 410 三、继续引出问题(老师继续出更加超纲的题)老师觉得小名很聪明，于是加大了题目的难度，如果老师继续出的题是26549 + 16487 呢？小明应该怎么办呢？小名当然可以继续用计算器算，但是不需要每次都自己算，我们可以改进一下代码:定义一个超级计算器类，超级计算器的add方法应该包含两个操作数和小明自身的引用： 12345678 public class SuperCalculator2 &#123;3 public void add(int a, int b, Student xiaoming)4 &#123;5 int result = a + b;6 xiaoming.fillBlank(a, b, result);7 &#125;8 &#125; 修改后Student代码： 12345678910111213141516171819202122232425public class Student&#123; private String name = null; public Student(String name) &#123; // TODO Auto-generated constructor stub this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void callHelp (int a, int b) &#123; new SuperCalculator().add(a, b, this); &#125; public void fillBlank(int a, int b, int result) &#123; System.out.println(name + &quot;求助小红计算:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result); &#125;&#125; 客户端代码： 12345678910public class Test&#123; public static void main(String[] args) &#123; int a = 26549; int b = 16487; Student s = new Student(&quot;小明&quot;); s.callHelp(a, b); &#125;&#125; 运行结果： 1小明求助小红计算:26549 + 16487 = 43036 执行流程为：小明通过自身的callHelp方法调用了小红（new SuperCalculator()）的add方法，在调用的时候将自身的引用（this）当做参数一并传入，小红在使用计算器得出结果之后，回调了小明的fillBlank方法，将结果填在了黑板上的空格里。灯灯灯！到这里，回调功能就正式登场了，小明的fillBlank方法就是我们常说的回调函数。通过这种方式，可以很明显的看出，对于完成老师的填空题这个任务上，小明已经不需要等待到加法做完且结果填写在黑板上才能去跟小伙伴们撒欢了，填空这个工作由超级计算器小红来做了。回调的优势已经开始体现了。 四、理解回调如果不仅仅小明需要这个计算的功能，一个小商贩(如果一位老奶奶平时卖东西，但是她不太会算数)也需要呢？我们定义一个接口，如下： 1234public interface doJob&#123; public void fillBlank(int a, int b, int result);&#125; 修改后的超级计算器 12345678public class SuperCalculator&#123; public void add(int a, int b, doJob customer) &#123; int result = a + b; customer.fillBlank(a, b, result); &#125;&#125; 修改后的Student类代码(小明的代码): 1234567891011121314151617181920212223242526272829303132public class Student&#123; private String name = null; public Student(String name) &#123; // TODO Auto-generated constructor stub this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public class doHomeWork implements doJob &#123; @Override public void fillBlank(int a, int b, int result) &#123; // TODO Auto-generated method stub System.out.println(name + &quot;求助小红计算:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result); &#125; &#125; public void callHelp (int a, int b) &#123; new SuperCalculator().add(a, b, new doHomeWork()); &#125;&#125; 小商贩的代码： 1234567891011121314151617181920212223242526272829303132public class Seller&#123; private String name = null; public Seller(String name) &#123; // TODO Auto-generated constructor stub this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public class doHomeWork implements doJob &#123; @Override public void fillBlank(int a, int b, int result) &#123; // TODO Auto-generated method stub System.out.println(name + &quot;求助小红算账:&quot; + a + &quot; + &quot; + b + &quot; = &quot; + result + &quot;元&quot;); &#125; &#125; public void callHelp (int a, int b) &#123; new SuperCalculator().add(a, b, new doHomeWork()); &#125;&#125; 客户端代码： 123456789101112131415public class Test&#123; public static void main(String[] args) &#123; int a = 56; int b = 31; int c = 26497; int d = 11256; Student s1 = new Student(&quot;小明&quot;); Seller s2 = new Seller(&quot;老婆婆&quot;); s1.callHelp(a, b); s2.callHelp(c, d); &#125;&#125; 运行结果： 12小明求助小红计算:56 + 31 = 87老婆婆求助小红算账:26497 + 11256 = 37753元 以上就是回调的整个过程，也就是从计算加法引申出来。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java，回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus浅析]]></title>
    <url>%2F2019%2F02%2F28%2FEventBus%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[事件总线EventBus为了简化并提高在activity、Fragment、Thread和Service之间的通信，同时解决组件之间的高耦合的同时仍然能继续高效地通信，事件总线设计出现了。著名的开源框架有EventBus和otto，我们先来解析EventBus。 一、EventBus简介EventBus是针对Android优化的发布–订阅事件总线。它简化了应用程序内各组件、组件与后台线程间的通信。优点是开销小、代码优雅。以及将发布者和订阅者解耦。我们知道在平时的开发中Activity和Activity的交互还好说，但是Fragment与Fragment之间的交互就复杂的多。这时候我们会用广播来处理，但是使用广播效率也不高。 二、使用EventBusEventBus的三要素和它的四中ThreadMode。三要素： a,Event：事件，可以是任意类型的对象 b,Subscriber:事件订阅者。在EventBus 3.0之前消息处理方式只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，分别代表四种线程模型。在EventBus 3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型(默认为POSTING)。 c,Publisher:事件发布者。可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法，可以自己实例化EventBus对象，但一般使用EventBus.getDefault()就可以。根据post函数参数的类型，会自动调用订阅相应类型事件的函数。 四种ThreadMode(线程模型)。四模型： 1,POSTING(默认)：该模型下，该事件是在哪个线程发布出来的，事件处理函数就会在哪个线程中运行，也就是说事件发布和订阅事件在同一个线程中。在此模型状态下应该注意尽量避免处理函数中执行耗时操作，因为它会阻塞事件的传递，甚至引起ANR。 2，MAIN:事件处理在UI线程，事件处理事件不能太长，否则会引起ANR。 3，BACKGROUND:此模式下，若事件是从UI线程发出来的，那么事件处理函数就会在新的线程中运行：若本来就是在子线程中发布出来的，那么该事件处理函数就直接在发布事件的线程执行。在此事件处理函数中禁止进行UI操作。 4，ASYNC：此模式下，无论在哪个线程发布事件，该事件处理函数都会在新建的子线程中进行，同样，事件处理函数也禁止进行UI更新操作。 2.1 EventBus的用法分为步骤： 1，自定义一个事件类 123public class MessageEvent &#123;&#125; 2，在需要订阅的地方注册事件： 1Event.getDefault().rigister(this); 3,发送事件 1EventBus.getDefault().post(messageEvent); 4,处理事件 1234@Subscribe (tthreadMode = Thread.MAIN)public void XXX (MessageEvent messageEvent) &#123; //code&#125; 5，取消订阅事件 1Event.getDefault().unregister(this); 注：消息方法可以随意取名，但是需要添加一个注解@Subscribe,并且要指定线程模型(默认为POSTING)。 2.2 EventBus应用举例2.2.1 添加依赖库 1implementation &apos;org.greenrobot:eventbus:3.1.1&apos; 现在已经更新到3.1.1版本。2.2.1 定义消息类事件 12345678910111213141516public class MessageEvent &#123; private String message; public MessageEvent(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 2.2.3 注册和取消订阅 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; private TextView tv_message; private Button bt_message; private Button bt_subscription; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_message = this.findViewById(R.id.tv_message); tv_message.setText(&quot;MainActivity&quot;); bt_subscription = this.findViewById(R.id.bt_subscription); bt_subscription.setText(&quot;注册事件&quot;); bt_message = this.findViewById(R.id.bt_message); bt_message.setText(&quot;跳转到secondactivity&quot;); bt_message.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,SecondActivity.class)); &#125; &#125;); bt_subscription.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //注册事件 EventBus.getDefault().register(MainActivity.this); &#125; &#125;); &#125; //事件处理者处理事件 @Subscribe(threadMode = ThreadMode.MAIN) public void onMoonEvent(MessageEvent messageEvent)&#123; tv_message.setText(messageEvent.getMessage()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125; &#125; 我们定义了两个Button和TextView，Button用来注册和跳转到另一个Activity，TextView用来显示内容。2.2.4 事件订阅者处理事件在MainActivity中定义方法来处理事件，在这里因为ThreadMode为MAIN，事件的处理会在UI线程中执行，用TextView来展示收到的信息。 1234@Subscribe(threadMode = ThreadMode.MAIN) public void onMoonEvent(MessageEvent messageEvent)&#123; tv_message.setText(messageEvent.getMessage()); &#125; 2.2.5 事件发布者发布事件SecondActivity中的代码如下所示： 123456789101112131415161718192021222324public class SecondActivity extends AppCompatActivity &#123; private Button bt_message; private Button bt_message1; private TextView tv_message; @Override public void onCreate( Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sec); tv_message = findViewById(R.id.tv_message); tv_message.setText(&quot;SecondActivity&quot;); bt_message = findViewById(R.id.bt_message); bt_message.setText(&quot;发送事件&quot;); bt_message.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; EventBus.getDefault().post(new MessageEvent(&quot;欢迎&quot;)); finish(); &#125; &#125;); &#125;&#125; 在SecondActivity中，定义”发送事件”来发送事件并将SecondActivity finish掉，运行程序，如下图所示。接下来点击”注册事件”按钮来注册事件，然后点击下面的按钮跳转到SEcondActivity，这时候跳转到SecondActivity，如下图所示，接下来点发送事件按钮，这是SecondActivity会被finish掉，这时候MainActivity的TextView会显示”欢迎”。注：以上代码是这个程序后续都写好了运行截图的，所以后续的黏性事件的代码也显示了，懒得改了 2.3 EventBus的粘性事件EventBus还支持发送黏性事件，就是在发送事件之后再订阅该事件也能收到该事件，这类似黏性广播。我们看怎么修改代码。 2.3.1 订阅者处理黏性事件在MainActivity中写一个方法来处理黏性事件。 12345代码位于MainActivity中@Subscribe(threadMode = ThreadMode.POSTING,sticky = true) public void ononMoonSticky (MessageEvent messageEvent) &#123; tv_message.setText(messageEvent.getMessage()); &#125; 2.3.2 发送黏性事件12345678代码位于SecondActivity中bt_message1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; EventBus.getDefault().postSticky(new MessageEvent(&quot;粘性事件&quot;)); finish(); &#125;&#125;); 运行代码，我们在MainActivity没有点注册按钮，而是直接进入到SecondActivity中，然后选择发送黏性事件，这时回到MainActivity，我们看到在MainActivity仍然显示”MainActivity”，点击”注册事件”，TextView内容发生了变化，显示”黏性事件”，说明黏性事件被接收到了。 三、源码解析EventBus3.1 EventBus构造方法EventBus.getDefault()方法，可以看到这是一个经典的单例模式，还是DCL单例。 12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; 再看EventBus()构造函数： 123public EventBus() &#123; this(DEFAULT_BUILDER);&#125; DEFAULT_BUILDER是默认的EventBusBuilder，用来构造EventBus。这里this是调用了Eventbus的另一个有一个参数的构造方法。我们再看这个有一个DEFAULT_BUILDER参数的构造方法。 1234567891011121314151617181920EventBus(EventBusBuilder builder) &#123; logger = builder.getLogger(); subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadSupport = builder.getMainThreadSupport(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; 可以看到，我们可以通过一个EventBusBuilder来构造EventBus，这里应用了建造者模式。 3.2 订阅者注册获取EventBus实例后，便可以将订阅者注册到EventBus中，看rigister方法。 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);//1 synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod);//2 &#125; &#125;&#125; 对于以上代码解析： 1，查找订阅者的订阅方法在注释1处的findSubscriberMethods方法找出一个SubscribeMethod集合，也就是传进来的订阅者的所有订阅方法，接下来遍订阅者历所有的订阅方法来完成订阅者的注册操作。register做了两件事：一是查找订阅者的订阅方法，二是订阅者的注册，SubscriberMethod类用来保存订阅方法的Method对象、线程模型、事件类型、优先级、是否是黏性事件一系列属性。findSubscriberMethods代码： 12345678910111213141516171819List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);//1 if (subscriberMethods != null) &#123; return subscriberMethods; &#125; if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass);//3 &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods);//2 return subscriberMethods; &#125; &#125; findUsingInfo方法,在项目中通常是通过EventBus单例模式来获取默认的EventBus对象，也就是ignoreGeneratedIndex为false的情况，这时候就会调用findUsingInfo方法。 12345678910111213141516171819private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState);//1 if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();//2 for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; findUsingReflectionInSingleClass(findState);//3 &#125; findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; 注释1处：通过getSubscriberInfo方法获取订阅者的信息，在开始查找订阅方法的时候并没有忽略注释器为我们生成的索引MyEvenBusIndex。如果我们通过EventBusBuilder配置了MyEvenBusIndex，便会获取subscriberInfo。就会调用subscriberInfo的getSubscriberMethods方法，获取订阅方法相关的信息；若没有配置MyEvenBusIndex，就执行3处的findUsingReflectionInSingleClass方法，将订阅方法保存到findState中。最后通过getMethodsAndRelease方法对dindState做回收处理并返回订阅的List集合。默认是没有配置MyEvenBusIndex的，所以看看findUsingReflectionInSingleClass的代码 12345678910111213141516171819202122232425262728293031323334353637private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; //通过反射来获取订阅者中所有方法 // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125; &#125; 2，订阅者的注册过程在rigister方法中，在注释2处调用了subscribe方法来对订阅方法进行注册，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 // Must be called in synchronized blockprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod);//1 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);//2 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //判断订阅者是否已经注册 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; //对黏性事件的处理 // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 3.3 事件的发送获取EventBus对象后，可以通过post方法来进行事件的提交。post源码： 123456789101112131415161718192021222324public void post(Object event) &#123; //PostingThreadState保存着事件队列和线程状态信息 PostingThreadState postingState = currentPostingThreadState.get(); //获取事件队列，并将当前事件插入事件队列 List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = isMainThread(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; try &#123; //处理队列中的所有事件 while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 分析：首先从PostingThreadState对象中取出事件队列，然后再讲当前的事件插入事件队列。最后将队列中的事件一次交由postSingleEvent方法处理，并移除该事件。之后看postSingleEvent方法里做了什么：postSingleEvent 12345678910111213141516171819202122232425private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; //eventInheritance表示是否向上查找事件的父类，默认为true if (eventInheritance) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; //找不到该事件时的异常 if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125; eventInheritance表示是否向上查找事件的父类，它的默认值是true，可以通过在EventBusBuilder中进行配置。当eventInheritance为true，则通过lookupAllEventTypes找到所有父类事件并存在List中，然后通过postSingleEventForEventType方法逐一处理，postSingleEventForEventType代码： 12345678910111213141516171819202122232425262728private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; //同步取出该事件对应的Subscription(订阅对象集合) subscriptions = subscriptionsByEventType.get(eventClass);//1 &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123;//2 //处理Subscription，将事件event和Subscription(订阅对象)传递给postingState并调用postToSubscription方法对事件进行///处理 postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 注释1处同步取出该事件对应的Subscription(订阅对象集合)，注释2处处理Subscription，将事件event和Subscription(订阅对象)传递给postingState并调用postToSubscription方法对事件进行，接下来看postToSubscription源码：postToSubscription： 12345678910111213141516171819202122232425262728293031323334private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125;&#125; 取出订阅者的threadMode之后,根据threadMode来分别处理，若threadMode是MAIN，则通过反射直接运行订阅的方法；若不是主线程，则需要mainThreadPoster将我们的订阅事件添加到主线程队列中。mainThreadPoster是HandlerPoster类型的，继承自Handler，通过Handler将订阅的方法切换到主线程。 3.4 订阅者取消注册unrigister方法： 123456789101112/** Unregisters the given subscriber from all event classes. */ public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);//1 if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType);//2 &#125; typesBySubscriber.remove(subscriber);//3 &#125; else &#123; logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass()); &#125; &#125; typesBySubscriber是一个map集合，注释1处通过subscriber找到subscribedTypes(事件类型集合)。注释3处将subscriber对应的eventType从typesBySubscriber中移除。注释2处遍历subscribedTypes，并调用unsubscribeByEventType方法：unsubscribeByEventType源码： 12345678910111213141516/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */ private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);//1 if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125; &#125; 注释1处通过eventType来得到对应的Subscription(订阅对象集合)，并在for循环中判断如果Subscription(订阅对象)的subscriber属性等于传进来的subscriber，则从Subscription中移除该Subscription。这就是EventBus的源码]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>开源框架，安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[示例]]></title>
    <url>%2F2019%2F02%2F26%2F%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[来点音乐： 不知道为什么，下面的视频只能在手机上用浏览器看，电脑上看就是一片空白。]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>游玩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例的几种写法及浅析]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E5%8F%8A%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在Android中我们常用到单例模式，所以深刻理解单例模式很有必要。在面试中也经常被问到。 单例定义：保证一个类仅有一个实例，并提供一个访问它的全局方法。UML图1,饿汉模式 12345678public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125;//私有化构造函数 public static Singleton getInstance() &#123; return singleton; &#125;&#125; 饿汉模式是在类的加载时就完成了初始化，所以加载较慢，但获取对象的速度快。是基于类加载机制避免了线程同步问题，但是也不能完全避免多线程问题(或其他的静态方法)导致类被加载。这时候初始化并没有达到懒加载的效果。2，懒汉模式(线程不安全) 1234567891011public class Singleton &#123; private static Singleton singleton = null; private Singleton()&#123;&#125;//私有化构造函数 public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 这是懒汉加载模式，先申明一个静态对象(也就是先不实例化)，在客户端调用的时候才初始化，这样节约了资源，但是初次加载需要实例化，反应稍慢一点，并且不是线程安全的。3，懒汉模式(线程安全) 1234567891011public class Singleton &#123; private static Singleton singleton = null; private Singleton()&#123;&#125;//私有化构造函数 public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 这种方式是线程安全的，但是每次调用getInstance()方法的时候都要进行同步操作，造成不必要的同步开销，所以这种方式不建议使用。4，双重检查机制(DCL模式) 123456789101112131415public class Singleton &#123; private volatile static Singleton singleton = null;//volatile关键字 private Singleton()&#123;&#125;//私有化构造函数 public static Singleton getInstance() &#123; if (singleton == null) &#123;//为了避免不必要的同步 synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这里在getInstance()方法进行了两次判空，第一次是为了不必要的同步，第二次是在singleton实例为空的时候才创建实例，这里使用了volatile关键字，从这里可以看到DCL模式也是volatile使用的场景之一。volatile或多或少会影响性能，不过在程序的正确运行面前这点消耗还是值得的。DCL优点是资源利用率高，第一次执行getInstance()时单例对象才被实例化，效率高。缺点是：第一次加载时反应稍慢，在高并发情况下也有一定的缺陷，虽然发生概率小。DCL在一定程度上解决了资源的消耗和多余的同步，线程安全等问题。但是它还是在某些情况会出现失效的问题，也就是DCL失效，在《java并发编程实践》中作者建议我们使用静态内部类单例模式来替代DCL。5，静态内部类单例模式 12345678910public class Singleton &#123; private Singleton()&#123;&#125;//私有化构造函数 public static Singleton getInstance() &#123; return SingleHolder.sSingleton; &#125; private static class SingletonHolder &#123; private static final Singleton sSingleton = new Singleton(); &#125;&#125; 第一次加载Singleton类时不会初始化sSingleton，只会在第一次调用getInstance方法的时候虚拟机加载SingletonHolder初始化sSingleton，这样不仅能够确保线程安全也能保证Singleton类的唯一性，所以推荐使用。6，枚举单例 123456public enum Singleton &#123; INSTANCE; public void doSomething() &#123; &#125;&#125; 默认的枚举实例的创建时线程安全的，并且在任何情况下都是单例，上述的几种单例中，有一种情况下会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘中再读回来，从而获得了一个实例。反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化重新生成对象，要加入如下方法： 123private Object readResolve () throws ObjectStreamException &#123; return singleton;&#125; 枚举单例的优点是简单，但是大部分应用开发很少用到它，因为这样会使程序的可读性变低，不建议用。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调栈结构]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目：给定一个数组(不含重复值)，找到每一个位置i的左边和右边离i最近且值比arr[i]小的位置，返回所有值。举例：有数组 arr = {3,4,1,5,6,2,7};那么返回的信息就是[{-1,2}，{0,2}，{-1，-1}，{2,5}，{3,5}，{2,-1}，{5，-1}]。这里返回的是二维数组。-1表示不存在。 进阶问题：若arr可能有重复值，找到每个位置i左边和右边的离i最近的且比arr[i]小的位置。 要求：arr长度为n，实现原问题和进阶问题的解法，时间复杂度为O(N)。先看暴力解法，思路较简单，T(n) = O(n*n),每个位置分别向左和向右遍历一下，总可以确定。代码如下：123456789101112131415161718192021222324252627public static int[][] rightway(int[] arr) &#123; int[][] res = new int[arr.length][2]; for (int i = 0; i &lt; arr.length; i++) &#123; int leftLessIndex = -1; int rightLessIndex = -1; int cur = i - 1; while (cur &gt;= 0) &#123; if (arr[cur] &lt; arr[i]) &#123; leftLessIndex = cur; break; &#125; cur--; &#125; cur = i + 1; while (cur &lt; arr.length) &#123; if (arr[cur] &lt; arr[i]) &#123; rightLessIndex = cur; break; &#125; cur++; &#125; res[i][0] = leftLessIndex; res[i][0] = rightLessIndex; &#125; return res;&#125; 单调栈结构解决原问题： 1，准备一个栈，记为stack,栈中放数组的位置，开始stack为空，如果找到每一个i位置左边和右边离i位置最近的且比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是严格递减的；如果找到每一个i位置左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是严格递增的。我们讨论前者，实际上这两种情况原理一样。 下面举例说明这个问题：初始时arr={3,4,1,5,6,2,7};stack从栈顶到栈底为{}(意思是为空)。 1，遍历到arr[0] = 3，stack为空，直接放入0位置。stack从栈顶到栈底为{0位置(值为3)}; 2，遍历到arr[1] = 4，发现直接放入1位置不会破坏stack要求的特性，直接放入1位置。stack从栈顶到栈底为{1位置(值是4)、0位置(值为3)}; 2，遍历到arr[2] = 1，发现直接放入2位置会破坏stack要求的特性，从stack开始弹出位置，如果x位置被弹出，在栈中位于x下面的的位置，就是x位置左边离x位置最近且比arr[x]小的位置；当前遍历到的位置就是x位置右边离x位置最近且比arr[x]小的位置。从stack中弹出1，在栈中位于1位置下面的是位置0，当前遍历到的位置是2，所以ans[1] = {0,2}。弹出1位置后，发现放入2位置(值是1)还会破坏规则，所以继续弹出位置，这次弹出位置0。在栈中位于位置0下面已经没有位置了，说明在位置0左边不存在比arr[0]小的值，当前遍历到的位置是位置2，所以ans[0] = {-1,2}。stack已经为空，所以放入2位置(值为1)，stack从栈顶到栈底为：{2位置{值是1}};…. 以此类推，得到ans[4] = {3,5},ans[3] = {2,5},ans[6] = {5,-1},ans[5] = {2,-1},ans[2] = {-1,-1}。 简单证明单调栈中，如果x位置被弹出，在栈中位于x位置下面的位置为什么就是x位置左边离x位置最近且比arr[x]小的位置 答：如果x位置被弹出，在栈中位于x位置下面的位置为什么就是x位置左边离x位置最近且值比arr[x]小的位置；当前遍历到的位置就是x位置右边离x位置最近且比arr[x]小的位置。假设stack当前栈顶位置是x，值是5；x下面是i位置，值是1；当前遍历到j位置，值是4。整个栈是没有重复值的。当前遍历到j位置，但是x位置已经在栈中，所以x位置肯定在j位置的左边。如果5和4之间存在小于5的数，那么没等遍历到当前的4，x位置(值是5)就已经被弹出了，轮不到当前的4来让x位置的5弹出，所以5和4之间的数要么没有，要么一定比5大，所以x位置右边离x位置最近且小于arr[x]的位置就是j位置。 当前弹出的是x位置，x位置下面是位置i，i比x早进栈，所以i的位置肯定在x位置的左边；如果在1和5之间存在小于1的数，那么i位置(值为1)会被提前弹出，在栈中i位置和x位置就不可能贴在一起，如果在1和5之间存在大于1但小于5的数，那么在栈中i位置和x位置之间一定会夹上一个别的位置，也不可能贴在一起，所以1和5之间的数要么没有，要么一定大于5，那么x位置左边离x位置最近且小于arr[x]的位置就是i位置。 证明结束，整个流程中，每个位置都进栈一次、出栈一次，所以整个流程的时间复杂度是O(n)，看如下的getNearLessNoRepeat方法。 12345678910111213141516171819202122class Solution &#123; public int[][] getNearLessNoRepeat(int[] arr) &#123; int[][] res = new int[arr.length][2]; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123; int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = i; &#125; stack.push(i); &#125; while (!stack.isEmpty()) &#123; int popIndex = stack.pop(); int leftLessIndex = stack.isEmpty() ? -1 : stack.peek(); res[popIndex][0] = leftLessIndex; res[popIndex][1] = -1; &#125; return res; &#125;&#125; 进阶问题，可能含有重复的数组使用单调栈，其实过程和原问题的解法差不多。全过程看如下代码： 12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之ArrayMap]]></title>
    <url>%2F2019%2F01%2F25%2FAndroid%E4%B9%8BArrayMap%2F</url>
    <content type="text"><![CDATA[参考Android达摩院的ArrayMap文章。ArrayMap是Android中存储的一个数据结构。是Android专门针对内存优化而设计的，用于取代Java API中的HashMap。为了进一步优化key是int类型的Map，Android再次提供了效率更高的数据结构SparseArray，可避免自动装箱过程。对于key为其他类型则使用ArrayMap。HashMap的get和put方法的时间复杂度是O(1)是以牺牲大量内存为代价而才得以实现的，SparseArray和ArrayMap性能略低于HashMap，但是更节省内存，用在移动端是权衡的结果。 一、ArrayMap源码分析1.1 基本成员变量1234567891011121314151617181920212223public final class ArrayMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; private static final boolean CONCURRENT_MODIFICATION_EXCEPTIONS = true; //默认的容量的最小值 private static final int BASE_SIZE = 4; //缓存数组的上限 private static final int CACHE_SIZE = 10; //用于缓存大小为4的ArrayMap static Object[] mBaseCache; static int mBaseCacheSize; //用于缓存大小为8的ArrayMap static Object[] mTwiceBaseCache; static int mTwiceBaseCacheSize; final boolean mIdentityHashCode; //由key的hashcode所组成的数组 int[] mHashes; //由key-value对所组成的数组，是mHashes的两倍 Object[] mArray; //成员变量的个数 int mSize;&#125; 1,ArrayMap对象的存储格式如下图所示： mHashes是一个记录所有key的hashcode值组成的数组，是从升序排序 mArray是一个记录着所有key-value键值对所组成的数组 mSize:记录ArrayMap对象中有多少对数据，put或append方法时，mSize会加1，执行remove则减1。mSize往往小于mHashes.length，如果mSize大于或等于mHashes.length，则说明mHashes和mArray需要扩容。 2，ArrayMap中还有两个很重要的成员变量mBaseCache和mTwiceBaseCache，用于ArrayMap所在进程的全局缓存功能。 mBaseCache：用于缓存大小为4的ArrayMap，mBaseCacheSize记录着当前已缓存的数据，超过10个就不在缓存 mTwiceBaseCache：用于缓存大小为8的ArrayMap，mTwiceBaseCache记录着当前已缓存的数量，超过10个则不再缓存ArrayMap用两个大小为10的缓存队列来分别保存大小为4和8的Map对象。为了节省内存有更加保守的内存扩容和内存收缩策略。我们来看看ArrayMap缓存和扩容机制。1.2 ArrayMap缓存机制ArrayMap是专门为Android优化而设计的Map对象，使用比较高频，很多场景可能起初都是数据很少，为了减少频繁地创建和回收，特意设计了两个缓存池，分别缓存大小为4和8的ArrayMap对象。要理解缓存机制，就需要看内存是怎么分配(allocArrays)和内存释放(freeArrays)。1.2.11234567891011121314151617181920212223242526272829303132228 private static void freeArrays(final int[] hashes, final Object[] array, final int size) &#123;229 if (hashes.length == (BASE_SIZE*2)) &#123;230 synchronized (ArrayMap.class) &#123; 当大小为8的缓存池数量小于10个，则将其放入缓存池231 if (mTwiceBaseCacheSize &lt; CACHE_SIZE) &#123;232 array[0] = mTwiceBaseCache;//arr[0]指向原来的缓存池233 array[1] = hashes;234 for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123;235 array[i] = null;//清空其它数据236 &#125;237 mTwiceBaseCache = array;//mTwiceBaseCache指向新加入缓存池的Array238 mTwiceBaseCacheSize++;239 if (DEBUG) Log.d(TAG, &quot;Storing 2x cache &quot; + array240 + &quot; now have &quot; + mTwiceBaseCacheSize + &quot; entries&quot;);241 &#125;242 &#125;243 &#125; else if (hashes.length == BASE_SIZE) &#123;//当释放的是大小为4的对象，原理同上244 synchronized (ArrayMap.class) &#123;245 if (mBaseCacheSize &lt; CACHE_SIZE) &#123;246 array[0] = mBaseCache;247 array[1] = hashes;248 for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123;249 array[i] = null;250 &#125;251 mBaseCache = array;252 mBaseCacheSize++;253 if (DEBUG) Log.d(TAG, &quot;Storing 1x cache &quot; + array254 + &quot; now have &quot; + mBaseCacheSize + &quot; entries&quot;);255 &#125;256 &#125;257 &#125;258 &#125; 如上代码就是freeArrays方法的代码，最初mTwiceBaseCacheSize和mBaseCacheSize缓存池中都没有数据，在freeArrays释放内存时，如果同时满足释放的Arrays大小等于4或8，且对应的缓存池个数未达上限，则会把该array加入到缓存池中。加入的方法时将数组array的0角标元素指向原有的缓存池，1角标元素指向hashes数组的地址，arr[2]元素以后的数据全部为null。再把缓存池的头部指向最新的array的位置，并将该缓存池大小执行加1操作。freeArrays触发时机 当执行removeAt()移除最后一个元素的情况 当执行clear()清理的时候 当执行ensureCapacity()在当前容量小于预期容量的时候，先执行allocArrays函数，再执行freeArrays函数 当执行put()在容量满的时候，先执行allocArrays，再执行freeArrays1.2.2allocArrays()函数代码12345678910111213141516171819202122232425262728293031323334353637190 private void allocArrays(final int size) &#123;191 if (mHashes == EMPTY_IMMUTABLE_INTS) &#123;192 throw new UnsupportedOperationException(&quot;ArrayMap is immutable&quot;);193 &#125;194 if (size == (BASE_SIZE*2)) &#123;//当分配大小为8的对象，先查看缓存池195 synchronized (ArrayMap.class) &#123;196 if (mTwiceBaseCache != null) &#123;//当缓存池不为空时197 final Object[] array = mTwiceBaseCache;198 mArray = array;//从缓存中取出mArray199 mTwiceBaseCache = (Object[])array[0];//将缓存池指向上一条缓存地址200 mHashes = (int[])array[1];//从缓存中mHashes201 array[0] = array[1] = null;202 mTwiceBaseCacheSize--;//缓存池大小减1203 if (DEBUG) Log.d(TAG, &quot;Retrieving 2x cache &quot; + mHashes204 + &quot; now have &quot; + mTwiceBaseCacheSize + &quot; entries&quot;);205 return;206 &#125;207 &#125;208 &#125; else if (size == BASE_SIZE) &#123;////当分配的是大小为4的对象，原理同上209 synchronized (ArrayMap.class) &#123;210 if (mBaseCache != null) &#123;211 final Object[] array = mBaseCache;212 mArray = array;213 mBaseCache = (Object[])array[0];214 mHashes = (int[])array[1];215 array[0] = array[1] = null;216 mBaseCacheSize--;217 if (DEBUG) Log.d(TAG, &quot;Retrieving 1x cache &quot; + mHashes218 + &quot; now have &quot; + mBaseCacheSize + &quot; entries&quot;);219 return;220 &#125;221 &#125;222 &#125; //分配除了4和8之外大小对象的情况，则直接创建新的数组223 mHashes = new int[size];225 mArray = new Object[size&lt;&lt;1];226 &#125; allocArrays分配内存时，如果所需分配的大小等于4或8，且相应的缓存池不为空，则会从相应的缓存池中取出]]></content>
      <categories>
        <category>安卓 数据结构</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射机制学习]]></title>
    <url>%2F2019%2F01%2F12%2Fjava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、反射机制的定义JAVA反射机制是在运行状态_中，对于任意一个类 (class文件)，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 动态获取类中信息，就是java反射，可以理解为对类的解剖。要想要对字节码文件进行解剖，必须要有字节码文件对象。获取class对象有三种方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//方式一，这种方式实际上一般不会用，因为要明确具体的类并创建对象，如果这样就直接可以调用类的方法//和变量了。 /* * 获取字节码对象的方式： * 1，Object类中的getClass()方法的。 * 想要用这种方式，必须要明确具体的类，并创建对象。 * 麻烦 . * */ public static void getClassObject_1()&#123; Person p = new Person(); Class clazz = p.getClass(); Person p1 = new Person(); Class clazz1 = p1.getClass(); //结果为true，说明clazz和clazz1是同一个字节码对象 System.out.println(clazz==clazz1); &#125; /* * 方式二： * 2，任何数据类型都具备一个静态的属性.class来获取其对应的Class对象。 * 相对简单，但是还是要明确用到类中的静态成员。 * 还是不够扩展。 * */ public static void getClassObject_2() &#123; Class clazz = Person.class; Class clazz1 = Person.class; //还是返回true System.out.println(clazz==clazz1); &#125; /* * 方式三： * 只要通过给定的类的 字符串名称就可以获取该类，更为扩展。 * 可是用Class类中的方法完成。 * 该方法就是forName. * 这种方式只要有名称即可，更为方便，扩展性更强。 */ public static void getClassObject_3() throws ClassNotFoundException &#123; String className = &quot;bean.Person&quot;; Class clazz = Class.forName(className); // 打印 &quot;class bean.Person&quot;，Person类在bean文件夹下 System.out.println(clazz); &#125; 以上三种方式中第三种方式最常见。接下来看看得到字节码文件后创建对象的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Person类class Person &#123; private int age; private String name; public Person(String name,int age) &#123; this.age = age; this.name = name; &#125; public Person() &#123; &#125; public void show()&#123; System.out.println(name+&quot;...show run...&quot;+age); &#125; private void privateMethod()&#123; System.out.println(&quot; method run &quot;); &#125; public void paramMethod(String str,int num)&#123; System.out.println(&quot;paramMethod run.....&quot;+str+&quot;:&quot;+num); &#125; public static void staticMethod()&#123; System.out.println(&quot; static method run......&quot;); &#125;&#125;//方式一String name = &quot;bean.Person&quot;;//找寻该名称类文件，并加载进内存，并产生Class对象。Class clazz = Class.forName(name);//如何产生该类的对象呢？Object obj = clazz.getDeclaredConstructor().newInstance();//方式二String name = &quot;bean.Person&quot;;//找寻该名称类文件，并加载进内存，并产生Class对象。Class clazz = Class.forName(name);//获取到了指定的构造函数对 象。Constructor constructor = clazz.getConstructor(String.class,int.class);//通过该构造器对象的newInstance方法进行对象的初始化。Object obj = constructor.newInstance(&quot;小明&quot;,38); 获取字节码文件中的字段 123456789101112131415 Class clazz = Class.forName(&quot;bean.Person&quot;); Field field = null;//clazz.getField(&quot;age&quot;);//只能获取公有的， field = clazz.getDeclaredField(&quot;age&quot;);//只获取本类，但包含私有。 //对私有字段的访问取消权限检查。暴力访问。 field.setAccessible(true); Object obj = clazz.getDeclaredConstructor().newInstance(); field.set(obj, 89); Object o = field.get(obj); //打印结果为89 System.out.println(o);// bean.Person p = new cn.itcast.bean.Person();// p.age = 30; // 89 获取指定Class中的所有公共函数。 123456789101112Class clazz = Class.forName(&quot;bean.Person&quot;);Method[] methods = clazz.getMethods();//获取的都是公有的方法。 methods = clazz.getDeclaredMethods();//只获取本类中所有方法，包含私有。 for(Method method : methods)&#123; System.out.println(method);&#125;//public void bean.Person.show()public void bean.Person.paramMethod(java.lang.String,int)public static void bean.Person.staticMethod()private void bean.Person.privateMethod() 二、先来个小总结： 1，反射是一种具有动态交互能力的一种机制，为什么强调动态交互？因为一般情况下都是动态加载也就是在运行的时候加载，而不是在编译的时候，在需要的时候才进行加载获取，或者说你可以在任何时候加载一个不存在的类到内存，然后进行各种交互，或者获取一个没有公开的类的所有信息，开发者可以随时随意的利用反射的这种机制动态进行一些特殊的事情。1，反射的组成部分 1，java.lang.Class.java:类对象 2，java.lang.reflect.Constructor.java:类的构造函数对象 3，java.lang.reflect.Method.java:类的方法对象 4，java.lang.reflect.Field.java:类的属性对象 2，反射的作用反射在java和Android中的应用： 1，需要访问隐藏属性或者调用方法改变原来的逻辑，这个在开发中极为常见。当系统没有开放接口出来，这个时候利用反射是一个有效的解决方法 2，自定义注解，注解就是在运行的时候利用反射机制来获取的 3，在开发中动态加载类，比如Android中著名的65536问题，模块化和插件化都离不开反射，离开了反射这些问题很难解决 3，反射的原理每个java文件都会编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、字段等等，这些class文件在程序运行的时候会被ClassLoader加载到虚拟机中。当一个类被加载后，java虚拟机会在内存中自动产生一个Class对象，而我们一般情况下用new关键字来创建对象，本质上是一样的，只是这些底层原理对我们开发者透明，实际上有了class的引用，就相当于有了Method，Field，Constructors的一切信息，在java中有了对象的引用就有了一切，开发者就可以自由发挥了。反射的简单演示(一)String类 123456789101112131415161718192021222324252627282930313233343536public class Student &#123; private int age;//年龄 private String name;//姓名 private String address;//地址 private static String sTest; public Student() &#123; throw new IllegalAccessError(&quot;Access to default Constructor Error!&quot;); &#125; private Student(int age, String name, String address) &#123; this.age = age; this.name = name; this.address = address; sTest = &quot;测试反射&quot;; &#125; private int getAge() &#123; return age; &#125; private void setAge(int age) &#123; this.age = age; &#125; private String getName() &#123; return name; &#125; private void setName(String name) &#123; this.name = name; &#125; private String getAddress() &#123; return address; &#125; private void setAddress(String address) &#123; this.address = address; &#125; private static String getTest() &#123; return sTest; &#125;&#125; 123456789101112131415161718192021222324252627282930public class StudentClient &#123; public static void main(String[] args) throws Exception&#123; Class&lt;?&gt; clazz=Class.forName(&quot;ClassLoader.Student&quot;); Constructor constructors=clazz.getDeclaredConstructor(int.class,String.class,String.class); constructors.setAccessible(true); //利用构造器生成对象 Object mStudent=constructors.newInstance(27,&quot;小文&quot;,&quot;北京市海定区XX号&quot;); System.out.println(mStudent.toString()); //获取隐藏的int属性 Field mAgeField=clazz.getDeclaredField(&quot;age&quot;); mAgeField.setAccessible(true); int age= (int) mAgeField.get(mStudent); System.out.println(&quot;年龄为:&quot;+age); //调用隐藏的方法 Method getAddressMethod=clazz.getDeclaredMethod(&quot;getAge&quot;); getAddressMethod.setAccessible(true); int newage= (int) getAddressMethod.invoke(mStudent); System.out.println(&quot;年龄为:&quot;+newage); //调用静态方法 Method getTestMethod=clazz.getDeclaredMethod(&quot;getTest&quot;); getTestMethod.setAccessible(true); String result= (String) getTestMethod.invoke(null); System.out.println(&quot;调用静态方法:&quot;+result); &#125;&#125;//运行结果reflect.Student@2c13da15年龄为:27年龄为:27调用静态方法:测试反射 反射的简单演示(二) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package reflect;import java.lang.reflect.Field;class Student_Demo &#123; public Student_Demo()&#123; &#125; //**********字段*************// public String name; protected int age; char sex; private String phoneNum; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;; &#125; &#125;public class Demo &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class stuClass = Class.forName(&quot;reflect.Student_Demo&quot;); //2.获取字段 System.out.println(&quot;************获取所有公有的字段********************&quot;); Field[] fieldArray = stuClass.getFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;); fieldArray = stuClass.getDeclaredFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;); Field f = stuClass.getField(&quot;name&quot;); System.out.println(f); //获取一个对象 Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student(); //为字段设置值 f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot; //验证 Student_Demo stu = (Student_Demo)obj; System.out.println(&quot;验证姓名：&quot; + stu.name); System.out.println(&quot;**************获取私有字段****并调用********************************&quot;); f = stuClass.getDeclaredField(&quot;phoneNum&quot;); System.out.println(f); f.setAccessible(true);//暴力反射，解除私有限定 f.set(obj, &quot;18888889999&quot;); System.out.println(&quot;验证电话：&quot; + stu); &#125;&#125; 输出结果： 12345678910111213************获取所有公有的字段********************public java.lang.String reflect.Student_Demo.name************获取所有的字段(包括私有、受保护、默认的)********************public java.lang.String reflect.Student_Demo.nameprotected int reflect.Student_Demo.agechar reflect.Student_Demo.sexprivate java.lang.String reflect.Student_Demo.phoneNum*************获取公有字段**并调用***********************************public java.lang.String reflect.Student_Demo.name验证姓名：刘德华**************获取私有字段****并调用********************************private java.lang.String reflect.Student_Demo.phoneNum验证电话：Student [name=刘德华, age=0, sex= , phoneNum=18888889999]]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java零散知识点一]]></title>
    <url>%2F2019%2F01%2F11%2Fjava%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1,什么是java的接口回调？有什么作用？回调是一种向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口。学习自回调先看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package test2;//定义回调接口interface CallBackInterface &#123; void execute();&#125;//创建回调对象class Boss implements CallBackInterface &#123; @Override public void execute() &#123; System.out.println(&quot;收到了!!&quot; + System.currentTimeMillis()); &#125;&#125;//创建控制类class Employee &#123; private CallBackInterface callBackInterface = null; //告诉老板的联系方式，也就是注册 public void setCallBack (CallBackInterface callBackInterface) &#123; this.callBackInterface = callBackInterface; &#125; //工人干活 public void doWork () &#123; //1,开始干活 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;第[&quot; + i + &quot;]件事干完了!&quot; ); &#125; //2，告诉老板干完了 callBackInterface.execute(); &#125;&#125;public class CallBack &#123; public static void main(String[] args) &#123; //测试代码 Employee employee = new Employee(); //将回调对象(上层对象)传入，注册 employee.setCallBack(new Boss()); //开启控制器对象运行 employee.doWork(); &#125;&#125; 运行结果： 1234567891011第[0]件事干完了!第[1]件事干完了!第[2]件事干完了!第[3]件事干完了!第[4]件事干完了!第[5]件事干完了!第[6]件事干完了!第[7]件事干完了!第[8]件事干完了!第[9]件事干完了!收到了!!1547188964051 为什么会出现回调机制呢？在 现实生活中，比如有如下场景：工厂的老板(Boss，也是上层模块)很忙，他没有时间盯着员工(下层模块)干活，然后他告诉自己的雇员，干完这些事后，告诉他干活的结果。这个例子就是回调+异步的例子。再比如，A程序员写了一个程序a，其中预留了回调函数接口，并封装好了该程序，程序员B让a调用自己的程序b中的一个方法，于是它通过a中的接口回调自己b中的方法。注意：回调和异步不同，回调不是解决时间过长的问题，异步才是。2,s什么是菱形继承问题？答：这个问题反映了为什么在java中不允许多继承，如果两个类共同继承一个类，那么该类的方法会被两个子类重写，如果同时继承这两个子类，那么调用该重写方法时，编译器是不能识别你要调用哪个方法的，这个问题被称为菱形继承问题。3,final,finally和finalize三者之间有什么区别？答： 1，final关键字是用来在多个语境下定义只能分配一次的实体，final可以声明成员变量、方法、类以及本地变量，一旦将引用声明作final，就不能改变这个引用了，编译器会检查代码，如果试图将变量再次初始化的话，编译器会报编译错误。 2，finally代码块是用于执行重要代码(如关闭连接、流、数据库等)的代码块，无论是否处理异常，finally代码块都会被执行。finally代码块紧跟try或catch代码块。 3，finalize是在删除或销毁对象之前垃圾回收器总会调用的方法，该方法使得垃圾回收机制能够执行清理活动。 4,父类的静态方法能否被重写？为什么？答：静态方法只与类有关，不与具体实现相关。而且static方法不是后期绑定的，它在编译时期就绑定了。所有引用到该方法的对象(父类也好子类也好)所指向的都是同一块内存中的数据，也就是该静态方法，父类的静态不能被子类继承，就更谈不上重写了。5,接口回调过程答：定义一个回调函数，给事件发送方传入接口，在需要的地方调用未实现方法；在事件接收方实例化并处理结果。当事件发生时，会通知回调函数进行处理、6,泛型原理答：java的泛型是伪泛型，使用泛型的时候加上的类型参数，会在编译的时候去掉，这个过程叫泛型檫除。泛型只在编译时有效。7，创建对象的方式答： 1，new 关键字 2，通过反射创建 3，采用clone方法 4，通过序列化机制 8，object中的公共方法有哪些？答：equals(),clone(),getClass(),wait(),notify(),notifyAll(),toString(),finalize()。9，反射中，class.forName()和classLoader的区别？答： 1，class.forName()除了将类的.class文件加载到JVM中之外，还会对类进行解释，执行类中的static代码块 2，classLoader只做一件事，就是将.class文件加载到JVM中，不会执行static代码块 10，throw与throws的区别答： 1，throws出现在函数头(声明异常)；而throw出现在函数体(指抛出具体的异常) 2，throws表示出现异常的一种吗可能性，并不一定会发生该异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。123throw new NumberFormatException();voiud funtion() throws NumberformatException&#123;&#125; 11,java什么被称为与平台无关的语言答：”一次编译，到处运行”，这是java的口号，java有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得java程序员只需要生成在java虚拟机上运行的目标代码(也就是字节码)，就可以在多种平台上运行(当然在不同的平台用不同的虚拟机，比如在window是和mac系统中java的虚拟机就不一样，但是正是虚拟机自己和操作系统底层打交道，而不要程序员编码的时候去考虑这个问题，我们只要生成字节码就可以了，字节码在不同的虚拟机中都可以运行，这样才可以实现”一次编译，到处运行”)。12，JDK和JRE区别答： 1，jdk是java Development Kit(java开发工具包),它包含一整套java开发工具，包括JRE和编译器，可以开发、编译执行java程序。 2，JRE是java运行环境，包括java虚拟机和applet 3，JDK包含JRE 13，static修饰的方法能否被覆盖？答：不能，覆盖试是运行时动态绑定的，而static是编译时静态绑定的，static变量在java中是属于类的，它在所有的实例中值是一样的。14，finalize()方法答：finalize()方法是Object()类的一个方法，GC回收对象前会调用finalize()方法15，为什么内部类调用的外部变量必须final修饰？答：方法中的局部变量，方法结束后这个变量就要释放掉，然而内部类的某个方法还没有执行完，这个时候它所引用的外部变量已经找不到了。如果定义成final的，java会将这个变量复制一份作为成员变量内置于内部类中。为了解决：局部变量的生命周期与局部内部类的对象的生命周期不一致性的问题。16，迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除17，array可以包含基本类型和引用类型，ArrayList只能包含引用类型，如果要存基本数据类型，也要用它们的包装类才可以18，compareable和comparetor接口答：comparetor：需要实现compare(o1,o2)和equals()方法返回int值，负数，小于；正数，大于；0，等于。19，异常处理完成后，Exception会发生什么变化?答：exception对象会在下一个垃圾回收过程中被回收掉20，浅拷贝和深拷贝以及引用的拷贝答：先看代码：引用的拷贝： 123456789//其它的代码省略了Person p = new Person(&quot;zhangsan&quot;, 25);Person p1 = p; System.out.println(p);System.out.println(p1); //运行结果Test.Person@2c13da15Test.Person@2c13da15 打印结果是一样的，也就是说两者引用的是同一个对象，并没有创建一个新的对象， 浅拷贝浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着与原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址(引用类型)，拷贝的就是内存地址深拷贝会拷贝所有的属性，并拷贝属性所指向的动态分配的内存，当对象和它所引用的对象一起拷贝时发生深拷贝21，Session和Cookie区别答：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进阶学习四(面向对象)]]></title>
    <url>%2F2019%2F01%2F08%2Fpython%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一、正则表达式定义：正则表达式是一个特殊的字符串序列，一个字符串是否与我们所设定的这样的字符序列，相匹配。正则表达式的作用：它的作用:快速检查文本，实现一些替换文本的操作。比如： 1，检查一串数字是否是电话号码形式 2，检测一个字符串是否符合email的格式 3，把一个文本里指定的单词替换为另外一个单词 查找是否包含某个字符串比如有字符串： a = ‘C|C++|Java|C#|Python|JavaScript’。看以下示例代码： 12345678910111213141516171819import rea = &apos;C|C++|Java|C#|Python|Jav|Python|aScript&apos;#内置函数#是否包含&apos;Python&apos;# print(a.index(&apos;Python&apos;) &gt; -1)#是否包含&apos;Python&apos;# print(&apos;Python&apos; in a)#返回一个列表r = re.findall(&apos;Python&apos;,a)if len(r) != 0: print(&apos;字符串包含Python&apos;)else: print(&apos;字符串包含PHP&apos;)r = re.findall(&apos;Python&apos;,a)# if len(r) != 0:# print(&apos;字符串包含PHP&apos;) 正则表达式的灵魂是规则，上面的代码是一个常量，不能说不是规则，不过这并不是正则表达示的广泛应用。 找出字符串中所有的数字字符串:a = ‘C|C++7|Java8|C#8|Python8|Jav|Python|aScript’ 12345678910111213141516171819&apos;Python&apos;:是普通字符&apos;\d&apos;:是元字符#正则表达式就是元字符和普通字符的组合#元字符[百度百科正则表达式](https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215?fr=aladdin)import rea = &apos;C|C++7|Java8|C#8|Python8|Jav|Python|aScript&apos;#规则#打印出所有的数字r = re.findall(&apos;\d&apos;,a)print(r)#匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持r = re.findall(&apos;\D&apos;,a)print(r)#打印结果PS G:\python&gt; python test14.py[&apos;0&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;3&apos;] 1，字符集操作a = ‘abc,acc,adc,aec,afc,ahc’,找到’a[cf]c’,就是找到字符串中间是c或f，两边分别是a和c。 12345678910111213141516171819202122232425262728293031#字符集import rea = &apos;abc,acc,adc,aec,afc,ahc&apos;#字符集的特性:[]中间的字符是 或 关系r = re.findall(&apos;a[cf]c&apos;,a)print(r)#打印PS G:\python\正则表达式&gt; python test15.py[&apos;acc&apos;, &apos;afc&apos;]import rea = &apos;abc,acc,adc,aec,afc,ahc&apos;#匹配不是c、f、d的字符r = re.findall(&apos;a[^cfd]c&apos;,a)print(r)#打印结果PS G:\python\正则表达式&gt; python test15.py[&apos;abc&apos;, &apos;aec&apos;, &apos;ahc&apos;]import rea = &apos;abc,acc,adc,aec,afc,ahc&apos;#匹配是c到f的字符r = re.findall(&apos;a[c-f]c&apos;,a)print(r)#打印结果PS G:\python\正则表达式&gt; python test15.py[&apos;acc&apos;, &apos;adc&apos;, &apos;aec&apos;, &apos;afc&apos;] 2，概括字符集 1234567891011121314151617181920212223242526272829#找出全部数字# &apos;\d&apos;就是一个概括字符集import rea = &apos;a111456pythonjava678php&apos;#以下两种方式都可以，正则表达式很灵活r = re.findall(&apos;\d&apos;,a)r = re.findall(&apos;[0-9]&apos;,a)#非数字r = re.findall(&apos;[^0-9]&apos;,a)#数字和字母全匹配r = re.findall(&apos;\w&apos;,a)# &amp; 符号就不可以匹配a = &apos;a 1\n4\r5\tp2g&amp;__r = re.findall(&apos;\W&apos;,a) #大写的Wprint(r)#打印PS G:\python\正则表达式&gt; python test16.py[&apos; &apos;, &apos;\n&apos;, &apos;\r&apos;, &apos;\t&apos;, &apos;&amp;&apos;]#import rea = &apos;a145 p2\rg&amp;__&apos;print(r)#打印结果PS G:\python\正则表达式&gt; python test16.py[&apos; &apos;, &apos;\r&apos;] 小总结： 1234#概括字符集# \d \D# \w单词字符 \W# \s空白字符 \ 3,数量词 123456789#import rea = &apos;python 145java678php&apos;r = re.findall(&apos;[a-z]&#123;3,6&#125;&apos;,a) #3到6个都可以print(r)#打印 结果PS G:\python\正则表达式&gt; python test17.py[&apos;python&apos;, &apos;java&apos;, &apos;php&apos;] 为什么匹配到3个不会输出，而是会继续匹配？这涉及数量词的一个重要概念。贪婪模式和非贪婪模式数量词的贪婪和非贪婪方式：python的数量词默认是贪婪方式，所以匹配到3个的时候，会继续匹配，到第六个都匹配，后面不配，就才结束。所以会匹配出：python、java、php。 非贪婪模式：在规则后面加’?’：’[a-z]{3,6}?’以上规则打印结果：[‘pyt’, ‘hon’, ‘jav’, ‘php’] :打印0次或无限多次 ：匹配1次或无限多次? :匹配0次或1次 123456789#以下三种情况第一行是代码，第二行是对应代码的输出结果。r = re.findall(&apos;python*&apos;,a)[&apos;pytho&apos;, &apos;python&apos;, &apos;pythonn&apos;]r = re.findall(&apos;python+&apos;,a)[&apos;python&apos;, &apos;pythonn&apos;]r = re.findall(&apos;python?&apos;,a)[&apos;pytho&apos;, &apos;python&apos;, &apos;python&apos;] 12345678910import relanguage = &apos;Pythonc#JavaPHP&apos;#(python) 加了括号就是一个组，(python)&#123;3&#125;这个组出现3次#re.I 忽略大小写r = re.findall(&apos;C#&apos;,language,re.I)print(r)#打印结果PS G:\python\正则表达式&gt; python test17.py[&apos;c#&apos;] 12345678910111213141516171819import relanguage = &apos;PythonC#\nJavaPHP&apos;#(python) 加了括号就是一个组，(python)&#123;3&#125;这个组出现3次#re.I 忽略大小写r = re.findall(&apos;c#.&#123;1&#125;&apos;,language,re.I)print(r)#打印PS G:\python\正则表达式&gt; python test17.py[]#加入re.S规则，就能匹配\nimport relanguage = &apos;PythonC#\nJavaPHP&apos;#(python) 加了括号就是一个组，(python)&#123;3&#125;这个组出现3次#re.I 忽略大小写r = re.findall(&apos;c#.&#123;1&#125;&apos;,language,re.I | re.S)print(r)PS G:\python\正则表达式&gt; python test17.py[&apos;C#\n&apos;] 贪婪模式和非贪婪模式 123456789101112#非贪婪和贪婪模式language = &apos;pythocpython#JavaPHPpythonn&apos;#[&apos;pytho&apos;, &apos;python&apos;, &apos;python&apos;]python&apos;]r = re.findall(&apos;python?&apos;,language)print(r)#[&apos;python&apos;, &apos;python&apos;]s = re.findall(&apos;python&#123;1,2&#125;?&apos;,language)print(s)#[&apos;python&apos;, &apos;pythonn&apos;]t = re.findall(&apos;python&#123;1,2&#125;&apos;,language)print(t) 边界匹配qq号是否匹配(4到8位)？ 12]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算未来读书笔记]]></title>
    <url>%2F2019%2F01%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%AA%E6%9D%A5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[沈向洋博士和微软总裁的书，相信是一本很好的科普文章，看看也做做笔记，理解理解人工智能，给自己扫个盲把。我向诸君提出这一问题：机器能否思考？ —-阿兰.图灵 1956年夏天，达特茅斯学院举行了一场特殊的会议，研究的主题是，如何才能开发出像人类一样的，有能力从经验中自主学习的计算机系统。这场会议标志着人工智能开发的纪元时刻。这就是鼎鼎大名的达特茅斯会议。不过其实对机器智能概念的探索早在此之前就已经开始，到达特茅斯会议召开时，已经有十余年的时间。其中最出名的就是阿兰.图灵提出的 图灵测试：如果人类在与一台机器进行交互时，无法辨别对方是人还是机器，那么这台机器就可视为是”智能的”。这就是很有名的图灵测试。 为什说研究人工智能时机已至？得益于三方面的发展：1，数据可用性增加；2，云计算能力不断加强；3，人工智能研究人员提出了更强答的算法。而随着生活的数字化程度越来越高，以及各种传感器的普及，计算机可用于学习的数据已经达到了空前的规模。]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算未来读书笔记]]></title>
    <url>%2F2019%2F01%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%AA%E6%9D%A5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap详解]]></title>
    <url>%2F2019%2F01%2F08%2FHashMap%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、HashMaphashmap在元素size超过负载因子对应数的时候就会扩容，但是其实还有一种情况也会扩容，那就是链表上Node数量大于等于8且tab数组长度小于64的时候的时候。HashMap的结构是哈希表，底层维护了一个Node数组(Jdk 8之后，之前是HashMap.Entry数组)，它是集合框架里非常常用的集合类，和ArrayList一样，使用非常频繁，HashMap的初始容量是16，加载因子是0.75，当在一个位桶发生哈希冲突(也叫哈希碰撞)的时候，添加的元素会依次存放在该位置的最后一个元素后面(形成链表)，链表数量大于8且HashMap元素大小小于64时，这条链表就会转成就会转成红黑树，注意一定两个条件都满足才会转成红黑树，不要忽略了64这个数，平时很多博客说链表大于8就转红黑树大概是因为在工程上链表大于8了基本上HashMap存储的元素大于64，否则说明这个HashMap的hash函数设计的不好，基本上算出来的值都是同一个，也就是说产生了哈希碰撞。而实际上HashMap的hash函数是已经高度优化了的，所以某条链表节点数大于8而总节点数小于64发生的概率极低，当然要知道这个逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 1.1 treeifyBin方法如图所示，TREEIFY_THRESHOLD值是8，它的意思是超过一条链上的Node数量大于等于8就会转成红黑树来存储元素而不是链表，然后会执行treeifyBin(tab, hash);方法，我们看看这个方法的实现： 123456789101112131415161718192021222324/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */ final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; 看注释，意思大概就是，把链表转换为红黑树，除非数组太小，在hashmap的实现里，是table小于64时，不转为红黑树。MIN_TREEIFY_CAPACITY是最小转为红黑树的tab大小，是64，如果满足这个条件同时链表长度大于8就执行resize()方法对数组进行扩容。 HashMap是容器类，存储的是键值对，jdk 1.8之前底层是 数组和链表结合在一起使用也就是 链表散列。HashMap通过key的 hashCode 经过扰动函数处理后得到hash值，然后通过(n - 1) &amp; hash判断当前元素存放的位置(n是数组的长度，HashMap默认为16，加载因子是0.75)，如果当前位置存在元素，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不同就通过拉链法解决冲突。put()方法相关源码如下： 1.2 putVal方法123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()/*resize方法生成一个指定容量大小的Node数组*/).length; if ((p = tab[i = (n - 1) &amp; hash]) == null)//1,tab[i]位置没有node对象，就直接把元素放在此位置 tab[i] = newNode(hash, key, value, null); else &#123;//2，不为空的情况下，在这里判断是否覆盖还是通过拉链法放到别处(判断是同一个对象就覆盖) Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//3, e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 1.3 扰动函数是HashMap的hash方法，使用hash方法也就是扰动函数时为了防止一些实现比较差的hashCode()方法，也就是说，扰动函数可以减少碰撞。 1234567891011//jdk 11.0.1(估计还是和jdk 8一样，因为最新的eclipse支持，jdk 11.0.1所以我直接下载的最新版本)static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//jdk 1.7的hash方法static final int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 相比之下，JDk 11.0.1的方法性能要好一些，jdk 7的hash方法扰动了4次。 1.4 拉链法拉链法就是将链表和数组结合，也就是说创建一个链表数组，数组每一个格是一个链表，若遇到哈希冲突，则将冲突的值加到链表中即可。jdk 1.7:jdk 1.8之后 1.5 HashMap类的成员变量123456789101112131415161718192021222324252627private static final long serialVersionUID = 3624988207631812static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;transient Node&lt;K,V&gt;[] table;transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;transient int modCount;int threshold;final float loadFactor; jdk 1.8及以后put方法HashMap只提供了普通方法用于添加元素，putVal()方法 是在put方法调用的时候调用的，没有给用户调用。putVal方法添加元素的过程如下： 如果定位到的位置没有元素就直接插入 如果定位到的数组位置有元素就和要插入的元素的key作比较，如果相同就直接覆盖(key不能重复，重复就覆盖)，再判断p是不是一个树节点，如果是调用 e = e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);将元素插入。如果不是就遍历链表插入。 1.6 Jdk 8 putVal方法的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //tab未初始化就扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //(n - 1) &amp; hash是确定元素位于哪个桶中，桶为空，就生成新的节点放入桶中(此时，这//个节点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //如果桶中已存在 else &#123; Node&lt;K,V&gt; e; K k; //如果桶中第一个元素(数组中的节点)hash值与要传入的值的hash值相等且key相等， if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //将第一个元素赋值给e,用e来记录 e = p; //hash值不相等，即key不相等；为红黑树节点 else if (p instanceof TreeNode) //放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //为链表节点 else &#123; //在链表最尾端插入 for (int binCount = 0; ; ++binCount) &#123; //到达链表尾部 if ((e = p.next) == null) &#123; //在尾部插入节点 p.next = newNode(hash, key, value, null); //节点数量达到阈值，转化为红黑树(并不一定就会转成红黑树，)，Node数组要大于等于 MIN_TREEIFY_CAPACITY(64)//才可以 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); //跳出循环 break; &#125; //判断链表中节点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //相等，跳出循环 break; //用于遍历桶中的链表，与前面的 e = p.next结合，可以遍历链表 p = e; &#125; &#125; //表示在桶中找到key值、hash值与插入元素相等的节点 if (e != null) &#123; // existing mapping for key //记录e的value V oldValue = e.value; //onlyIfAbsent值为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换 e.value = value; //返回后回调 afterNodeAccess(e); //返回旧值 return oldValue; &#125; &#125; //结构性修改 ++modCount; //满足实际容量大小大于阈值扩容条件 if (++size &gt; threshold) resize(); //插入后回调 afterNodeInsertion(evict); return null;&#125; jdk1.7 put方法put方法的分析： 如果定位到的数组位置没有元素就直接插入 如果定位到的数组位置有元素，遍历以这个元素为头节点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素 1.7 jdk 1.7get方法get方法分析： get方法返回对应键值对的value，传入key，通过key得到hash值，hash值和key传入getNode()方法中得到一个Node类型的变量，为空返回null，不为空说明hash表中有这个元素，返回这个元素对应的value(e.value)。 getNode()方法，12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //传入的key的hash值与数组元素的hash(其实也可以是元素中key的hash值，因为hash只与key有关)，并且 (k = first.key) == //key 和 (key != null &amp;&amp; key.equals(k))两个条件有一个为真，那么说明这个我们传入的key就是first这个元素的key，我们就是//想得到它的value值。此时返回Node，在上面的get()方法中返回这个Node对象的 value。 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //该桶不止一个元素，也就是有链表或者红黑树 if ((e = first.next) != null) &#123; //在红黑树中用get()方法， if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //在链表中调用get()方法，遍历，找到就返回 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 1.8 getTreeNode方法我们看看从红黑树中查找的方法实现 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);这里一个getTreeNode对象，也就是红黑树中节点对象，这里把Node类型的first强转为了TreeNode类型。 getTree方法12345678910111213141516171819202122232425262728293031323334353637final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null);&#125;// TreeNode中的find()方法，官方注释是通过这个方法找到那个元素,返回TreeNode，官方注释：/** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */意思是通过传入的hash和key找到这个元素(红黑树TreeNode类型)。 final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null;&#125; 1.9 resize方法resize方法分析： 这个方法用于进行扩容，会伴随着一次重新的hash分配，并且会遍历hash表中所有的元素，非常耗时。在编写程序时，尽量避免resize。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //超过最大值就不再扩充了 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //没有超过最大值，扩充为原来两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //计算新的resize上限，是为ft，还是Integer得最大值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; //把每个桶都移到新的桶中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //原索引 + oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bucket中 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引 + oldCap放到bucket中 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 以下内容学习自以下博客HashMap 下面以知识点的形式对HashMap进行解析1，容量和 size 分别指什么？答：容量并不是指 HashMap 所能存储的键值对数量，而是其内部的 table 数组的大小，而 size 是指目前已存储的键值对的数量。table 是一个 Entry 数组。 table 的每一个节点都连着一个链表或者红黑树。2,初始容量可以随意设置吗？答：可以，但是 HashMap 内部会你设置的 initialCapacity 转换为大于等于它的最小的2的n次方。比如 20 转为 32，32 转为 32等。如果不设置，则为默认值16。需要注意的是，在 Java 8的源码中，并没有在构造方法直接新建数组。而是先将处理后的容量值赋给 threshold，在第一次存储键值对时再根据这个值创建数组。3，HashMap为什么要将容量转换为2的n次方？答：这是为了提高取余的效率，存储键值对时，通过hash函数对key(键)求出key的hash值后，需要对数组的容量进行取余，余数即为key-value对在数组中的index(索引)。我们知道对于计算机而言，二进制计算的效率远远高于取余操作(%)。而容量如果是2的n次方的话，hash值对其取余就等同于hash值和容量值减1进行按位与操(&amp;)作: 1234//capacity为2的n次方的话，下面两个操作结果相同hash &amp; (capacity - 1)值等于hash % capacity 原因：如果一个数是2的n次方，那它的二进制就是从右往左n位都是0，第n+1位是1。2的3次方二进制是1000,2的5次方二进制是100000，这个数的倍数也满足从右往左n为0，取余的时候抛弃倍数，就等同于将n+1位及其往左的所有位都置0，剩下的n位就代表余数。也就是说，一个数对2的n次方取余，就是要取这个数二进制的最低n位。2的n次方减1的结果就是n个1，进行与操作后得到了最低n位。 *4，HashMap的初始容量为多少？可以自己设置吗？答：HashMap的初始容量为16，也就是不指定容量的情况下默认为16，可以自己设置，但HashMap内部会根据我们设置的initCapacity转换为大于等于它的最小的2的n次方。比如20默认转换为32,32转换为32。如何转换看问题3。 5，如何将一个数转换为大于等于它的最小的2的n次方呢？答：如下代码所示，这是HashMap的源码：我们先看代码的运行过程，如果我们在实例化HashMap对象的时候，在构造函数传入一个int值，也就是我们想自己设置容量的大小，此时会调用1处的构造函数，然后又调用了2处的构造函数，这个函数有两个参数，前面的代码是一些提高代码健壮性的代码，我们暂时不看，我们看到最后一行代码： this.threshold = tableSizeFor(initialCapacity);threshold是int类型，所以tableSizeFor应该返回的也是int型，我们看tableSizeFor的源码： 1234static final int tableSizeFor(int cap) &#123; int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1); return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 我们分析一下这两行代码，tableSizeFor函数会返回一个数，这个int类型的数是大于等于它的最小的数并且是2的n次方。numberOfLeadingZeros函数的代码： 1234567891011public static int numberOfLeadingZeros(int i) &#123; // HD, Count leading 0&apos;s if (i &lt;= 0) return i == 0 ? 32 : 0; int n = 31; if (i &gt;= 1 &lt;&lt; 16) &#123; n -= 16; i &gt;&gt;&gt;= 16; &#125; if (i &gt;= 1 &lt;&lt; 8) &#123; n -= 8; i &gt;&gt;&gt;= 8; &#125; if (i &gt;= 1 &lt;&lt; 4) &#123; n -= 4; i &gt;&gt;&gt;= 4; &#125; if (i &gt;= 1 &lt;&lt; 2) &#123; n -= 2; i &gt;&gt;&gt;= 2; &#125; return n - (i &gt;&gt;&gt; 1);&#125; 6，hash值是怎么计算的？答：hash函数的源码: 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以看到，函数没有直接返回hashcode的返回值，而是进行了一些处理。我们通过hash函数得到的值要和Node数组容量进行按位与操作，我们已经知道这个操作的结果只与hash值的低n位有关，如果低n位时固定的或者集中在几个值，那么按位与的结果会很多相同，这就做”哈希碰撞”或”哈希冲突”，由于hashCode()函数可以重写，重写的时候可能写了一个性能不好的hashCode()函数，导致”哈希碰撞”产生。为了尽量避免这种情况发生，HashMap的做法是先将hash值向右移，再进行异或操作，这样就使得高位的值和低位的值融合成一个新的值，这样可以保证后面的按位与操作受每一个二进制位的影响。 7，扩容后元素如何进行移动答：为了防止元素增多后，链表越来越长，HashMap 会在元素个数达到阈值后进行扩容，新的容量为旧容量的2倍。容量变化后，每个元素用 hash 值取余的结果也会随之变化，需要在数组中重新排列。以前同一条链表上的元素，扩容后可能存在不同的链表上。 在 Java 7 中，重新排列实现得简单粗暴，直接用 hash 根据新容量算出下标，然后设置到新数组中，即相当于将元素重新put 了一次。但在 Java 8中，作者发现没必要重新插入，因为重新计算后，新的下标只可能有两种情况，要么是原来的值，要么是原来的值加旧容量。比如容量为16的数组扩容到32，下标为1的元素重新计算后，下标只可能为1或17。 这个怎么理解呢？重提一下之前的一句话，一个数对2的 n 次方取余，就是要取这个数二进制的最低 n 位。当容量为16时，取余是取最后4位的值，而扩容到32后，取余变成取最后5位的值。这里增加的1位如果为0，那么余数就没变，如果为1，那么余数就增加了16。如何取增加的这一位的值呢？直接和16进行与操作即可。16的二进制是10000，与操作后如果结果为0，即表示高位为0，否则为1。 根据这个原理，我们只需要将原来的链表分成两条新链放到对应的位置即可，下面是具体步骤： 遍历旧数组，如果元素的 next 为空，直接取余后放到新数组； 如果元素后面连了一个链表，那么新建两条链表，暂且成为 hi 链和 lo 链； 遍历链表，计算每个元素的 hash 值和旧容量与操作的结果，结果为0则将其放入 lo 链末端，不为0放入 hi 链末端； 将两条链的 head 放到新数组中，其中 loHead 放到原来的位置，hiHead 放到原来的下标加上旧容量处； 如果是红黑树，进行和上面类似的操作，只是将两条链表换成两棵树。 123456789101112131415161718192021222324252627282930313233343536373839404142if (oldTab != null) &#123;for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //红黑树类似 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //新建两条链表 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; //结果为0，表示下标没变，放入 lo 链 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; //结果为0，表示下标要加上旧容量，放入 hi 链 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; //lo 链放在原来的下标处 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; //hi 链放在原来的下标 加旧容量处 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125;&#125; 1if ((e.hash &amp; oldCap) == 0) 这里是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位。还没理解，，， 增加元素往表中添加一个元素， 1234public V put(K key, V value) &#123; //先根据key，取得hash值。 再调用上一节的方法插入节点 return putVal(hash(key), key, value, false, true);&#125; 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 这个hash函数也称为扰动函数，它的目的是为了让得出来的hash值更加均衡，与n-1作与运算(也就是计算元素在table表中的位置)后的值更加分散，减小哈希冲突。 以下内容来源于转载：因为hashCode()是int类型，取值范围是40多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。但就算原本的hashCode()取得很好，每个key的hashCode()不同，但是由于HashMap的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有hashCode()的低位参加运算，发生不同的hash值，但是得到的index相同的情况的几率会大大增加，这种情况称之为hash碰撞。 即，碰撞率会增大。扰动函数就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）9，删除元素以key为条件删除元素 12345public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; 如果key对应的value存在，则删除这个键值对。 并返回value。如果不存在 返回null。10,HashMap与Hashtable的区别 a,与之相比HashTable是线程安全的，且不允许key、value是null。 b,HashTable默认容量是11。 c,HashTable是直接使用key的hashCode(key.hashCode())作为hash值，不像HashMap内部使用- d,static final int hash(Object key)扰动函数对key的hashCode进行扰动后作为hash值。 HashTable取哈希桶下标是直接用模运算%.（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算） 扩容时，新容量是原来的2倍+1。int newCapacity = (oldCapacity &lt;&lt; 1) + 1; Hashtable是Dictionary的子类同时也实现了Map接口，HashMap是Map接口的一个实现类； 腾讯云：https://hexoblog-1257580711.cos-website.ap-guangzhou.myqcloud.com]]></content>
      <categories>
        <category>数据结构,java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进阶学习三(面向对象)]]></title>
    <url>%2F2019%2F01%2F07%2Fpython%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B8%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象概念和java一样，类(class)和对象是面向对象的体现，它是一种设计思想现实生活在计算机世界的映射。类的最基本作用就是封装代码，在一个类里可以定义很多个类。 1，类的定义 1234567891011121314151617181920212223242526272829303132333435class Student(): #可以在类体定义变量 name = &apos;&apos; age = 0 c = 9 #也可以在类体定义函数 def print_file(self): #要加self def print_file(self): print(&apos;name:&apos; + name) print(&apos;name:&apos; + str(age)#然而运行还是会报错PS G:\python&gt; python test10.pyTraceback (most recent call last): File &quot;test10.py&quot;, line 15, in &lt;module&gt; student.print_file() File &quot;test10.py&quot;, line 11, in print_file print(&apos;name:&apos; + name)NameError: name &apos;name&apos; is not defined#显示没有定义 name变量#正确的方法是在name和age这两个变量前加self.来引用。class Student(): name = &apos;&apos; age = 0 def print_file(self): print(&apos;name:&apos; + self.name) print(&apos;name:&apos; + str(self.age))student = Student() student.print_file()#运行结果PS G:\python&gt; python test10.pyname:name:0 1.1 方法与函数的区别1，实际上很多时候我们都把他们划等号，java、c#一般称为方法，c和c++一般称函数。2，方法：趋向于面向对象的概念，python建议称方法，在模块里就建议称函数。3，函数：面向过程的概念当然没有必要刻意强调它们的区别 1.2 变量1，在模块中定义的就称变量2，在类中定义的就称为数据成员(这样以体现封装性)。 1.3 类和对象的关系和区别类的定义：类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。类只是一类事物的总称，并不是一个具体的集合，具体的对象表示具体的类的一个实例，类的实例化就生成一个对象。 1.4 类的实例化1234567891011student1 = Student() student2 = Student() student3 = Student() print(id(student1))print(id(student2))print(id(student3))#运行结果，可以看到他们的内存地址都是不同的PS G:\python&gt; python test10.py247971223244824797122328402479712232616 构造函数只能返回none，不能返回其他类型的值，比如字符串。我们在实例化对象的时候要在构造函数传入定义的变量，然后赋值，在生成对象的时候传入我们要定义的实际参数的值， 123456789101112131415161718192021222324252627282930class Student(): name = &apos;&apos; age = 0 def __init__(self,name,age): #这是构造函数 name = name age = age def print_file(self): print(&apos;name:&apos; + self.name) print(&apos;name:&apos; + str(self.age))student1 = Student(&apos;石头&apos;,18) print(student1.name)#打印PS G:\python&gt; python test10.py#但是输出却是空，为什么？再看一个小例子：c = 50def add(x,y): c = x + y print(c)add(1,2)print(c)#输出结果PS G:\python&gt; python test11.py350 这里我们在函数内部打印c的值是3，在外部打印c的值是50，在函数里面c是局部变量，不会改变全局变量的值，不过类的情况不同。下面分析一下。 1.5 类变量和实例变量类变量时和类相关联的，实例变量是和对象相关联的，python里面是用self.变量名来保存实例变量的值。如下代码所示， 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student(): name = &apos;&apos; age = 0 def __init__(self,name,age): #这是构造函数 self.name = name self.age = age def print_file(self): print(&apos;name:&apos; + self.name) print(&apos;name:&apos; + str(self.age))student1 = Student(&apos;石头&apos;,18) # student1 = Student(&apos;石敢&apos;,18) print(student1.name,student1.age)#运行结果PS G:\python&gt; python test10.py石头 18#再看如下代码class Student(): #不适合定义在这里 name = &apos;qiyue&apos; age = 0 def __init__(self,name,age): #这是构造函数 self.name = name self.age = age def print_file(self): print(&apos;name:&apos; + self.name) print(&apos;name:&apos; + str(self.age))student1 = Student(&apos;石头&apos;,18) student2 = Student(&apos;石敢&apos;,18) print(student1.name)print(student2.name)print(Student.name)#运行结果PS G:\python&gt; python test10.py石头石敢qiyue两个对象的name是不同的，所以打印出不同的结果，最后一行打印出qiyue，这是类变量，但是这样没有意义，名字和年龄应该定义成实例变量，而不是定义在如上代码的位置，因为类不是具体的一个对象。 下面分析一下类变量和实例变量的有关问题 123456789101112131415class Student(): name = &apos;qiyue&apos; age = 0 def __init__(self,name,age): name = name age = agestudent1 = Student(&apos;石头&apos;,18) print(student1.name)#打印PS G:\python&gt; python test10.pyqiyueqiyue 如上代码所示，我们打印对象student1的name是qiyue，直接打印类的变量name值也是qiyue，后者好理解，可是我们为什么试图打印student1的name也是qiyue而不是石头呢？ 123def __init__(self,name,age): name = name age = age 我们这样写是不会给对象赋值的，应该配合self来使用。 123def __init__(self,name,age): self.name = name self.age = age self如果定义的是实例方法，那我们必须在方法的参数列表第一个固定加上self，这是python的规定(实际上也可以用this，不过建议self)，要显式的传入self，self就代表当前对象，不过我们调用实例方法的时候不需要传self，代码： 1234567891011#定义的时候要在参数列表第一个位置加selfclass Student(): name = &apos;qiyue&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age#调用的时候则不需要这么做student1 = Student(&apos;石头&apos;,18) 如果要在实例方法中和函数外访问类变量，应该用类名.变量名调用。方法一 12345678910111213141516171819202122232425262728293031323334class Student(): sum1 = 0 name = &apos;qiyue&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age print(Student.sum1)student1 = Student(&apos;石头&apos;,18) print(student1.name)print(Student.sum1)class Student(): sum1 = 0 name = &apos;qiyue&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age print(Student.sum1)student1 = Student(&apos;石头&apos;,18) print(student1.name)print(Student.sum1)#运行结果PS G:\python&gt; python test10.py0石头0 方法二：通过self，self有一个自带的class，它就是Student类。 12345678910111213141516171819class Student(): sum1 = 0 name = &apos;qiyue&apos; age = 0 def __init__(self,name,age): self.name = name self.age = age print(self.__class__.sum1)student1 = Student(&apos;石头&apos;,18) print(student1.name)print(Student.sum1)#打印结果PS G:\python&gt; python test10.py0石头0 2,类方法为什么会有类方法？它有什么作用？ 12345678910111213141516171819202122class Student(): sum = 0 # name = &apos;qiyue&apos; # age = 0 def __init__(self, name, age): self.name = name self.age = age self.__class__.sum += 1 print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;do homework&apos;)student1=Student(&apos;小明&apos;, 18)student1=Student(&apos;小强&apos;, 18)student1=Student(&apos;小黄&apos;, 18)#运行结果PS G:\python&gt; python test10.py当前班级学生总数为：1当前班级学生总数为：2当前班级学生总数为：3 类变量也有一个专门操作它的方法,叫类方法 123@classmethoddef plus_sum(cls): pass 这是类方法定义的规范，在方法前面添加一个装饰器@classmethod。类方法怎么调用呢？ 123456789101112131415161718192021222324252627282930class Student(): sum = 0 # name = &apos;qiyue&apos; # age = 0 def __init__(self, name, age): self.name = name self.age = age self.__class__.sum += 1 print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) @classmethod def plus_sum(cls): cls.sum += 1 print(cls.sum)student1=Student(&apos;小明&apos;, 18)Student.plus_sum()student1=Student(&apos;小强&apos;, 18)Student.plus_sum()student1=Student(&apos;小黄&apos;, 18)Student.plus_sum()#打印PS G:\python&gt; python test10.py当前班级学生总数为：12当前班级学生总数为：34当前班级学生总数为：56 实例化对象的时候，对sum操作 加1，然后在类方法中又对sum进行加1操作，所以会如上代码打印。cls可以 叫别的名字吗?可以，我们换成self也同样可以。实例方法关联的是对象，类方法关联的是类。这是区别，既然可以在实例方法中操作类变量，那还要类方法做什么？因为在操作与对象无关的变量，最正确的方法还是用类方法(实例方法也可以，但是不建议)。self和clsself是可以代表当前对象的一个参数；cls是代表当前类的一个参数，代表当前类。也可以用对象调用类的方法(不建议，java中就不可以这么做)。 3，静态方法定义: 123@staticmethod def add(x,y): print(&apos;This is a static method&apos;) 调用： 123456789...student1=Student(&apos;小明&apos;, 18)student1.add(1,2)Student.add(1,2)...#运行结果PS G:\python&gt; python test10.pyThis is a static methodThis is a static method 注：省略了部分代码。静态方法可以用类和对象调用。静态方法也可以访问类变量。静态方法不建议经常用。 4,成员的可见性面向对象语言都有这个概念，java使用private、public来修饰，也叫权限修饰符。python是怎么定义一个方法的权限呢？：双下划线。在方法前面加双下划线。如： 12345def __marking(self,score): if score &lt; 0: return &apos;分数不合法，请重新打分&apos; self.score = score print(self.name + &apos;同学本次考试分数为:&apos; + str(self.score)) 这里有个疑问，构造函数也是前面有双下划线为什么不是私有的？仔细看，init后面还有双下划线，在python里，函数名前后都有双下划线就不会被认为是私有函数，我们可以运行函数来证明： 1234567891011121314151617181920...def marking(self,score): if score &lt; 0: return &apos;分数不合法，请重新打分&apos; self.score = score print(self.name + &apos;同学本次考试分数为:&apos; + str(self.score))...student1=Student(&apos;小明&apos;, 18)result = student1.marking(-9)print(result)#运行结果PS G:\python&gt; python test10.py分数不合法，请重新打分#这里运行了marking方法，我们在前面加双下划线，运行结果如下：PS G:\python&gt; python test10.pyTraceback (most recent call last): File &quot;test10.py&quot;, line 50, in &lt;module&gt; result = student1.marking(-9)AttributeError: &apos;Student&apos; object has no attribute &apos;marking&apos;#果然，现在不能访问了，&quot;no attribute &apos;marking&apos;&quot;,我们再在marking后面加双下划线 &quot;__marking__&quot;，则可以调用。当然这样不建议，因为它是python内置的定义方式。 我们可以强制访问，在调用的时候在变量前面加双下划线。如: student1.__score = 1. 123456789student1=Student(&apos;小明&apos;, 18)result = student1.marking(9)student1.__score = -9print(student1.__score)#打印PS G:\python&gt; python test12.py小明同学本次考试分数为:59-1&#123;&apos;name&apos;: &apos;小明&apos;, &apos;age&apos;: 18, &apos;_Student__score&apos;: 59, &apos;__score&apos;: -1&#125; 注意 _Student__score ，它就是我们定义的私有变量score,这是python私有变量的保护机制。为什么我们访问不到这个score变量，实际上就是python修改了它的名字，前面加上单下划线和类名。严格意义上python并没有私有变量。我们还是可以访问所谓的私有变量，”students._Student__score”。 1234567891011student1=Student(&apos;小明&apos;, 18)student2=Student(&apos;小兰&apos;, 18)result = student1.marking(59)student1.__score = -1print(student1.__score)print(students._Student__score)#打印PS G:\python&gt; python test12.py小明同学本次考试分数为:59-10]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进阶学习二]]></title>
    <url>%2F2019%2F01%2F06%2Fpython%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一、pyhton项目组织架构—包和模块和类python组织架构：包–&gt;模块–&gt;类。而类中有函数和变量。一个包可以包含很多模块，一个模块可以包括很多类。和java、c++不同，python中一个文件经常有多个类。java和c++中一般一个文件只有一个类，包可以理解就是一个文件夹(java中是jar包的概念)。 1，包和模块的命名表面上看，包的名字就是文件夹的名字，模块的名字就是文件的名字，如果想让一个普通文件夹成为一个包，就在文件夹中加入init.py文件，当然我们也可以在这个文件中写代码。不过它比较特殊，init.py这个模块的名字就是包名，比如如下包中init.py模块的名字就是python： 1.1,模块的导入在一个模块中导入另一个模块，用 import module_name来导入，使用的时候通过 模块名.变量名来使用，否则会找不到这个变量。如下图所示，我们虽然导入了test6这个模块，但是使用test6模块的变量c在输出语句还是报错了，我们改为test6.c则可以，这就说明要通过模块名.变量名来使用其他模块的变量。并输出c的值为3，我们在test6模块中定义了变量c，它的值为3。我们也可以引入模块中的函数。 注意：python是解释型语言，引入模块的时候import语句应该在第一行，如果我们把import语句放在需要调用被引入模块的变量或函数时，python解释器会报错，，如下图所示：如果是子包就需要加上命名空间。import只能导入模块，不能用模块.变量名来导入变量。不过可以import test6 as m(这就是把命名空间简化成一个字符)，引用变量的时候就可以这样： 1234import test6 as fprint(f.c)PS G:\python&gt; python .\test7.py3 可以看到编译器没有报错，而且同样可以运行成功。 1.1.2 模块(module)另一种导入方式语法: 12from py.test import cprint(c) 我们是直接导入了test6的变量c，所以可以直接使用变量c。同样，我们也可以用这种方式导入模块，如下： 12from py import testprint(test.c) 其中py是python包下的子包，它和模块test7.py是属于同一级。如果一个模块有很多变量需要被其他的模块使用那应该怎么导入呢？ 1234567891011from py.test import *print(a)print(b)print(c)print(g)#输出PS G:\python&gt; python .\test7.py1237 可以看到，我们可以用 ‘*’来导入py.test中所有的变量和函数。不过会提示语法错误，但是可以执行。实际开发中并不是所有的变量和函数我们都需要，所以我们还可以控制 * 的导入行为，导入什么不导入什么，在需要被导入的模块中添加如下代码，就说明只导入变量a和b： 1__all__ = [&apos;a&apos;,&apos;b&apos;] python建议一般一行不要超过80个字符。 123456from test5 import a,b,\c# \ 可以换行from test5 import (a,b,c)#括号也可以换行(建议使用)。 init.py是什么？有什么作用？init.py可以帮我们做初始化，我们可以把需要导入的库在这里导入，然后在其他的模块中导入包(要确定该包中有init.py这个文件)。 2，包的导入知识点1，包的导入不会重复2，注意循环导入 1234567891011121314151617181920#test7.pyfrom test8 import t8t7 = 2#test8.pyfrom test7 import t7t8 = 3print(t7)#运行结果PS G:\python&gt; python test8.pyTraceback (most recent call last): File &quot;test8.py&quot;, line 4, in &lt;module&gt; from test7 import t7 File &quot;G:\python\test7.py&quot;, line 34, in &lt;module&gt; from test8 import t8 File &quot;G:\python\test8.py&quot;, line 4, in &lt;module&gt; from test7 import t7ImportError: cannot import name &apos;t7&apos; 这就是循环导入，代码会出问题。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进阶学习一]]></title>
    <url>%2F2019%2F01%2F05%2Fpython%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python进阶学习前面学习python的基本语法和基本数据类型，现在开始进入编程阶段(之前的学习是学习基本的语法和数据结构)，用代码编辑器或专业的IDE来编写并执行python程序。 1，编写一个简单的python程序编写一个简单的python程序，打印输出Hello Python。新建文本文件，输入如下程序代码： 1234a = 1b = 2c = 3print(&apos;Hello Python&apos;) 这个小程序的作用很简单，就是打印输出一条语句，我们把文本的后缀名改为.py，这是python文件的格式，把它保存在某个盘的某个目录下，我这里是保存在G:\python&gt;目录下，在Windows命令行窗口进入该目录，执行dir命令，可以看到有test.py文件；执行该程序，执行的命令是:python .py，代表文件名，我这里是test.py，python文件的截图如下所示： 在命令行窗口执行该程序： 结果如上图所示。 2，小知识点以及编码规范python中形式上的常量字母要大写，当定义一个变量的时候没有定义在类或函数里面并且我们用的是小写字母的时候，，pylint会提示这应该是一个常量，因为pylint就是按照这个标准来判断的。以下代码： 12print(&apos;please input account&apos;)user_account = input() pylintpylint会提示这应该是一个常量，因为这个变量没有在类或函数里，只是在一个模块里。虽然这里input函数返回的应该是一个变量。 pass语句pass语句，也叫占位语句，空语句,为了保证代码的完整性 12if True: pass :空语句，占位语句，保证代码的完整性,比如写API接口的时候，先写一些空的代码，这时候pass就会经常出现。 snippet片段snippet 片段，它的作用可以提高我们的编码效率，相当于代码提示，比如我们输入if，IDE会提示我们可以选择实现什么代码，我们选中就会自动生成一小段代码： 选中后就会自动生成如下代码： )ifelse代码块可以嵌套，如下所示： 12345678910if condition: if condition: pass else: passelse: if condition: pass else: pass if else分支嵌套代码如下所示，运行，输入1，按理应该是输出apple，可是结果却是shopping，为什么？输入2、3也是同样的结果。 123456789101112131415161718192021222324a = input()if a == 1: print(&apos;apple&apos;)else: if a == 2: print(&apos;orange&apos;) else: if a == 3: print(&apos;banana&apos;) else: print(&apos;shopping&apos;)PS G:\python&gt; python .\test5.py1shoppingPS G:\python&gt; python .\test5.py2shoppingPS G:\python&gt; python .\test5.py3shopping 上述代码的解释：a = input(),a是字符串类型并不是整型，我们在 a = input()语句后面加入print(type(a))，看打印的结果： 这就证明了a的类型是str类型，所以a == 2当然是false，代码会执行最后的else后面的print()语句。我们可以将a强转为int类型，这样就可以和数字做比较了。 1234a = input()a = int(a)...... 输入值为1的时候的运行结果: 1234PS G:\python&gt; python .\test5.py1&lt;class &apos;int&apos;&gt;apple 打印出了’apple’，说明 “a == 1”返回了True。根本原因就是input函数，接收的值都认为是字符串，这是动态语言的一个不好的特点，变量没有具体的类型，不像java是强类型语言，这种问题很发现，代码没有写错没有报错信息所以很难解决。这是python语言的一个缺点。 elif的用法elif是else if的简写，上面的代码可以用elif简写如下： 12345678910a = input()print(&apos;a is&apos; + a)if a == 1: print(&apos;apple&apos;)elif a == 2: print(&apos;orange&apos;)elif a == 3: print(&apos;banana&apos;)else: print(&apos;shopping&apos;) 我们用elif对代码进行了重写，这样可以提高代码的阅读性。所有的elif代码块都是同级别的，尽量减少代码的级别减少嵌套，这是很好的编码习惯。上述代码中elif还是要配合if使用的，不能单独出现，最后的else是和elif配对使用的。注意：python中没有switch语句。 3,python循环语句循环是计算机计算解决问题的最常见的思想，计算机里常见的循环有while和for循环。 3.1 while循环123456# 循环语句 # while forCONDITION = Truewhile CONDITION: print(&apos;I am while&apos;) 这是一个循环语句，会一直循环下去，是死循环，条件为真时会一直循环。我们不应该把常量作为while的判断语句，因为常量不会变，条件的判断结果也不会变。 1234567counter = 1while counter &lt;= 10: counter += 1 print(counter)else: print(&apos;EOF&apos;) while条件判断为假时会打印出 “EOF”。不过循环一般用for循环的多，不过有一种情况下while非常合适，就是递归。 3.2，for循环for循环主要用于遍历/循环 序列或者集合、字典中，组概念的数据都可以用for循环，遍历—-for循环。for循环基本结构： 123456789101112a = [&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;grape&apos;]for x in a: print(x)#打印结果PS G:\python&gt; python .\test6.pyappleorangebananagrape########## 循环也可以嵌套循环，以上代码修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;grape&apos;],[1,2,3]]for x in a: print(x)#运行结果PS G:\python&gt; python .\test6.py[&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;, &apos;grape&apos;][1, 2, 3] #注意，这里并没有打印出每个元素，只是打印出了序列中的两个子序列，那如果我们要打印每个子元素(就是打印&quot;orange&quot;和另一个序列中的1,2,3)应该怎么办呢？这个时候我们就可以用循环的嵌套。########循环嵌套a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;grape&apos;],[1,2,3]]for x in a: for y in x: print(x)#运行结果PS G:\python&gt; python .\test6.pyappleorangebananagrape123###########这里就是两个循环,这样打印就没有换行。a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;grape&apos;],[1,2,3]]for x in a: for y in x: print(x,end=&apos;&apos;)#PS G:\python&gt; python .\test6.pyappleorangebananagrape123###########a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;grape&apos;],[1,2,3]]for x in a: for y in x: print(y)else: print(&apos;fruit is gone&apos;) #什么时候执行else语句，当元素遍历结束的时候执行。PS G:\python&gt; python .\test6.pyappleorangebananagrape123fruit is gone############循环终止 a = [1,2,3]for x in a: if x == 2: break print(x)#打印，当x = 2的时候，结束循环PS G:\python&gt; python .\test7.py1a = [1,2,3]#############for x in a: if x == 2: break print(x)#打印，跳出本次循环，继续下次循环PS G:\python&gt; python .\test7.py13#############a = [1,2,3]for x in a: if x == 2: break print(x)else: print(&apos;EOF&apos;)#执行结果PS G:\python&gt; python .\test7.py1#为什么else语句没有执行呢？for和else结合使用正常情况下for语句结束是会执行else语句块的，但是如果for循环是异常终止的话，这种情况就不会执行。那么continue呢？会。#########a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;grape&apos;],[1,2,3]]for x in a: for y in x: if y == &apos;orange&apos;: break print(y)else: print(&apos;fruit is gone&apos;) #什么时候执行else语句，当元素遍历结束的时候执行。#执行结果PS G:\python&gt; python .\test6.pyapple123fruit is gone#为什么这里有break语句，但是还是打印了1 2 3，因为这里有两个循环，break跳出的是里面的循环，不是外面的循环。我们试试跳出外层循环。#########a = [[&apos;apple&apos;,&apos;orange&apos;,&apos;banana&apos;,&apos;grape&apos;],[1,2,3]]for x in a: if &apos;banana&apos; in x: break for y in x: if y == &apos;orange&apos;: break print(y)else: print(&apos;fruit is gone&apos;) #什么时候执行else语句，当元素遍历结束的时候执行。#执行结果PS G:\python&gt; 123456789101112131415for x in range(0,10): print(x)#执行结果PS G:\python&gt; python .\test7.py0123456789相当于java中的 for (int x=0;x &lt;=10;x++&gt;)&#123;System.out.println(x)&#125; python的range函数，可以按照我们制定的规则生成一个序列。比如上面代码就是生成了一个0到9的序列，rage[0,10]：从1开始，不包含10，10在这里代表偏移量。再比如：range(0,10,2)什么意思呢？ 12345for x in range(0,10,2): print(x,end = &apos; | &apos;)#打印PS G:\python&gt; python .\test7.py0 | 2 | 4 | 6 | 8 | 再看： 12345for x in range(10,0,-2): print(x,end = &apos; | &apos;)#打印PS G:\python&gt; python .\test7.py10 | 8 | 6 | 4 | 2 | range(0,10,2)表示从0开始到10(不包含10)递增打印数字(公差为2)；range(10,0,-2)表示从10到0(不包含0)递减打印数字(公差为2)，第三个参数为-2，大的数在第一个参数位置。 12345678910a = [1,2,3,4,5,6,7,8]# for x in range(0,len(a),2):# print(a[x],end = &apos; | &apos;)b = a[0:len(a):2]print(b)#执行结果PS G:\python&gt; python .\test7.py[1, 3, 5, 7] 如上代码所示，a[0:len(a):2]意思是 引申：为什么python没有switch语句？在Design and History FAQ网站中，有关于这个问题的回答。官方的回答是我们可以用if … elif … elif …… else 语句块来起到其他语言中switch语句同样的效果，或者当需要从很多数量的case中去选择，那就建议用字典(dict)，官方原话是：”For cases where you need to choose from a very large number of possibilities,you can create a dictionary mapping case values to functions to call. For example:”。小总结一下，也就是官方推荐这两种方式来代替switch语句，或者准确地说，用这两种方式起到switch语句在其它语言中起到的作用。 python为什么没有其他语言几乎都有的switch语句]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础学习三]]></title>
    <url>%2F2019%2F01%2F05%2Fpython%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[表达式定义：表达式：是运算符和操作数所构成的序列。a = [1,2,3]、a &gt; b是表达式，1 + 1也是表达式，a = 1 + 2 * 3也是表达式，=也是运算符(赋值运算符)。 12345678910111213141516171819202122232425262728&gt;&gt;&gt; a=1&gt;&gt;&gt; b = 2&gt;&gt;&gt; c = 3&gt;&gt;&gt; a + b * c7&gt;&gt;&gt; a or b and c1//and优先级高于or，以下是对a or b and c的分解，b和c先做与运算，得到的结果再与a做或运算。&gt;&gt;&gt; a or b and c1&gt;&gt;&gt; b and c3&gt;&gt;&gt; 1 or 3//逻辑运算符优先级最低，**运算符最高(指数运算)，and优先级高于or。运算规则：如果操作符优先级同级，解释器就从左向右运算， 3 + 2 -1：从左向右运算。如果想强制让解释器按照自己的要求进行运算的顺序调整，用括号，括号的优先级最高，如果有两个括号？那就是从第一个开始运算，然后两个括号的运算结果再进行运算。从左至右：左结合。通常都是左结合；但是也有特例，赋值运算符，c = a + b;先运算a + b，再赋值给c，而不能是c = a,再与b相加。再如：c = a or b; = 的优先级比or高，但是还是a和b运算，再赋值给c。&gt;&gt;&gt; not a or b + 2 == c //左结合规则(没有赋值运算符)False它等价于：&gt;&gt;&gt; (not a) or ((b + 2) == c)False优先级：not &gt; and &gt; or&gt;&gt;&gt; not a or b + 2 == cFalse&gt;&gt;&gt; (not a )or ((b + 2) == c)False//可以用括号辅助理解，根据运算符号的优先级。优先级：算术运算符优先级 &gt; 比较运算符 &gt; 逻辑运算符。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础学习二]]></title>
    <url>%2F2019%2F01%2F04%2Fpython%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[变量与运算符1，基本的运算假如有列表A[1,2,3,4,5,6]和列表B[1,2,3]两个列表，对这两个列表做以下运算：A乘以3，再加上B，最后再加上列表A。我们容易可以写出如下代码： 12&gt;&gt;&gt; [1,2,3,4,5,6]*3 + [1,2,3] + [1,2,3,4,5,6][1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 1, 2, 3, 4, 5, 6] 这样运算就很麻烦，我们引入了变量，比如可以用一个变量表示[1,2,3,4,5,6]这个列表。变量的定义：A = [1,2,3,4,5,6]。B = [1,2,3]。那么我们上面的运算就可以写成 A*3 + B + A，这样就方便多了。 12345678910111213141516&gt;&gt;&gt; A = [1,2,3,4,5,6] //变量A代表列表[1,2,3,4,5,6] &gt;&gt;&gt; print(A) [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; B = [1,2,3] //定义变量B &gt;&gt;&gt; print(B) //打印变量B [1, 2, 3]//做运算&gt;&gt;&gt; A*3 + B + A [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 1, 2, 3, 4, 5, 6] 其中 “B = [1,2,3]”中的 “=”是赋值运算符。不过给变量起名字尽量要具有可读性，尽量表达出它的意义，这里举例子中的A和B显然就不合适，这不是合适的命名方式。我们要尽量提高代码的可阅读性，这是写出优质的代码的一个很重要的前提。尽量用英语给变量命名(千万不要用拼音)。 2,变量与运算的基本规范 1，可以用数字、字母、下划线来定义变量，首字母不能是数字。 2，系统已经使用了的关键字(也叫保留关键字，比如and、if、import，因为他们都是保留关键字)，不能被用于变量中。 3，type可以作为变量名(不建议这样使用，会产生歧义) 4，变量名是区分大小写， 5，变量没有类型限制(这也是python被称为动态语言的最大的缘由) 6，12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = a &gt;&gt;&gt; a = 3 &gt;&gt;&gt; print(b) 1b的值为1，不是3，没有改变。int、str、tuple都是不可变的；set、list、dict是可变的。&gt;&gt;&gt; a = [1,2,3,4,5] &gt;&gt;&gt; b = a &gt;&gt;&gt; a[0] = &apos;1&apos; &gt;&gt;&gt; print(a) [&apos;1&apos;, 2, 3, 4, 5]&gt;&gt;&gt; print(b) [&apos;1&apos;, 2, 3, 4, 5]在这里列表第一个元素改变了，为什么？int类型和list是截然不同的额，int称为值类型，list是引用类型，它们的区别：类似于java中的基本数据类型和引用类型，&gt;&gt;&gt; a = &quot;hello&quot; &gt;&gt;&gt; a = a + &quot;world&quot; &gt;&gt;&gt; print(a) helloworld字符串不是不可变的么？这里a怎么貌似从&quot;hello&quot;变成了&quot;helloworld&quot;。实际上不是，a = a + &quot;world&quot;生成了一个新的字符串，我们再看python的一个函数id(),用于显示某一个变量在内存的地址。&gt;&gt;&gt; b = &quot;hello&quot; &gt;&gt;&gt; id(b) 1979272160456&gt;&gt;&gt; b = b + &quot;python&quot; &gt;&gt;&gt; id(b) 1979272322480可以看到两次调用id方法b的地址是不同的，这就说明生成了一个行的字符串。再看：&gt;&gt; &apos;python&apos;[0] &apos;p&apos;&gt;&gt;&gt; &apos;python&apos;[0]=&apos;o&apos; Traceback (most recent call last): File &quot;&lt;pyshell#40&gt;&quot;, line 1, in &lt;module&gt; &apos;python&apos;[0]=&apos;o&apos;TypeError: &apos;str&apos; object does not support item assignment这里就报错了，错误信息显示str是不可变的。&gt;&gt;&gt; type = 1 &gt;&gt;&gt; type(1) Traceback (most recent call last): File &quot;&lt;pyshell#29&gt;&quot;, line 1, in &lt;module&gt; type(1)TypeError: &apos;int&apos; object is not callable报错，因为type已经是一个变量了，不能使用type(1)作为函数调用，所以尽量不要用type来命名变量，同样print也不要用来当变量名。 3，python运算符3.1 比较运算符1234567891011121314151617181920&gt;&gt;&gt; 1&gt;1False&gt;&gt;&gt; &apos;a&apos;&gt;&apos;b&apos;False&gt;&gt;&gt; ord(&apos;a&apos;)97&gt;&gt;&gt; ord(&apos;b&apos;)98 //ACSII码&gt;&gt;&gt; &apos;abc&apos;&lt;&apos;abd&apos; // 比较ASCII值，而且是逐个比较，相同就往后继续比，c(99)的ASCII值比d(100)小。True//列表比较，也是逐个比较&gt;&gt;&gt; [1,2,3]&lt;[1,2,3]False&gt;&gt;&gt; [1,2,3]&lt;[1,2,4]True//元组比较&gt;&gt;&gt; (1,2,3)&lt;(1,2,3)False&gt;&gt;&gt; (1,2,3)&lt;(1,2,4)True 3.2 逻辑运算符逻辑运算符有and、or、not，它对布尔值进行运算，他们相关运算的规则与示例如下代码所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//and 与运算&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse//or 或运算&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse//not 非&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not not TrueTrue//思考代码：&gt;&gt;&gt; 1 and 11&gt;&gt;&gt; &apos;a&apos; and &apos;a&apos;&apos;a&apos;&gt;&gt;&gt; &apos;a&apos; or &apos;b&apos;&apos;a&apos;&gt;&gt;&gt; not&apos;a&apos;False以上代码实际上也是成立的，逻辑运算符两边也是布尔型的值，1是True，与布尔型有一个转换，not &apos;a&apos; == not True。对于int、float类型的数，0被认为是False，非零表示True。对于字符串：空字符串 False，非空字符串：True，所以以上的代码就可以理解了。&gt;&gt;&gt; not &apos;0&apos; //是字符串，而且非空，所以为True，不是0。False//列表:空的列表 False，非空列表 True,tuple、list、dict和列表类似。&gt;&gt;&gt; not[]True&gt;&gt;&gt; not[1]False//返回结果是[1]，实际上它是布尔型，非空的列表，就是True，[1]与布尔型的值有转换。&gt;&gt;&gt; [1]or[][1]&gt;&gt;&gt; []or[1][1]//字符串&gt;&gt;&gt; &apos;a&apos;and&apos;b&apos;&apos;b&apos;&gt;&gt;&gt; &apos;&apos;and&apos;b&apos;&apos;&apos;//&gt;&gt;&gt; not 0True&gt;&gt;&gt; 1 and 00&gt;&gt;&gt; 0 and 10&gt;&gt;&gt; 1 and 22&gt;&gt;&gt; 2 and 11&gt;&gt;&gt; 0 and 10&gt;&gt;&gt; 1 and 22//只要一个数值就可以表示结果，选择最后一个，&gt;&gt;&gt; 1 or 01&gt;&gt;&gt; 1 or 2 //读到第一个值的时候就已经可以得出结果了，所以就返回了。1 3.3 成员运算符成员运算符有两个，in、not in，就是在或不在。表示一个元素是否在一组元素里。相关运算： 12345678910111213141516171819202122232425262728293031323334//in&gt;&gt;&gt; a=1&gt;&gt;&gt; a in [1,2,3,4,5]True&gt;&gt;&gt; b = 6&gt;&gt;&gt; b in [1,2,3,4,5]False//not in&gt;&gt;&gt; b not in [1,2,3,4,5]True&gt;&gt;&gt; a not in [1,2,3,4,5]False&gt;&gt;&gt; b = &apos;h&apos;&gt;&gt;&gt; b in &apos;hhee&apos;True&gt;&gt;&gt; b not in (1,2,3,4,5)True&gt;&gt;&gt; b not in&#123;1,2,3,4,5,&#125;True//字典的成员运算符&gt;&gt;&gt; b = &apos;a&apos;&gt;&gt;&gt; b in &#123;&apos;c&apos;:1&#125;False&gt;&gt;&gt; b = 1&gt;&gt;&gt; b in &#123;&apos;c&apos;:1&#125;False&gt;&gt;&gt; b = &apos;c&apos;&gt;&gt;&gt; b in &#123;&apos;c&apos;:1&#125;True字典的成员运算是针对key，字典的key。 3.4 身份运算符身份运算符有：is、is not。用于对象的判断，返回值是布尔值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&gt;&gt;&gt; a = &apos;hello&apos;&gt;&gt;&gt; b = &apos;hello&apos;&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1.0&gt;&gt;&gt; a==bTrue&gt;&gt;&gt; a=1&gt;&gt;&gt; b = 1.0&gt;&gt;&gt; a is bFalse//关系运算符(==)比较的是值是否相等，is不是比较值，比较的是两个变量身份是否相等(内存地址是否相等)。&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1.0&gt;&gt;&gt; id (a)1799908384&gt;&gt;&gt; id(b)2825402717672&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bFalse//地址值不同，所以is返回False，== 返回True。//集合的运算&gt;&gt;&gt; a = &#123;1,2,3&#125;&gt;&gt;&gt; b = &#123;2,1,3&#125;&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a is bFalse//元组的运算&gt;&gt;&gt; c = (1,2,3)&gt;&gt;&gt; d = (2,1,3)&gt;&gt;&gt; c == dFalse&gt;&gt;&gt; c is dFalse&gt;&gt;&gt; id(a)2026157550504&gt;&gt;&gt; id(b)2026157966056//分析：集合和元组不同，集合是无序的，&#123;1,2,3&#125;和&#123;2,1,3&#125;， == 是比较值，所以相等；is比较内存地址，所以返回False。而元组是有序的，做值的比较返回时False。 对象的三个特征：1，值；2，身份；3，类型。python中，一切皆对象(is,==,isinstance)。 12345678910111213&gt;&gt;&gt; a = &apos;hello&apos;&gt;&gt;&gt; type(a) == int //不建议使用False&gt;&gt;&gt; type(a) == strTrue&gt;&gt;&gt; isinstance(a,str)True&gt;&gt;&gt; isinstance(a,int) //建议使用，isinstance可以判断值类型是属于哪一种，而type不可以。False&gt;&gt;&gt; isinstance(a,(int,str,float)) //是否是三种中任意一种True&gt;&gt;&gt; isinstance(a,(int,float))False 3.5 位运算符位运算符有这几种：&amp;:按位与;|:按位或；^:按位异或;~:按位取反;&lt;&lt;:左移;&gt;&gt;:右移。 位运算符我们平时开发中使用的较少，可以稍作了解。位运算符都是对二进制数运算(把数字当做二进制进行运算)。 123456&gt;&gt;&gt; a = 2&gt;&gt;&gt; b =3&gt;&gt;&gt; a &amp; b2&gt;&gt;&gt; a | b3]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习一]]></title>
    <url>%2F2019%2F01%2F04%2FPython%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1，python的基本数据类型python是一门很灵活的语言，俗称”胶水语言”。”人生苦短，我用python”。 python之禅 123456789101112131415161718192021The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&apos;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&apos;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&apos;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&apos;s do more of those! python的基本数据类型：int、float(单精度和双精度都是用float表示，不像java一样有float和double之分)。 2，python的数据结构列表比如[1,2,3]是一个列表，用type([1,2,3])函数会输出 class ‘list’，class表示是什么类型，这里说明[1,2,3]是一个列表，列表可以嵌套：[[1,2,3],[‘123’],[True]]也是一个列表，元素可以是不同的类型。 元组python有很多种方法可以表示元组，先学习其中一种：(1,2,3,4)，(1,2,’True’)都是元组。type((1,2,3))得出数据类型是 tuple，tuple就是元组的意思。 为什么是 int 12&gt;&gt;&gt; type((1))&lt;class &apos;int&apos;&gt; 以上按照我们理解应该是一个元组，只有一个元素，为什么不是呢？而是int型呢？什么原因？再看： 12&gt;&gt;&gt; type((&apos;helo&apos;))&lt;class &apos;str&apos;&gt; 其实括号还有运算的作用，比如 (1+1)*2,我们都知道显示1和1相加再乘以2，因为括号的优先级在这里高于乘号，编译器怎么猜测我们是想运算还是定义一个元组呢，这时候编译器就不知道了，所以python编译器硬性规定，括号只有一个元素的这种情况为运算，不是元组。那怎么定义只有一个元素的元组呢？，(1,)：加一个逗号，假装后面还有一个元素。 12&gt;&gt;&gt; type((1,))&lt;class &apos;tuple&apos;&gt; 这个时候type函数返回的就是tuple类型了。定义元素为空的元组,()。括号里面什么也没有。 12&gt;&gt;&gt; type(())&lt;class &apos;tuple&apos;&gt; 可以看到 “()”是一个元组，只不过里面没有元素。type([1])返回什么呢？返回list，是列表类型。 12&gt;&gt;&gt; type([1])&lt;class &apos;list&apos;&gt; 元组也叫序列，str、tuple、list都是序列，序列的共有操作： ‘hello world’[2] :序列的每个元素都会分配一个序号(或者角标，它有顺序) 切片：[1,2,3,4,5][0:3];[1,2,3,4,5][-1:]; ‘hello world’[0:8:2],这里有三个数，什么意思？ 是否包含某个元素：3 in [1,2,3,4,5]，返回True，10 in [1,2,9]，返回False，3 not in [1,2,3]，返回False。 求元素长度，len([1,2,3,4,5,6])，返回6；len(‘hello world’),返回11，max([1,2,3,4,5,7]),求最大值，返回7，min([1,2,7]),求最小值，返回1；max(‘helloowrld’)，返回’w’，min(‘helloowrld’)，返回’d’，也是ASCII码最大最小。如果是代码min(‘helloowrld’)，就输出空格，如下所示： 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; 3 in [1,2,3]True&gt;&gt;&gt; 10 in [1,2,9]False&gt;&gt;&gt; 3 not in [1,2,3]False&gt;&gt;&gt; len([1,2,3,4,5,6])6&gt;&gt;&gt; len(&apos;hello world&apos;)11&gt;&gt;&gt; max([1,2,3,4,5,7])7&gt;&gt;&gt; min([1,2,7])1&gt;&gt;&gt; max(&apos;helloowrld&apos;)&apos;w&apos;&gt;&gt;&gt; min(&apos;helloowrld&apos;)&apos;d&apos;&gt;&gt;&gt; min(&apos;hello owrld&apos;)&apos; &apos; ord()函数可以求字符的ASCII码， 12345&gt;&gt;&gt; ord(&apos;a&apos;)97&gt;&gt;&gt; ord(&apos; &apos;)32 3,数据结构之set集合很重要的一个特性：无序。 定义{1,2,3,4,5,6}是一个集合 12&gt;&gt;&gt; type(&#123;1,2,3,4,5,6&#125;)&lt;class &apos;set&apos;&gt; 集合是无序的，没有角标，也就是没有索引，和序列的操作很不同。12345&gt;&gt;&gt; &#123;1, 2&#125;[1]Traceback (most recent call last): File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt; &#123;1, 2&#125;[1]TypeError: &apos;set&apos; object does not support indexing 如上，如果想对集合类似于序列的操作(在这里是找出第二个元素编译亲会报错，不支持索引，这是集合和序列的一大区别) 无重复元素。12&gt;&gt;&gt; &#123;1,1,2,2&#125;&#123;1, 2&#125; 集合基本操作： 12345678910111213141516171819202122232425262728&gt;&gt;&gt; len(&#123;1,2,3&#125;)3&gt;&gt;&gt; 1 in &#123;1,2,4&#125;True&gt;&gt;&gt; 1 not in &#123;1,2,4&#125;False从一个集合中去除另一个集合的元素：&gt;&gt;&gt; &#123;1,2,3,4,5,6&#125;-&#123;1,2,5,6&#125;&#123;3, 4&#125;得到&#123;3,4&#125;，注意这里&quot;-不是减法操作，而是求两个集合的差集。&#123;1,2,3,4,5,6&#125; &#123;4,5&#125;,求交集&gt;&gt;&gt; &#123;1,2,3,4,5,6&#125;&amp;&#123;4,5&#125;&#123;4, 5&#125;&#123;1,2,3,4,5,6&#125; &#123;3，4,7&#125;，求并集：&gt;&gt;&gt; &#123;1,2,3,4,5,6&#125;|&#123;3,4,7&#125;&#123;1, 2, 3, 4, 5, 6, 7&#125;定义一个空的集合,需要用到set关键字：&gt;&gt;&gt; type(set())&lt;class &apos;set&apos;&gt;&gt;&gt;&gt; len(set())0set集合长度为0 字典dict字典的key，字典的value。通过key查询value。字典可以有很多个key和value。 123456789101112131415161718192021222324252627282930313233&#123;key1:value1,key2:value2....&#125;：字典的定义，它和set有什么区别？在于每一个元素的定义，set单个，字典是键值对。&gt;&gt;&gt; type(&#123;1:4,2:2&#125;)&lt;class &apos;dict&apos;&gt;字典的访问方式：&gt;&gt;&gt; &#123;&apos;Q&apos;:&apos;新月打击&apos;,&apos;w&apos;:&apos;苍白之瀑&apos;,&apos;R&apos;:&apos;月神冲刺&apos;&#125;[&apos;Q&apos;]&apos;新月打击&apos;&gt;&gt;&gt; &#123;&apos;Q&apos;:&apos;新月打击&apos;,&apos;Q&apos;:&apos;月之&apos;,&apos;w&apos;:&apos;苍白之瀑&apos;,&apos;R&apos;:&apos;月神冲刺&apos;&#125;[&apos;Q&apos;]&apos;月之&apos;&gt;&gt;&gt; &#123;&apos;Q&apos;:&apos;新月打击&apos;,&apos;Q&apos;:&apos;月之&apos;,&apos;w&apos;:&apos;苍白之瀑&apos;,&apos;R&apos;:&apos;月神冲刺&apos;&#125;&#123;&apos;Q&apos;: &apos;月之&apos;, &apos;w&apos;: &apos;苍白之瀑&apos;, &apos;R&apos;: &apos;月神冲刺&apos;&#125;字典没有重复的键，&gt;&gt;&gt; &#123;1:&apos;新月打击&apos;,&apos;1&apos;:&apos;月之&apos;,&apos;w&apos;:&apos;苍白之瀑&apos;,&apos;R&apos;:&apos;月神冲刺&apos;&#125;&#123;1: &apos;新月打击&apos;, &apos;1&apos;: &apos;月之&apos;, &apos;w&apos;: &apos;苍白之瀑&apos;, &apos;R&apos;: &apos;月神冲刺&apos;&#125;key不一定是字符串，也可以是数字，但是它必须是不可变的类型(int、str)；value：str、int、float、list、set、dict。value几乎可以是任意的数据类型。&gt;&gt;&gt; &#123;[1,2]: &apos;新月打击&apos;, &apos;1&apos;: &apos;月之&apos;, &apos;w&apos;: &apos;苍白之瀑&apos;, &apos;R&apos;: &apos;月神冲刺&apos;&#125;Traceback (most recent call last): File &quot;&lt;pyshell#57&gt;&quot;, line 1, in &lt;module&gt; &#123;[1,2]: &apos;新月打击&apos;, &apos;1&apos;: &apos;月之&apos;, &apos;w&apos;: &apos;苍白之瀑&apos;, &apos;R&apos;: &apos;月神冲刺&apos;&#125;TypeError: unhashable type: &apos;list&apos;key不能为[1,2]，也就是说不能是列表，那么元组呢？&gt;&gt;&gt; &#123;(1,2): &apos;新月打击&apos;, &apos;1&apos;: &apos;月之&apos;, &apos;w&apos;: &apos;苍白之瀑&apos;, &apos;R&apos;: &apos;月神冲刺&apos;&#125;&#123;(1, 2): &apos;新月打击&apos;, &apos;1&apos;: &apos;月之&apos;, &apos;w&apos;: &apos;苍白之瀑&apos;, &apos;R&apos;: &apos;月神冲刺&apos;&#125;可以是元组。以上代码可以通过运行。空的字典怎么定义？&gt;&gt;&gt; type(&#123;&#125;)&lt;class &apos;dict&apos;&gt; 总结python基本数据类型图解： 字符串不可变，列表可变。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之建造者模式(Builder模式)]]></title>
    <url>%2F2018%2F12%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转载自刘望舒博客建造者模式 1，建造者模式定义建造者模式（builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 简介建造者模式（builder）是创建一个复杂对象的创建型模式，将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示分离开来。例如我们要DIY一个台式机电脑，我们找到DIY商家，我们可以要求这台电脑的cpu或者主板或者其他的部件都是什么牌子的什么配置的，这些部件是我们可以根据我们的需求来变化的，但是这些部件组装成电脑的过程是一样的，我们不需要知道这些部件是怎样组装成电脑的，我们只需要提供部件的牌子和配置就可以了。对于这种情况我们就可以采用建造者模式，将部件和组装过程分离，使得构建过程和部件都可以自由拓展，两者之间的耦合也降到最低。 建造者模式UML图 Dirextor: 指挥者类，用于统一组装流程 Builder：抽象Builder类，规范产品的组建，一般是由子类实现。 ConcreteBulider: 抽象Builder类的实现类，实现抽象Builder类定义的所有方法，并且返回一个组建好的对象 Product:产品类 2,建造者模式简单实现这里我们就用DIY组装电脑的例子来实现一下建造者模式。 创建产品类我要组装一台电脑，电脑被抽象为Computer类，它有三个部件:CPU 、主板和内存。并在里面提供了三个方法分别用来设置CPU 、主板和内存： 1234567891011121314151617public class Computer &#123; private String mCpu; private String mMainboard; private String mRam; public void setmCpu(String mCpu) &#123; this.mCpu = mCpu; &#125; public void setmMainboard(String mMainboard) &#123; this.mMainboard = mMainboard; &#125; public void setmRam(String mRam) &#123; this.mRam = mRam; &#125;&#125; 创建Builder类规范产品的组建商家组装电脑有一套组装方法的模版，就是一个抽象的Builder类,里面提供了安装CPU、主板和内存的方法，以及组装成电脑的create方法： 123456public abstract class Builder &#123; public abstract void buildCpu(String cpu); public abstract void buildMainboard(String mainboard); public abstract void buildRam(String ram); public abstract Computer create();&#125; 商家实现了抽象的Builder类，MoonComputerBuilder类用于组装电脑： 12345678910111213141516171819202122public class MoonComputerBuilder extends Builder &#123; private Computer mComputer = new Computer(); @Override public void buildCpu(String cpu) &#123; mComputer.setmCpu(cpu); &#125; @Override public void buildMainboard(String mainboard) &#123; mComputer.setmMainboard(mainboard); &#125; @Override public void buildRam(String ram) &#123; mComputer.setmRam(ram); &#125; @Override public Computer create() &#123; return mComputer; &#125;&#125; 用Dirextor指挥者类来统一组装过程商家的指挥者类用来规范组装电脑的流程规范，先安装主板，再安装CPU，最后安装内存并组装成电脑： 12345678910111213public class Direcror &#123; Builder mBuild=null; public Direcror(Builder build)&#123; this.mBuild=build; &#125; public Computer CreateComputer(String cpu,String mainboard,String ram)&#123; //规范建造流程 this.mBuild.buildMainboard(mainboard); this.mBuild.buildCpu(cpu); this.mBuild.buildRam(ram); return mBuild.create(); &#125;&#125; 客户端调用指挥者类最后商家用指挥者类组装电脑。我们只需要提供我们想要的CPU，主板和内存就可以了，至于商家怎样组装的电脑我们无需知道。 12345678public class CreatComputer &#123; public static void main(String[]args)&#123; Builder mBuilder=new MoonComputerBuilder(); Direcror mDirecror=new Direcror(mBuilder); //组装电脑 mDirecror.CreateComputer(&quot;i7-6700&quot;,&quot;华擎玩家至尊&quot;,&quot;三星DDR4&quot;); &#125;&#125; 3,使用建造者模式的场景和优缺点使用场景 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 相同的方法，不同的执行顺序，产生不同的事件结果时。 多个部件或零件,都可以装配到一个对象中，但是产生的运行结果又不相同时。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。 创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。 优缺点优点 使用建造者模式可以使客户端不必知道产品内部组成的细节。 具体的建造者类之间是相互独立的，容易扩展。 由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。 缺点 产生多余的Build对象以及Dirextor类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议浅析]]></title>
    <url>%2F2018%2F12%2F27%2FHttp%E5%8D%8F%E8%AE%AE%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、基本网络相关概念1，网络分层分层为了将网络节点所要完成的数据的发送或转发、打包或拆包，以及控制信息的加载或拆出工作，分别由不同的硬件和模块来完成，这样分层的好处是可以可以将通信和网络互联这一原本复杂的问题简单化，网络分层有经典的七层网络和五层，一般来说五层协议更加常用，应用更广泛，因为它更好理解。网络分层的每一层都是为了完成某一种功能而设计的。为了实现这些功能就要遵守共同的规则，就是协议规则。 如上图所示，从上到下一次分为应用层、传输层、网络层、数据链路层和物理层。我们比较关心的是应用层和传输层，这两层与我们平时的开发相关性较大。著名的TCP协议就是处于传输层(包括不可靠通信协议UDP，TCP是可靠的)；而Http、FTP、SMTP、POP3位于应用层。2，TCP协议的三四握手与四次挥手在分析OkHttp框架的时候会用到TCP的相关知识，通常我们进行HTTP连接的时候会进行TCP的三次握手，然后传输数据，之后再释放；连接。TCP传输如图所示： 三次握手和的过程详细如下： 三次握手过程 a,第一次握手，建立连接。客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。 b,第二次握手：服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。 c，第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。四次挥手过程 a,首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u，此时客户端进入FIN_WAIT_1状态，表示客户端没有数据要发送给服务端了。 b,服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加1。 c,服务端想客户端发送一个FIN给客户端，请求关闭连接，同时服务端进入LAST_ACK状态。 d,客户端收到FIN报文段后，发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。客户端发送FIN后，进入终止等待状态，服务器收到客户端连接释放报文段后，就立即给客户端发送确认，服务器就进入CLOSE_WAIT状态，此时TCP服务器进程就通知高层应用进程，因而从客户端到服务器的连接就释放了。此时是“半关闭状态”，即客户端不可以发送给服务器，服务器可以发送给客户端。 此时，如果服务器没有数据报发送给客户端，其应用程序就通知TCP释放连接，然后发送给客户端连接释放数据报，并等待确认。客户端发送确认后，进入TIME_WAIT状态，但是此时TCP连接还没有释放，然后经过等待计时器设置的2MSL后，才进入到CLOSE状态。 如果有大量的连接，每次连接、关闭时都要经历三次握手、四次挥手，这显然很浪费资源造成性能下降。因此Http有一种keepalive-connections的机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而无需再次建立连接了。 TCP协议常见问题： 为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？我们来分析一种特殊情况，假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的过程中数据丢失，客户端认为连接没有建立，会进行重传。假设每次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪水攻击”。总结：第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。 为什么需要2MSL时间？首先，MSL即Maximum Segment Lifetime，就是最大报文生存时间，是任何报文在网络上的存在的最长时间，超过这个时间报文将被丢弃。《TCP/IP详解》中是这样描述的：MSL是任何报文段被丢弃前在网络内的最长时间。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒、1分钟、2分钟等。 为什么是四次挥手，而不是三次或是五次、六次？双方关闭连接要经过双方都同意。所以，首先是客服端给服务器发送FIN，要求关闭连接，服务器收到后会发送一个ACK进行确认。服务器然后再发送一个FIN，客户端发送ACK确认，并进入TIME_WAIT状态。等待2MSL后自动关闭。 总结：（1）为了保证客户端发送的最后一个ACK报文段能够到达服务器。即最后一个确认报文可能丢失，服务器会超时重传，然后服务器发送FIN请求关闭连接，客户端发送ACK确认。一个来回是两个报文生命周期。 如果没有等待时间，发送完确认报文段就立即释放连接的话，服务器就无法重传，因此也就收不到确认，就无法按步骤进入CLOSE状态，即必须收到确认才能close。（2）防止已经失效的连接请求报文出现在连接中。经过2MSL，在这个连续持续的时间内，产生的所有报文段就可以都从网络消失。 二、Http协议原理1,Http简介Http是位于应用层协议，由于简介、快速的特性，广泛用于分布式超媒体信息系统。于1990年被提出，经过几年的发展，得到不断的完善。 HTTP的历史版本 HTTP0.9:1991年，只有一个GET命令，服务器只能回应HTML格式的字符串 HTTP1.0:1996年发布，内容增加很多，除了GET命令外，还增加了POST命令和HEAD命令。HTTP请求和响应的格式除了部分数据，每次通信都必须包括头信息，用来描述一些元数据 HTTP1.1:1997年发布，进一步完善了，现在还是最流行的版本。 SPDY:2009年谷歌为了解决Http1.1效率不高的问题而自行研究的协议 HTTP2:2015年新发布的协议，SPDY协议的主要特性也包含在里面 HTTP协议的主要特点 支持C/S(客户端/服务端)模式 简单快速：Client想Server请求服务时，只需要传输请求方法和路径。请求方法常用的有GET、HEAD、POST，每种方法都规定了客户端与服务端联系的类型的不同。由于HTTP协议简单，使得HTTP协议服务器的程序规模，因而通信速度快 灵活：HTTP允许传输任意类型的对象，正在传输的类型由Content-Type加以标记， 无连接：每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间 无状态：HTTP协议是无状态的，无状态是指协议对于事物处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大；而另一方面，在服务器不需要先前信息时它的应答速度就很快 HTTP URL协议格式： 1http://host[&quot;:&quot;port][abs_path] 协议各部分代表的意义 http:代表使用HTTP协议来访问服务器 host：表示合法的Internet主机域名或者ip地址 oort：表示指定一个端口号，为空则默认为80 abs_path:指请求资源的URI(web上任意的可用资源) HTTP状态码 200 请求成功 301 资源被永久转移到其他URL 404 请求的资源不存在 500 内部服务器错误]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨程序共享数据--Android之内容提供器(ContentProvider)学习]]></title>
    <url>%2F2018%2F12%2F25%2F%E8%B7%A8%E7%A8%8B%E5%BA%8F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-Android%E4%B9%8B%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8-ContentProvider-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一、访问其他程序中的数据内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序的数据，另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口。 二、ContentProvider的基本用法想要访问一个应用程序中共享的数据，就要借助ContentResolver这个类，可通过Context的getContentResolver()得到这个类的实例。ContentResolver类提供了一系列的方法用于对于进行CRUD操作，其中insert()用于添加数据，update()用于更新数据，delete()方法用于更新数据，query()方法用于查询数据。SQLiteDatabase也是用这几个方法来进行CRUD操作，只不过他们在方法参数上有些区别。 不同于SQLiteDatabase，ContentResolver类的CRUD是不接收表名参数的，而是使用Uri参数代替，它被称为内筒URI，它给内容提供器中的数据建立了唯一的标识符，由两部分组成：authority和path，authority是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。比如某个程序的包名是com.example.app，那么该程序的authority就可命名为com.example.app.provider；path则是一般用于对同一应用的不同表做区分的，通常会添加到authority后面，如有两张表table1、table2，path就可命名为/table1和/table2,然后将authority与path进行组合，内容URI就成为了com.example.app.provider/table1和com.example.app.provider/table2。我们会在这个字符串的头部加上协议声明: 12content://com.example.app.provider/table1content://com.example.app.provider/table2 内容URI可以非常清楚地表达我们想要访问哪个程序中哪张表的数据。也正因如此，ContentResolver中的CRUD方法才都接收Uri对象作为参数，因为如果使用表名的话，系统将无法得知我们期望访问的是哪个应用程序里的表。 得到内容URI字符串之后，我们还要将它们解析成Uri对象才可以作为参数传入，解析的方法如下： 1Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;); 只需要调用Uri.parse()方法，就可以将内容Uri字符串解析成Uri对象了。解析之后我们就可以使用这鞥Uri对象来查询table1中的数据了，代码如下： 1234567Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder); 查询完成后返回的是一个Cursor对象，这时候我们可以将Cursor对象从Cursor对象中逐个读取出来，读取的思路仍然是通过移动游标的位置来遍历Cursor的所有行，然后再取出每一行中相应列的数据，代码： 123456if (cursor != null) &#123; while (cursor.moveToBext) &#123; String column1 = cursor.getString(cursor.getColumnIndex(&quot;column1&quot;); int column2 = cursor.getInt(cursor.getColumnIndex(&quot;column2&quot;)); &#125;&#125; 向table1中添加一条数据 1234ContentValues values = new ContentValues();values.put(&quot;column1&quot;,&quot;text&quot;);values.put(&quot;column1&quot;,1);getContentResolver().insert(uri,values); 可以看到，是将待添加的数据组黄到ContentValues中，然后调用ContentResolver的insert()方法，将Uri和ContentValues作为参数传入即可。如果想更新这条添加的数据，把column1的值清空，可以借助ContentResolver的update方法实现，代码如下： 123ContentValues values = new ContentValues();values.put(&quot;column1&quot;,&quot;&quot;);getContentResolver().update(uri,values,&quot;column1 = ? and column2 = ?&quot;,new String[] &#123;&quot;text&quot;,&quot;1&quot;&#125;); 1,读取联系人项目源代码地址：读取联系人(ContactsTest)这是一个读取手机联系人信息的项目，我们希望读取联系人的信息并能够在listview中显示出来，修改activity_main.xml，代码如下： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;ListView android:id=&quot;@+id/contacts_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 在MainActivity的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends AppCompatActivity &#123; ArrayAdapter&lt;String&gt; adapter; List&lt;String&gt; contactsList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView contactsView = findViewById(R.id.contacts_view); adapter = new ArrayAdapter&lt;&gt;(this,android.R.layout.simple_list_item_1,contactsList); contactsView.setAdapter(adapter); if (ContextCompat.checkSelfPermission(this,Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(this,new String[] &#123;Manifest. permission.READ_CONTACTS&#125;,1); &#125;else &#123; readContacts(); &#125; &#125; private void readContacts () &#123; Cursor cursor = null; try &#123; cursor = getContentResolver().query(ContactsContract.CommonDataKinds. Phone.CONTENT_URI,null,null,null,null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; //获取联系人姓名 String displayName = cursor.getString(cursor.getColumnIndex (ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); //获取联系人手机号 String number = cursor.getString(cursor.getColumnIndex (ContactsContract.CommonDataKinds.Phone.NUMBER)); contactsList.add(displayName + &quot;\n&quot; + number); &#125; adapter.notifyDataSetChanged(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) &#123; cursor.close(); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager. PERMISSION_GRANTED) &#123; readContacts(); &#125; else &#123; Toast.makeText(this,&quot;You denied the permission&quot;,Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125;&#125; 在onCreate方法中，首先获取了ListView的实例，并给它设置好了适配器，然后开始调用运行时权限的处理逻辑，因为READ_CONTACTS属于危险权限，所以要先获取权限。获得授权之后调用readContacts()方法来读取联系人信息。运行程序，首先会弹出申请访问联系人权限的对话框，我们点击”始终允许”，当然也可以点击拒绝。 点击允许后，程序会显示联系人信息，如下图所示： readContacts方法解析： 这里使用了ContentResolver的query()方法来查询联系人的数据，不过传入的Uri参数为什么没有调用Uri.parse()方法去解析一个内容URI字符串呢？因为ContactsContract.CommomDataKinds.PHhone()类已经帮我们做好了封装，提供了一个CONTENT_URI常量，而这个常量就是使用Uri.parse()解析出来的结果。接着对Cursor对象进行遍历，将联系人姓名和手机号这些数据逐个取出，联系人姓名这一列对应的常量是ContactsContract.CommonDataKinds.DISPLAY_NAME,联系人手机号对应的常量是ContactsContract.CommonDataKinds.PHONE_NUMBER。两个数据都取出之后，将它们进行拼接，并且在中间加上换行符，然后将拼接后的数据添加到ListView的数据源里，并通知刷新一下ListView,最后要把cursor对象关闭。 还有读取联系人的权限”android.permission.READ_CONTACTS”要在清单文件里声明。 总结 想要访问内容提供器中共享的数据，必须借助ContentResolver类 ContentResolver的增删改查方法都不接收表明参数，而是使用Uri作为参数，我们称它为内容URI 得到内容URI字符串后，我们要将它解析成Uri对象才可以作为参数传入(Uri.parse()方法) 通过Uri对象查询数据，返回的是一个Cursor对象，这个时候我们就可以将数据从Cursor对象中逐个读取出来 三、创建自己的内容提供器前面我们学习了如何在自己程序中访问其他应用程序的数据。总体来说思路还算非常简单，只需要获取到该应用程序的内容URI，然后借助ContentResolver进行CRUD操作就可以了。问题来了？这些提供外部访问接口的应用程序如何实现这种功能的呢？他们又是怎样保证数据的安全性呢，从而能使得隐私数据不会泄露出去？接下来一一讲解。 1，创建内容提供器的步骤前面提到过，如果想跨程序共享数据，官方推荐的是用内容提供器，可以新建一个类去继承ContentProvider的方式来创建一个自己的内容提供器，ContentProvider类有6个抽象方法，我们在使用子类继承它的时候，需要将这6个抽象方法全部复写，新建MyProvider继承ContentProvider,代码如下： 12 2，实现跨程序数据共享我们在上一章的DatabaseTest项目的基础上继续开发，通过内容提供器来给它加入外部访问接口。打开DatabaseTest项目，首先将MyDatabaseHelper中使用Toast弹出创建数据库成功的提示去除掉，因为跨程序访问时不能直接使用Toast。然后创建一个内容提供器，右键点击报名–&gt;New–&gt;Other–&gt;ContentProvider，将内容提供器命名为DatabaseProvider，authority指定为com.example.databasetest.provider。选中Exported和Enabled属性。修改DatabaseProvider中的代码，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class DatabaseProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final int CATEGORY_DIR = 2; public static final int CATEGORY_ITEM = 3; public static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR); uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM); uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR); uriMatcher.addURI(AUTHORITY, &quot;category/#&quot;, CATEGORY_ITEM); &#125; @Override public boolean onCreate() &#123; dbHelper = new MyDatabaseHelper(getContext(), &quot;BookStore.db&quot;, null, 2); return true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // 查询数据 SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] &#123; bookId &#125;, null, null, sortOrder); break; case CATEGORY_DIR: cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(&quot;Category&quot;, projection, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;, null, null, sortOrder); break; default: break; &#125; return cursor; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; // 添加数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert(&quot;Book&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId = db.insert(&quot;Category&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/category/&quot; + newCategoryId); break; default: break; &#125; return uriReturn; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // 更新数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); int updatedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: updatedRows = db.update(&quot;Book&quot;, values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] &#123; bookId &#125;); break; case CATEGORY_DIR: updatedRows = db.update(&quot;Category&quot;, values, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Category&quot;, values, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;); break; default: break; &#125; return updatedRows; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // 删除数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] &#123; bookId &#125;); break; case CATEGORY_DIR: deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Category&quot;, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;); break; default: break; &#125; return deletedRows; &#125; @Override public String getType(Uri uri) &#123; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.book&quot;; case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.book&quot;; case CATEGORY_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.category&quot;; case CATEGORY_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.category&quot;; &#125; return null; &#125;&#125; 另外注意，内容提供器一定要在清单文件注册，Android studio已经帮我们自动注册了(因为我们是用Android Studio的快捷功能创建内容提供器的)，打开AndroidManifest.xml文件，发现注册已经自动完成了。也就是在标签多了一个标签。现在DatabaseTest已经具有跨程序共享数据的功能了，我们新建一个ProviderTest项目，然后通过这个程序去访问DatabaseTest中的数据。新建ProviderTest项目，修改activity_main.xml，代码如下： 12345678910111213141516171819202122&lt;Button android:id=&quot;@+id/add_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Add To Data&quot;/&gt;&lt;Button android:id=&quot;@+id/query_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Query From Book&quot;/&gt;&lt;Button android:id=&quot;@+id/update_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Update Book&quot;/&gt;&lt;Button android:id=&quot;@+id/delete_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Delete From Book&quot;/&gt; 设置为垂直布局，设置四个按钮，分别用于添加、查询、修改和删除数据。然后修改MainActivity中的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private String newId; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button addData = findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //添加数据 Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot;); ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;A Clash of Kings&quot;); values.put(&quot;author&quot;, &quot;George Martin&quot;); values.put(&quot;pages&quot;, 1040); values.put(&quot;price&quot;, 55.55); Uri newUri = getContentResolver().insert(uri, values); newId = newUri.getPathSegments().get(1); &#125; &#125;); Button queryData = (Button) findViewById(R.id.query_data); queryData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 查询数据 Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot;); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; String name = cursor.getString(cursor. getColumnIndex(&quot;name&quot;)); String author = cursor.getString(cursor. getColumnIndex(&quot;author&quot;)); int pages = cursor.getInt(cursor.getColumnIndex (&quot;pages&quot;)); double price = cursor.getDouble(cursor. getColumnIndex(&quot;price&quot;)); Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author); Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages); Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price); &#125; cursor.close(); &#125; &#125; &#125;); Button updateData = (Button) findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 更新数据 Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book/&quot; + newId); ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;A Storm of Swords&quot;); values.put(&quot;pages&quot;, 1216); values.put(&quot;price&quot;, 24.05); getContentResolver().update(uri, values, null, null); &#125; &#125;); Button deleteData = (Button) findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 删除数据 Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book/&quot; + newId); getContentResolver().delete(uri, null, null); &#125; &#125;); &#125; 我们在四个按钮的点击事件里面处理了CRUD的逻辑 添加数据的时候，调用了Uri.parse()方法将一个内容URI解析成Uri对象，然后把要添加的数据都存放到ContentValues对象中，接着调用ContentResolver的insert()方法执行添加操作就可以了。注意insert()方法会返回一个Uri对象，这个对象中包含了新增数据的id，我们通过getPathSegments()方法将这个id取出。 查询数据的时候，调用Uri.parse()方法将一个内容URI解析成Uri对象，然后调用ContentResolver的query()方法去查询数据，查询的结果还是在Cursor对象中，之后对Cursor进行遍历，从中取出查询结果，并一一打印出来。 更新数据，也是将内容URI解析成Uri对象，然后把想要更新的数据存放到ContentValues对象中，再调用ContentResolver的update()方法执行更新操作就可以了。这里为了不想让Book表中的其他行受到影响，在调用Uri.parse()方法的时候，给内容URI的尾部增加了一个id，而这个id正是添加数据是所返回的。这就表明我们只希望更新刚刚添加的那条数据，Book表中的其他行不会受到影响。 删除数据，也是同样的方法解析一个以id结尾的内容URI，然后调用ContentResolver的delete方法执行删除操作就可以了，由于我们在内容URI里指定了一个id，因此只会删除以拥有相应id的那行数据，Book表中的其他数据不会受影响。 点击ADD TO BOOK按钮，此时数据就应该添加到了DatabaseTest程序的数据库中了，再通过点击Query From Book按钮检查，日志如图： 然后再点击Update Book按钮完成更新数据的操作，再点击一下Query From Book按钮进行检查，日志如图： 最后点击Delete From Book按钮，此时再点击Query From Book按钮查询数据，我们会发现查询不到数据了。由此可以看出，我们的跨进程访问数据功能实现了，现在不仅仅ProviderTest程序吗，任意一个程序都可以访问DatabaseTest程序中的数据，而且不需要担心隐私数据泄露的问题。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <url>%2F2018%2F12%2F25%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、ViewRoot和DecorViewViewRoot对应ViewRootImpl类，它是连接WindowManager和DecorView的纽带。View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当activity对象创建完毕后，会将DecorView添加到Window中，同时创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。 12 ###]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>View</tag>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile的使用及原理]]></title>
    <url>%2F2018%2F12%2F24%2Fvolatile%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、volatile的使用我们先理解可见性、有序性以及原子性三个概念，通常我们用synchronized关键字来解决这些问题，不过synchronized是重量级锁，对系统的性能有比较大的影响，所以如果有其他解决方案，我们都会优先考虑其他方案，避免使用synchronized关键字。而volatile关键字是就是java提供的解决可见性和有序性问题的关键字。注意：对于原子性，volatile变量的单次读写操作可以保证原子性，如long、double类型变量，但是不能保证i++这种操作的原子性，因为i++本质上是读、写两次操作。 二、volatile的使用通过一个经典的单例(DCL单例设计模式)来说明volatile的使用。如下代码所示： 123456789101112131415161718192021222324public class Singleton &#123; private static volatile Singleton single; private Singleton() &#123; &#125;//私有化构造函数，禁止外部实例化 public static Singleton getInstance () &#123; if (single == null) &#123; synchronized (single) &#123; if (single == null) &#123; single = new Singleton(); &#125; &#125; &#125; return single; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub &#125;&#125; 1，防止重排序加了volatile关键字才能真正保证线程安全，为什么呢？首先了解对象的构造过程，实例化一个对象可以分为三个步骤： 1)，分配内存空间 2)，将内存空间的地址赋给对应的引用 3)，初始化对象按照这个流程的话，多线程环境下，就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的后果，因此我们要将变量设置为volatile了类型的变量。 ####,2，实现可见性可见性指一个线程修改了共享变量，而另一个线程却看不到。引用可见性的原因是每个线程拥有自己一个高速缓存–线程工作内存。volatile关键字能有效的解决这个问题，看下面代码片段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package test2;public class VolatileTest &#123; int a = 1; int b = 2; void change () &#123; a = 3; b = a; &#125; void print() &#123; System.out.println(&quot;b=&quot; + &quot;;a+&quot; + a); &#125; public static void main(String[] args) &#123; while (true) &#123; final VolatileTest test = new VolatileTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.change(); &#125; &#125;).start(); new Thread (new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; test.print(); &#125; &#125;).start(); &#125; &#125;&#125; 直观上说，上述代码只会有两种结果：b=2;a=1 、b=3;a=3。但是居然出了第三种结果：b=3;a=1。为什么会出现这种结果呢？正常情况下，如果先执行change方法，再执行print方法，输出结果应该是b=3;a=3。相反，如果先执行print方法，再执行change方法，结果就应该是b=2;a=1。那么b=3;a=1是怎么产生的？原因是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才会出现这一结果，如果将a和b也改为用volatile修饰，则不会出现这样的问题了。 3，保证原子性volatile关键字只能保证单词读写的原子性。这个在JLS中有描述。关于volatile关键字还有一个情况容易被误解，接下来用代码演示。 123456789101112131415161718192021222324252627282930313233343536public class VolatileTest2 &#123; volatile int i; public void add() &#123; i++; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub final VolatileTest2 test2 = new VolatileTest2(); for (int i = 0; i &lt; 1000; i++) &#123; new Thread (new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; test2.add(); &#125; &#125;).start(); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(test2.i); &#125;&#125; 这里运行结果是981(在我的电脑上)，如果是线程安全的那么这段程序的运行结果应该是1000才对，我们从这里可以看出，volatile是无法保证原子性的，i++是一个复合操作，包括三个步： 1),读取i的值 2),对i加1操作 3),将i的值写会内存 volatile是无法保证这三个步骤具有原子性的，我们可以通过AtomicInteger或者synchronized来保证+1这个操作的原子性。 三、volatile的原理voliti有三个特征或者说三个作用。 1，保证可见性线程本身并不与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，volatile变量的读写与普通变量的读写有以下区别： 1)，修改volatile变量时会强制将修改后的值刷新到主内存中 2), 修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再次读取该变量的值的时候就要重新从主内存去读取 这两个特性，能保证volatile的可见性。 2，禁止指令重排序看一段代码： 12345int a=1,b=3;//1b++;//2volatile int c;//3c = a + b;//4 处理器有的时候会将执行的顺序进行优化，会调乱执行的顺序，禁止指令重排序的意思是说第三行代码之前代码一定会全部执行完之后，才会执行第四行的代码，至于第三行代码前面的代码什么顺序，volatile不关心，也控制不了，但是一定能保证他们会在4之前执行。 3，内存屏障四、总结只有在一种情况下使用volatile才能保证并发安全，同时满足两个条件： 1，对变量的写操作不依赖于当前值 2，该变量没有包含在具有其他变量的不变式中]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2018%2F12%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、观察者模式简介观察者模式的定义本文章学习自刘望舒的博客。观察者模式也叫发布–订阅模式，属于行为模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。同时观察者模式还是效率很高的模式，常用语GUI系统，订阅—发布系统，这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得他们之间的依赖性更小，甚至做到毫无依赖。以GUI系统来说，应用的UI更有易变性。 观察者模式UML图： 二、各个类代表的意义及功能1，各个模块解读 Subject:抽象主题(抽象被观察者)，它把所有观察者对象保存在一个集合里，每个主题可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject:具体主题(具体被观察者)，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生变化时，给所有注册过的观察者发通知。 Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知是更新自己。 ConcreteObserver:具体观察者，是实现抽象观察者定义的更新的接口，以便在得到主题更改通知是更新自身的状态。2，观察者模式简单实现我们以微信公众号的订阅来举例，假设用户是观察者，微信公众号是被观察者，有多个用户同时关注了程序猿这个公众号，当这个公众号更新了就会通知这些订阅的用户。接下来看看代码如何实现。抽象观察者(Observer)123public interface Observer &#123; public void update(String message);&#125; 具体观察者(ConcreteObserver)微信用户是观察者，里面实现了更新的方法“ 12345678910111213141516public class WeixinUser implements Observer&#123; //微信用户名 private String name; public WeixinUser(String name) &#123; super(); this.name = name; &#125; @Override public void update(String message) &#123; // TODO Auto-generated method stub System.out.println(name + &quot;-&quot; + message); &#125;&#125; 抽象被观察者(Subject)抽限主题，提供了attach、detach、notify三个抽象方法： 123456789public interface Subject &#123; //增加订阅者 void attach(Observer observer); //删除订阅者 void deatch(Observer observer); //通知订阅者更新消息 void notify(String message);&#125; 具体被观察者(ConcreteSubject)123456789101112131415161718192021222324public class SubscriptionSubject implements Subject&#123; private List&lt;Observer&gt; weixinUserlist = new ArrayList&lt;Observer&gt;(); @Override public void attach(Observer observer) &#123; // TODO Auto-generated method stub weixinUserlist.add(observer); &#125; @Override public void deatch(Observer observer) &#123; // TODO Auto-generated method stub weixinUserlist.remove(observer); &#125; @Override public void notify(String message) &#123; // TODO Auto-generated method stub for (Observer observer : weixinUserlist) &#123; observer.update(message); &#125; &#125;&#125; 客户端调用12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; SubscriptionSubject subscriptionSubject = new SubscriptionSubject(); //创建微信用户 WeixinUser user1 = new WeixinUser(&quot;小明&quot;); WeixinUser user2 = new WeixinUser(&quot;小红&quot;); WeixinUser user3 = new WeixinUser(&quot;小兰&quot;); //订阅公众号 subscriptionSubject.attach(user1); subscriptionSubject.attach(user2); subscriptionSubject.attach(user3); subscriptionSubject.notify(&quot;程序猿公众号专栏更新了&quot;); &#125;&#125; 结果123小明-程序猿公众号专栏更新了小红-程序猿公众号专栏更新了小兰-程序猿公众号专栏更新了 3，观察者模式的使用场景和优缺点使用场景 关联行为场景，需要注意的是，关联行为是可拆分的，而不是组合关系 事件多级触发场景 跨系统的消息交换场景，如消息队列、事件总线的处理机制优点 解耦，让耦合的双方都依赖于抽象，从而使得各自的变化都不会影响另一边的变化 缺点 在应用观察者模式的时候要考虑一下开发效率和运行效率的问题，程序包括一个被观察者、多个观察者，开发、调试都比较复杂，而且在java中消息一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View事件分发机制]]></title>
    <url>%2F2018%2F12%2F23%2FView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、先看ViewGroup类中的dispatchTouchEvent方法，其中关于拦截事件的代码：123456789101112131415// Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 可以看到，// Check for interception. 这句注释说明是处理拦截逻辑的代码。先定义一个布尔型的变量，我们看到，ViewGroup会在两种情况下判断是否要拦截当前事件：1，actionMasked == MotionEvent.ACTION_DOWN(手指刚触摸屏幕事件)。2，mFirstTouchTarget != null()。 MotionEvent.ACTION_DOWN好理解，就是触摸的一瞬间。mFirstTouchTarget != null()是什么意思呢？ 12// First touch target in the linked list of touch targets. private TouchTarget mFirstTouchTarget; 源码如上，这个mFirstTouchTarget是一个TouchTarget变量。从后面的代码可以看到：当ViewGroup的子元素成功处理时，mFirstTouchTarget会被赋值并指向子元素，也就是说，当ViewGroup不拦截事件并将事件交由子元素处理时mFirstTouchTarget != null成立。反之，一旦事件由当前ViewGroup拦截，mFirstTouchTarget != null就不成立。这时候ACTION_DOWN和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)这个条件就为false，将导致ViewGroup的onInterceptTouchEvent不会被调用，并且同一事件序列的其他事件也会默认交由他处理。 有一种特殊情况，就是FLAG_DISALLOW_INTERCEPT标记位，它是通过requestDisallowInterceptTouchEvent方法来设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦被设置，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件。为什么是除了ACTION_DOWN点击事件以外的其他事件？因为在ViewGroup分发事件中，如果是ACTION_DOWN事件就会重置FLAG_DISALLOW_INTERCEPT这个标记位，导致子View标记位无效，因此，当面对当前ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否需要拦截事件，从源码可以看出来。 下面代码中，ViewGroup会在ACTION_DOWN事件到来的时候做重置状态的操作，而在resetTouchState();方法中，会对FLAG_DISALLOW_INTERCEPT进行重置，因此子View调用requestDisallowInterceptedTouchEvent方法并不会影响ViewGroup对ACTION_DOWN的处理。 12345678// Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; 从上面的源码分析，当ViewGroup决定拦截事件后，后续的点击事件将会默认交给它处理而不是调用它的onInterceptTouchEvent方法，这证实了：当某一个View开始处理事件，如果它不消耗ACTION_DOWN事件(onTouchEvent返回false)，那么同一事件序列的其他事件也不会再交由它处理，并且将事件重新交由它的父元素处理，即父元素的onTouchEvent会被调用。也就是说，一旦事件交由一个View处理，那么它就必须消耗掉，否则同一事件序列的其他事件就不会再交由它处理了。FLAG_DISALLOW_INTERCEPT的作用是让ViewGroup不再拦截事件，当然前提是ViewGroup不拦截ACTION_DOWN事件，这证实了：事件传递过程是由外向内的，即事件总是先传给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptedTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。这意味着什么？这证明了两点：1，onInterceptTouchEvent不是每次事件都会被调用，如果我们想提前处理所有点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次会被调用，当然前提是事件能够传递到当前的ViewGroup，2，FLAG_DISALLOW_INTERCEPT的作用给我们提供了一个思路，当面对滑动冲突时，我们可以考虑用这种方法去解决。 接着再看ViewGroup不拦截事件的时候，事件会向下分发交由它的子View进行处理，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false);&#125; View先遍历所有的子元素，然后判断子元素是否能够接收到点击事件，能否接收点击事件由两个指标决定：1，子元素是否在播放动画和点击事件的坐标是否落在子元素的区域内。如果某个子元素满足这个条件，那么事件就会由它来处理。dispatchTransformedTouchEvent实际上调用的是子元素的dispatchTouchEvent方法，在它的内部有如下代码，而在上面的代码中child传递的不是null，因此它会直接调用子元素的dispatchTouchEvent方法，这样事件就交由子元素处理了，从而完成了一轮事件分发。 12345if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; 如果子元素的dispatchTouchEvent返回true，这时不考虑事件在子元素内部是怎么分发的，那么mFirstTouchTarget就会被赋值的同时跳出for循环，如下所示： 123newTouchTarget = addTouchTarget(child, idBitsToAssign);alreadyDispatchedToNewTouchTarget = true;break;]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>事件分发机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中Binder机制浅析]]></title>
    <url>%2F2018%2F12%2F22%2FAndroid%E4%B8%ADBinder%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文转载于简单理解Binder机制的原理 一、为什么要使用Binder性能方面在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。 安全方面传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。 二、Binder从进程角度看IPC原理 每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。 Binder原理Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示： Binder通信的四个角色Client进程：使用服务的进程。 Server进程：提供服务的进程。 ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。 Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。 Binder运行机制图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。 注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。 获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。 使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。 图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder驱动进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。 Binder运行的实例解释首先我们看看我们的程序跨进程调用系统服务的简单示例，实现浮动窗口部分代码： 123456//获取WindowManager服务引用WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); //布局参数layoutParams相关设置略...View view=LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, null); //添加viewwm.addView(view, layoutParams); 注册服务(addService)：在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册（即让ServiceManager管理）。这一步是系统自动完成的。 获取服务(getService)：客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，通常是Service引用的代理对象，对数据进行一些处理操作。即第2行代码中，得到的wm是WindowManager对象的引用。 使用服务：通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。即第6行调用WindowManager的addView函数，将触发远程调用，调用的是运行在systemServer进程中的WindowManager的addView函数。 使用服务的具体执行过程 client通过获得一个server的代理接口，对server进行调用。 代理接口中定义的方法与server中定义的方法时一一对应的。 client调用某个代理接口中的方法时，代理接口的方法会将client传递的参数打包成Parcel对象。 代理接口将Parcel发送给内核中的binder driver。 server会读取binder driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回。 整个的调用过程是一个同步过程，在server处理的时候，client会block住。因此client调用过程不应在主线程。 以上就是Binder机制原理的简单介绍。]]></content>
      <categories>
        <category>Binder机制</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>Binder机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动流程浅析]]></title>
    <url>%2F2018%2F12%2F21%2FActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在api26中，ActivityManagerNative类已经被弃用，同时代理类ActivityManagerProxy也被删除了。Instrumentation类的execStartActivity方法如下,注意注释1处。 12345678910111213141516171819202122232425262728293031323334353637383940public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String resultWho, Intent intent, int requestCode, Bundle options, UserHandle user) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); ActivityResult result = null; if (am.ignoreMatchingSpecificIntents()) &#123; result = am.onStartActivity(intent); &#125; if (result != null) &#123; am.mHits++; return result; &#125; else if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManager.getService() //1 .startActivityAsUser(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, resultWho, requestCode, 0, null, options, user.getIdentifier()); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125; api 25中Instrumentation类的的execStartActivity方法如下，注意注释2处。12345678910111213141516171819202122232425262728293031323334353637public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManagerNative.getDefault()//2 .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125; 我们看到，在注释1处和注释2处代码不一样，接下来继续看不同部分的代码，api26： 12345678910111213public static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; api25: 123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); &#125; return am; &#125;&#125;; 这两个地方的代码返回的都是IActivityManager对象。但是不同的是：api25中使用的是静态方法asInterface，该方法属于ActivityManagerNative。asInterface的源码如下： 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; 参考文章：Activity启动过程详解 说明了ActivityManagerNative类，还有ActivityManagerProxy类(已被移除)，是如何实现和AMS进程通信的，最终使用了ActivityManagerProxy代理类实现了startActivity。参考文章：ActivityManagerProxy已经被删除 api26使用的是： 1IActivityManager.Stub.asInterface(b); 再看api26中的ActivityManagerNative源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * &#123;@hide&#125; * @deprecated will be removed soon. See individual methods for alternatives. //将会被移除 */@Deprecatedpublic abstract class ActivityManagerNative &#123; /** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. * * @deprecated use IActivityManager.Stub.asInterface instead. */ //这里说可以用IActivityManager.Stub.asInterface来代替，这个方法已不被鼓励使用 static public IActivityManager asInterface(IBinder obj) &#123; return IActivityManager.Stub.asInterface(obj); &#125; /** * Retrieve the system&apos;s default/global activity manager. * * @deprecated use ActivityManager.getService instead. */ static public IActivityManager getDefault() &#123; return ActivityManager.getService(); &#125; /** * Convenience for checking whether the system is ready. For internal use only. * * @deprecated use ActivityManagerInternal.isSystemReady instead. */ static public boolean isSystemReady() &#123; return ActivityManager.isSystemReady(); &#125; /** * @deprecated use ActivityManager.broadcastStickyIntent instead. */ static public void broadcastStickyIntent(Intent intent, String permission, int userId) &#123; broadcastStickyIntent(intent, permission, AppOpsManager.OP_NONE, userId); &#125; /** * Convenience for sending a sticky broadcast. For internal use only. * If you don&apos;t care about permission, use null. * * @deprecated use ActivityManager.broadcastStickyIntent instead. */ static public void broadcastStickyIntent(Intent intent, String permission, int appOp, int userId) &#123; ActivityManager.broadcastStickyIntent(intent, appOp, userId); &#125; /** * @deprecated use ActivityManager.noteWakeupAlarm instead. */ static public void noteWakeupAlarm(PendingIntent ps, int sourceUid, String sourcePkg, String tag) &#123; ActivityManager.noteWakeupAlarm(ps, sourceUid, sourcePkg, tag); &#125; /** * @deprecated use ActivityManager.noteAlarmStart instead. */ static public void noteAlarmStart(PendingIntent ps, int sourceUid, String tag) &#123; ActivityManager.noteAlarmStart(ps, sourceUid, tag); &#125; /** * @deprecated use ActivityManager.noteAlarmFinish instead. */ static public void noteAlarmFinish(PendingIntent ps, int sourceUid, String tag) &#123; ActivityManager.noteAlarmFinish(ps, sourceUid, tag); &#125;&#125; “@deprecated will be removed soon. See individual methods for alternatives. “上面注释说明这个类将会被弃用，我们可以用ActivityManager来替代，而且ActivityManagerProxy已经被删除了。 api26及以后启动activity时候，和AMS通信已经采用了AIDL方式。实际上api25和api26及之后，启动Activity启动Activity的时候，和AMS通信调用的也是queryLocalInterface，他们的实质还是一样的。api26及之后只有ServiceManagerNative还没有被弃用，api25的：ApplicationThreadNative、ActivityManagerNative、BulkCursorNative、ContentProviderNative都已经不再使用了。这两句代码：mInstrumentation.execStartActivity，mMainThread.sendActivityResult。是activity启动过程中很重要的核心逻辑。 在ActivityThread中一个Activity被启动时相关方法是这样的：schedule–&gt;handle–&gt;perform–&gt;activity/Insturmation。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>activity启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI fragment和fragment管理器]]></title>
    <url>%2F2018%2F12%2F17%2FUI-fragment%E5%92%8Cfragment%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、UI设计的灵活性要求开发一个由两个Activity组成的列表明细类应用就可以了，一个activity负责管理记录列表，另一个负责管理记录明细界面，点击列表中某条记录会启动其明细activity实例，按后退键会销毁明细activity并返回到记录列表activity界面，想看记录，同样操作。理论上这样可行，但是如果应用需要更复杂的用户界面呈现及跳转，怎么办？ 比如在平板上运行app，平板尺寸较大，有足够的空间，能够同时显示列表和记录明细 假设用户正在手机上查看记录明细，并想查看列表中的下一条记录信息，如果能够返回列表界面，滑动屏幕就能够查看下一条记录就好了，每滑动一次屏幕，应用便自动切换到下一条记录明细。 activity本身不具有这样的灵活性。activity视图可以在运行时切换，但控制视图的代码必须在activity中实现，结果，各个activity还是得和特定的用户界面紧紧绑定。 二、 引入fragmentfragment可绕开Android的系统中activity使用规则的限制。fragment是一种控制器对象，activity可以委派它执行任务，这些任务通常用来管理用户界面，受管的用户界面可以是一整屏或是屏幕的一部分。 activity视图可以预留位置供fragment视图插入。应用怎么支持同屏显示列表和明细内容？由列表fragment和明细的fragment组成，明细视图负责显示列表项的明细内容。选择不同的列表项就显示对应的明细视图，activity负责以一个明细fragment替换另一个明细fragment，这样，视图切换的过程中，就不要销毁activity了，fragment的作用就在这里。 1，CriminalIntent应用中，新建一个CrimeFragment的UI fragment管理用户界面，再设计一个名为CrimeActivity的activity来托管CrimFragment实例。可以这样理解，activity在其视图层级预留一处位置，用来放置fragment视图，如下图所示，fragment本身没有在屏幕上显示视图的能力。因此，只有将它的视图放置在activity的视图层级结构中，fragment视图才能显示在屏幕上。 上图就是CrimeFragment托管CrimeFragment的示意图。CrimeFragment是个大项目，借助对象可以更好理解它，下面UML图展示了CriminalIntent项目设计的对象以及对象之间的关系。 CrimeActivity的作用与activity在GeoQuiz应用中的作用差不多，都负责创建并管理用户界面，以及与模型对象进行交互。Crime、CrimeActivity、CrimeFragment是我们要开发的类。2，两类fragmentfragment是在API11引进的，最初就是为了平板而设计的，当时google也发布了第一台平板(API 11)，可以说，UI要灵活，最初就是为了平板这样的大屏幕设备，现在Google有两个版本的fragment实现可供选择：原生版本和支持库版本。原生版本内置在系统中，支持库版本的fragment在类库里，发布时，会打包在应用里。显然支持库fragment的应用，无论在哪台设备上运行，都有相同的表现。所以建议使用支持库中的fragment。 三、 在Android studio增加依赖关系支持库中的fragment在AppCompat库中，要使用Appcompat支持库，项目必须将其添加到依赖关系，在build.gradle文件中设置。 1implementation &apos;com.android.support:appcompat-v7:28.0.0&apos; 四、 完整的CriminalIntent项目解析CriminalIntent项目]]></content>
      <categories>
        <category>fragment</category>
      </categories>
      <tags>
        <tag>fragment</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓编程权威指南1--3章知识点汇总]]></title>
    <url>%2F2018%2F12%2F15%2F%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%971-3%E7%AB%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一、Android开发初体验开发一个应用，名叫GeoQuiz，它能给出一道道地理知识问题，用户点击TRUE或FALSE来回答屏幕上的问题，GeoQuiz会及时给出反馈，应用界面如下图所示。 应用由一个activity和一个布局(layout)组成。按照Android studio提示新建一个普通的项目，activity name设置为”QuizActivity”(当然名字可以随便取，不过为了具有辨识度我们还是根据activity的作用来取)，layout名”activity_quiz”。修改默认的布局文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.QuizActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/question_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;24dp&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;Button android:id=&quot;@+id/true_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/true_button&quot;/&gt; &lt;Button android:id=&quot;@+id/false_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/false_button&quot;/&gt; &lt;/LinearLayout&gt; &lt;Button android:id=&quot;@+id/cheate_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/cheat_button&quot;/&gt; &lt;Button android:id=&quot;@+id/next_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/next_button&quot; android:drawableRight=&quot;@drawable/arrow_right&quot; android:drawablePadding=&quot;4dp&quot;/&gt;&lt;/LinearLayout&gt; 添加字符串资源(strings.xml文件)。 12345678910111213141516171819&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;GeoQuiz&lt;/string&gt; &lt;string name=&quot;question_australia&quot;&gt;Canberra is the capital of Australia.&lt;/string&gt; &lt;string name=&quot;question_oceans&quot;&gt;The Pacific Ocean is large than the Atlantic Ocean.&lt;/string&gt; &lt;string name=&quot;question_mideast&quot;&gt;The suez is Canal connects the Red Sea and the Indian Ocean.&lt;/string&gt; &lt;string name=&quot;question_africa&quot;&gt;The source of the Nile River is in Egypt.&lt;/string&gt; &lt;string name=&quot;question_americas&quot;&gt;The amazon River is the longest river in the Americas.&lt;/string&gt; &lt;string name=&quot;question_asia&quot;&gt;Lake Baikal is the world\&apos;s oldest and deepest freshwater lake.&lt;/string&gt; &lt;string name=&quot;warning_text&quot;&gt;Are you sure you want to do this?&lt;/string&gt; &lt;string name=&quot;show_answer_button&quot;&gt;Show Answer&lt;/string&gt; &lt;string name=&quot;cheat_button&quot;&gt;Cheat!&lt;/string&gt; &lt;string name=&quot;judgment_toast&quot;&gt;Cheating is wronging!&lt;/string&gt; &lt;string name=&quot;true_button&quot;&gt;True&lt;/string&gt; &lt;string name=&quot;false_button&quot;&gt;False&lt;/string&gt; &lt;string name=&quot;correct_toast&quot;&gt;Correct!&lt;/string&gt; &lt;string name=&quot;next_button&quot;&gt;Next!&lt;/string&gt; &lt;string name=&quot;incorrect_toast&quot;&gt;Incorrect!&lt;/string&gt;&lt;/resources&gt; 布局文件中，LinearLayout里嵌有一个LinearLayout，外层LinearLayout是垂直排列，里层是水平排列，在水平排列的布局中，放置了两个Button，用来选择答案的true或false。 2，从XML布局文件到视图对象setContentView(R.layout.activity_quiz);这行代码生成指定的视图并将其放在屏幕上。布局是一种资源，资源则是非代码形式的内容，图像文件、音频、xml等都是资源。布局文件放在app/res子目录下，activity_quiz.xml文件放在res/layout/目录下，strings.xml在res/values/目录下。可以使用资源ID在代码中获取相应的资源，activity_quiz.xml布局的资源ID为R.layout.activity_quiz。 3，组件的实际应用1)，在QuizActivity中添加两个成员变量，按IDE提示导入包。 12private Button mTrueButton;private Button mFalseButton; 2), 引用组件 1public View findViewById(int id); 以上代码用于引用已生成的组件，使用按钮的资源id获取视图对象，赋值给对应的成员变量，如下代码所示 12mTrueButton = findViewById(R.id.true_button);mFalseButton = findViewById(R.id.false_button); 3)，设置监听器Android应用属于典型的事件驱动类型，不像命令行或脚本程序，事件驱动应用启动后，即开始等待行为事件的发生，如用户点击某个按钮(事件也可以由操作系统或其他应用触发，但是用户触发的点击事件更直观，如点击按钮)。应用在等待某个特定事件的发生，可以说应用正在”监听”特定事件，为相应某个事件而创建的对象叫做监听器(listener)。监听器会实现特定事件的监听器接口(listener interface)。 Android Sdk为我们设置了很多的监听器接口，我们不需要自己实现，当前我们要监听用户的按钮”点击”事件，因此要实现View.OnClickListener接口。在QuizActivity中添加如下代码，并导入View类： 1234567mTrueButton = findViewById(R.id.true_button);mTrueButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //业务逻辑代码 &#125;&#125;); 这是一个匿名内部类实现了OnClickListener接口，使用匿名内部类有两大好处，第一，可以相对集中地实现监听器方法，便于观察。第二，事件监听器一般只在一个地方使用，使用匿名内部类，就不用再创建繁琐的命名类了。匿名内部类实现了OnClickListener接口，因此必须实现接口中唯一的onClick方法，onClick现在是空方法，至于如何实现这个方法，则取决于我们自己，同样为false button设置监听器。 1234567mFalseButton = findViewById(R.id.false_button); mFalseButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //do something here &#125;&#125;); 4),创建提示消息 创建一个toast提示消息，这是用来通知用户的简短弹出消息。用toast来反馈答案。首先在strings.xml中添加消息显示的字符串。代码如下： 1234567Toast.makeText(QuizActivity.this, R.string.correct_toast,Toast.LENGTH_SHORT) .show();...Toast.makeText(QuizActivity.this, R.string.incorrect_ toast,Toast.LENGTH_SHORT).show(); 运行程序，点击按钮会有toast提示。 二、Android与MVC设计模式2.1 创建新类新建Question类，新增两个成员变量和一个构造方法以及getter和setter方法： 12345678910111213141516171819202122232425262728public class Question &#123; private int mTextResId; private boolean mAnswerTrue; public Question(int mTextResId, boolean mAnswerTrue) &#123; this.mTextResId = mTextResId; this.mAnswerTrue = mAnswerTrue; &#125; public int getmTextResId() &#123; return mTextResId; &#125; public void setmTextResId(int mTextResId) &#123; this.mTextResId = mTextResId; &#125; public boolean ismAnswerTrue() &#123; return mAnswerTrue; &#125; public void setmAnswerTrue(boolean mAnswerTrue) &#123; this.mAnswerTrue = mAnswerTrue; &#125;&#125; 2.2 MVC模式MVC现在已经用的不多，MVP和MVVM模式是主流，我们修改QuizActivity类配合Question类使用，现在看看各个类是如何协同工作的。模型(Question)、控制器(QuizActivity)、视图(布局，mTrueButton、mFalseButton、TextView、Button、Button、Button) 1,Android与MVC设计模式GeoQuiz应用基于模型–视图–控制器的结构模式进行设计，MVC模式表明，应用的任何对象，归根结底都属于模型对象、视图对象以及控制器对象中的一种。 2，MVC各个模块分工 a,模型对象：储存应用的数据业务逻辑。模型类通常用来映射与应用相关的一些事物，如用户、商店里的商品、服务器上的图片。 b,视图对象：它知道怎样在屏幕上绘制自己，以及如何响应用户的输入，如触摸事件。 c,控制器对象：含有应用的逻辑单元，是视图对象与模型对象联系纽带，控制器对象响应视图对象触发的各类事件，此外还管理着模型对象与视图层间的数据流动。 GeoQuiz应用的控制器层目前仅有QuizActivity类。MVC设计模式的好处：随着应用功能的扩展，应用往往会变得过于复杂让人难以理解，以java类组织代码有助于从整体视角设计和理解应用，这样我们可以按类而不是按变量和方法思考设计开发问题。同样，把java类以模型层、视图层和控制器层进行分类组织，也有助于我们设计和理解Android应用，这样我们可以按层而非一个个类来考虑设计开发了。 2.3 更新视图层在QuizActivity中添加一个NEXT按钮，GeoQuiz应用唯一的布局定义在activity_quiz.xml文件中，添加一个NEXT BUTTON。 1234567&lt;Button android:id=&quot;@+id/next_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/next_button&quot; android:drawableRight=&quot;@drawable/arrow_right&quot; android:drawablePadding=&quot;4dp&quot;/&gt; 同时对文本视图(TextView)进行调整，删除TextView的android:text属性定义，不用硬编码地理知识问题，同时为TextView新增android:id属性，TextView需要资源ID，以便于在QuizActivity代码中为它设置要显示的文字。同时更新字符串资源定义，就是strings.xml中，添加其他地理知识问题的字符串。 2.4 更新控制器层在QuizActivity中添加TextView和Button变量，再创建一个Question对象数组以及一个该数组的索引变量，代码如下所示： 123456789101112private Button mNextbutton;private TextView mQuestionTextView;private Question[] mQuestionBank = new Question[] &#123; new Question(R.string.question_australia,true) , new Question(R.string.question_oceans,true) , new Question(R.string.question_mideast,false) , new Question(R.string.question_africa,false) , new Question(R.string.question_americas,true) , new Question(R.string.question_asia,true) ,&#125;;priavte int mCurrentIndex = 0; 在这里，我们会通过多次调用Question类的构造方法，创建了Question对象数组(在更复杂的项目里，这类数组的创建和存储会单独处理)。 123mQuestionTextView = findViewById(R.id.question_text_view); int question = mQuestionBank[mCurrentIndex].getmTextResId();mQuestionTextView.setText(question); 运行应用，可以看到数组存储的第一个问题显示在TextView上了。接下来处理，NEXT按钮，首先引用NEXT按钮，然后为其设置监听器View.OnClickListener。该监听器的作用是：递增数组索引并相应地更新TextView的文本内容，代码如下所示： 123456789mNextbutton = findViewById(R.id.next_button); mNextbutton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mCurrentIndex = (mCurrentIndex + 1) % mQuestionBank.length; int question = mQuestionBank[mCurrentIndex].getmTextResId(); mQuestionTextView.setText(question); &#125;&#125;); 把公共代码提取出来，然后在不同的地方分别调用它。 1234private void updateQuestion() &#123; int question = mQuestionBank[mCurrentIndex].getmTextResId(); mQuestionTextView.setText(question);&#125; 我们提取代码生成update方法，运行应用，验证新增的NEXT按钮。当前应用认为所有的问题答案都是true，下面解决这个逻辑错误，同样为了避免重复代码，我们把代码封装在一个方法里。 12345678910111213141516private void checkAnswer (boolean userPressedTrue) &#123; boolean answerIsTrue = mQuestionBank[mCurrentIndex].ismAnswerTrue(); int messageResId = 0; if (mIsCheater) &#123; messageResId = R.string.judgment_toast; &#125;else&#123; if (userPressedTrue == answerIsTrue)&#123; messageResId = R.string.correct_toast; &#125; else &#123; messageResId = R.string.incorrect_toast; &#125; &#125; Toast.makeText(this,messageResId,Toast.LENGTH_SHORT).show();&#125; 方法接收boolean值，也就是用户按的是true还是false按钮，将用户的答案和当前Question对象中的答案作比较，最后判断答案是否正确。生成一个Toast消息反馈给用户。在按钮的监听器里，调用checkAnswer方法，代码如下所示： 12345678910111213141516...public void onClick(View v) &#123;// Toast.makeText(QuizActivity.this,// R.string.correct_toast,Toast.LENGTH_SHORT)// .show();// setGravity(5,5,5); checkAnswer(true);&#125; public void onClick(View v) &#123;// Toast.makeText(QuizActivity.this,// R.string.incorrect_// toast,Toast.LENGTH_SHORT).show(); checkAnswer(false);&#125;... 2.5 添加图标资源使应用中的NEXT按钮能够显示向右的图标，这样会更加用户友好。将图标资源(图片)复制到res目录下的drawable目录。然后在布局文件中引用： 12android:drawableRight=&quot;@drawable/arrow_right&quot;android:drawablePadding=&quot;4dp&quot; 三、activity的生命周期现在应用运行后，旋转屏幕后，应用状态就重置，这就涉及到activity的生命周期问题了。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统广播机制]]></title>
    <url>%2F2018%2F12%2F09%2FAndroid%E7%B3%BB%E7%BB%9F%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[广播机制简介Android中有灵活的广播机制，Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样应用就只会收到自己感兴趣的广播，广播可以是来自于系统的，也可以来自于其他应用程序。Android系统中分为标准广播和有序广播： 1，标准广播：是一种完全异步执行的广播，广播发出后，所有的广播接收器几乎都会在同一时刻接收到这条广播信息，因此他们之间没有任何先后顺序。它的优点是：传播效率较高。缺点是：无法截断。 2，有序广播：特点是同步执行，可以被截断，同一时刻只会有一个广播可以接收到这条广播消息，当这个广播接收器的逻辑执行完以后，广播才会继续传递，所以广播有先后顺序，优先级高的就先接收到广播信息，优先级低的就后接收信息，广播可以被截断，被优先级高的广播接收器截断后后面的广播接收器就不能接收到广播信息了。 接收系统广播Android内置了许多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息，下面讲讲它的具体用法 动态注册监听网络变化注册广播的方式有两种，在代码中注册和在AndroidManifest中注册。前者也称为动态注册，后者也称为静态注册。 新建一个类，让它继承自BroadCastReceiver，重写onReceive()方法就行了，这样当有广播到来时，onReceive()方法就会执行，具体的逻辑就在这里执行。 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver); &#125; class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;network changes&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 定义了一个内部类NetworkChangeReceiver，继承自BroadcastReceiver并重写了onReceive()方法，这样每当网络状态变化时，onReceice方法会得到执行，当然这里只是简单用Toast提示了信息。 onCreate方法中，创建了IntentFilter实例，并给它添加了一个”android.net.conn.CONNECTIVITY_CHANGE”的action，添加这个值的目的是当网络状态发生变化时，系统发出的正是一条值为”android.net.conn.CONNECTIVITY_CHANGE”的广播，也就是说我们要接收什么广播我们就在这里添加相应的action。接下来创建一个NetworkChangeReceiver的实例，然后调用registerReceiver方法进行注册，”registerReceiver(networkChangeReceiver, intentFilter);”,这里我们把NetworkChangeReceiver的实例和IntentFilter的实例都传了进去，这样NetworkChangeReceiver就会收到”android.net.conn.CONNECTIVITY_CHANGE”这个广播。也就实现了监听网络变化的功能。 动态注册的广播一定要取消注册才行，我们在onDestroy方法里调用unregisterReceiver(networkChangeReceiver);方法来取消注册广播。 我们还可以优化onReceive方法中的代码，让程序准确地告诉我们当前是有网络还是没有网络，对代码进行进一步优化： 12345678910ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show(); &#125; 在onReceive方法中，通过getSystemService()方法得到了ConnectivityManager实例，这是一个系统服务类，专用于管理网络连接的，然后调用它的getActivityNetworkInfo()方法可以得到NetworkInfo的实例，然后调用NetworkInfo的isAvailable()方法判断当前是否有网络了，最后用toast提示。 注意：敏感的操作必须在配置文件中声明权限才可以使用，否则程序会崩溃，这里就需要访问系统的网络状态，所以要声明权限的 1&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 静态注册实现开机启动如果要让程序未启动的情况下就能收到广播呢？这就需要使用静态注册的方式了。 我们可以用Android studio的快捷方式来创建一个广播接收器，new–&gt;Pther–&gt;Broadcast Receiver，会弹出新建广播接收器的窗口，将它命名为BootCompleteReceiver，Exported属性表示是否允许广播接收器接收本程序以外的广播，Enabled属性表示是否启用这个广播接收器，勾选两个属性，点击Finish完成创建。 在onReceive方法中修改代码如下： 1Toast.makeText(context, &quot;Boot Completed&quot;, Toast.LENGTH_SHORT).show(); 代码在onReceive()方法中使用Toast弹出一段提示信息。 另外，静态注册的广播要在清单文件中注册才可以使用，使用Android studio快捷方式创建的广播接收器Android studio会自动完成在AndroidManifest文件的注册 123456&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;/receiver&gt; 不过我们还要在AndroidManifest文件中声明权限，因为监听系统开机广播也是需要声明权限的，我们在AndroidManifest文件中加入了： 1&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; 权限。以及在receiver中添加相应的action。 1234567 &lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/receiver&gt; 这样就可以接收启动广播了。重启手机或模拟器，在启动完成之后就会收到开机广播。 发送自定义广播发送标准广播先定义一个广播接收器，新建一个MyBroadcastReceiver,代码如下： 123public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show();&#125; 当自定义广播接收器收到自定义的广播时，就会弹出”received in MyBroadcastReceiver”的提示，同样要在AndroidManifest文件中进行修改： 12345678&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 然后在activity_main.xml文件中定义一个Button，用来触发发送广播的触发点。修改MainActivity的代码： 12345678Button button = findViewById(R.id.button);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); sendBroadcast(intent); // 发送广播 &#125; &#125;); 就这样将广播发送出去，调用Context的sendBroadcast将广播发送出去。 运行程序，点击Send Broadcast按钮，就会收到这条广播(以Toast方式提示)。 发送有序广播广播是一种可以跨进程的通信放心方式，这一点从前面接收系统广播就可以看出来了。 新建项目BroadcastTest2项目，再在这个项目下新建一个广播接收器，用于接收上一个程序中的自定义广播，新建AnotherBroadcastReceiver。 12Toast.makeText(context,&quot;received in AnotherBrocastReceiver&quot;, Toast.LENGTH_SHORT).show(); 在onReceive方法中弹出一段文本信息，然后去AndroidManifest文件中对这个广播接收器进行修改，如下： 12345678 &lt;receiver android:name=&quot;.AnotherBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 我们设置AnotherbroadcastReceiver接收的同样是”com.example.broadcasttest.MY_BROADCAST”这条广播，将BroadcastTest2安装到模拟器中，然后重新回到BroadcastTest程序主界面，点击send Broadcast按钮，就会分别弹出两次提示信息。 这都是标准广播，下面我们来尝试发送有序广播，在BroadcastTest项目，修改MainActivity代码： 1234567button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); sendOrderedBroadcast(intent,null); &#125;&#125;); 发送有序广播只要一行代码：sendOrderedBroadcast(intent,null);将sendBroadcast()改为sendOrderedBroadcast()方法，sendOrderedBroadcast()方法接收两个参数，第一个仍然是Intent，第二个是一个与权限有关的字符串，这里传入null就行了，运行程序，两个程序仍然可以接收这个广播。 不过有序广播是可以截断的，怎么设置先后顺序呢？在配置文件中这只优先级： 12345678 &lt;receiver android:name=&quot;.AnotherBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=100&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 通过android:priority属性给广播接收器设置了优先级，优先级高的广播接收器就可以先接收广播，这里将MyBroadcastReceiver的优先级设置成100，保证它会比AnotherBroadcastReceiver先收到广播。 设置了优先级，那么MyBroadcastReceiver就可以选择是否截断广播，修改onReceive中的代码： 1234public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, &quot;received in MyBroadcastReceiver&quot;, Toast.LENGTH_SHORT).show(); abortBroadcast();&#125; abortBroadcast()方法就表示将这条广播截断，后续的广播接收器就不能接收这条广播了，重新运行程序，点击send Broadcast按钮，只有MyBroadcastReceiver中的Toast信息能够弹出，说明这条广播被它截断了。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的算法之广度优先遍历]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[图的遍历方式有两种，一种是广度优先遍历，另一种是宽度优先遍历。 广度优先遍历(BFS)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多线程技术]]></title>
    <url>%2F2018%2F12%2F03%2FAndroid%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[本章学习Android多线程技术，多线程更新UI，用Handler方式解决两个线程之间的通信，同时理解学习Handler的实现原理(Handler、Lopper、MesageQueue三者的关系)，以及AsyncTask异步任务处理类，最后学习线程池的，多个异步任务时，合理利用线程池可以减少系统资源的使用，增加程序的流畅性。 5.1 多线程的建立每个应用启动都会启动一个线程处理UI相关的事物，例如处理用户的点击事件、屏幕绘制，并把相关的事件分发到相应的组件中进行处理，所以主线程又被称为UI线程。 耗时任务也在UI线程处理的话会影响用户体验，阻塞线程，所以在这种一般都是新建一个子线程来处理耗时任务。Android中与java中新建线程方式一样，例如在onCreate()方法中添加如下代码： 12345678910111213new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0;i &lt; 100;i++) &#123; Log.i(&quot;MainActivity&quot;, &quot;当前值是&quot; + i); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); 5.2 子线程更新UI的方法Android中是不能在子线程中更新UI的，否则会抛出异常，我们一般是在子线程中执行耗时任务，执行任务完后发送消息给主线程，通知主线程更新UI。例如，下载文件，下载完成后发送一个消息通知主线程更新界面，提示用户文件已经下载完成。 Android中子线程更新UI的方式有以下四种： 1，用activity对象的runOnUiThread方法 2，View.post(Runnable r) 3, AsyncTask系统SDK提供的处理耗时任务的类 4，Handler解决多线程间的通信 5.2.1 用activity对象的runOnUiThread方法5.3 Handler的使用handler可以发送和处理消息对象或Runnable对象，这些消息对象和Runnable对象与一个线程相关联。 Handler类有两种主要用途： 1，执行Runnable对象，还可设置延迟 2，两个线程之间发送消息，主要用来给主线程发送消息更新UI 5.3.1 为什么要用Handler解决多线程并发问题，假设有多个线程去更新Activity的UI，并且都没有加锁，那么界面会显示不正常，这是不被允许的。Android提供了一套更新UI的机制，也可以使用Handler来实现多个线程之间的消息发送。 1，使用Handler的sendMessage发送消息12345678910111213141516171819202122232425262728293031323334353637383940private Handler handler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case UPDATE_TEXT: textView.setText(&quot;Nice to meet you&quot;); break; default: break; &#125; &#125;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.text); Button changeText = findViewById(R.id.change_text); changeText.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; Message message =new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message); &#125; &#125;).start(); break; default: break; &#125;&#125; 如上代码：这就是Handler消息机制，我们可以通过这个机制来更新UI，也就是异步消息处理机制，解决了在子线程中进行UI操作的问题，下面我们来分析一下Handler消息处理机制。 如上在MainActivity中的代码，我们定义了一个整型常量，表示更新UI操作(在这里是更新textview)，我们新建了一个Handler对象，并重写了handleMessage()方法，在这里对具体的message进行处理，若发现Message的what字段的值等于UPDATE_TEXT，就将TextView显示的内容改成Nice to meet you。 我们再看点击事件的代码，我们并没有在子线程中直接进行UI操作，而是创建了一个Message对象，并将它的what字段值指定为UPDATE_TEXT，然后调用Handler的sendMessage方法将这条Message发送出去。Handler收到这条消息，并在handleMessage()对它进行处理，而此时handlerMessage方法的则是运行在主线程中，我们可以在这里进行UI操作，接下来对Message的what字段进行判断，如果等于UPDATE_TEXT，就将TextView的显示内容改成Nice to meet you。 这就是Android异步消息处理的基本用法，下面分析一下它的原理。 5.4 解析异步消息处理机制Android异步消息主要分为4个部分组成：Message、Handler、MessageQueue、Looper。下面对这4部分进行介绍。 1，Message它是线程之间传递的消息，它可以在内部传递少量的消息，用于在不同的线程之间交换数据。比如我们刚刚用到的what字段，除此之外还可以使用args1和arg2字段来携带一些整型数据，obj携带一个Object对象。 2，Handler处理者，它主要用于发送和处理消息，发送消息一般是使用Handler的sendMessage方法，而发出的消息经过一系列的处理后，最终会传递到Handler的handleMessage方法中。 3，MessageQueue消息队列，主要用于存放所有通过Handler发送的消息，这部分消息会一直存在于消息队列中，等待被处理，每个线程只会有一个消息队列。 4，Looper它是MessageQueue的管家，调用Looper的loop方法后，就会进入一个无限循环中，每当发现MessageQueue中有一条消息后，就会将它取出，并传递到Handler的handleMessage方法中，每个线程只能有一个Looper对象。 问题：主线程的Looper.loop()死循环为什么不会导致ANR？回答这个问题先看ActivityThread的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper();//1 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop();//2 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; // ------------------ Regular JNI ------------------------ private native void nDumpGraphicsInfo(FileDescriptor fd);&#125; 在java程序中main方法是入口，当main方法的代码结束后程序也结束了，所以我们要让一个程序一直或长时间运行知道用户退出才结束程序，那么就要阻塞这个线程，如果不阻塞，那么一个APP刚刚启动main方法结束后，程序直接退出，这是不合适的。 这个阻塞就是通过Looper.loop()来实现的，再看loop()的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block 1 注意此处 if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; msg.target.dispatchMessage(msg);// 2注意此处 end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot; + Thread.currentThread().getName() + &quot;, h=&quot; + msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 这个方法在获取到调用这个方法的线程(即主线程)的looper后，再通过looper获取到了messageQueue，然后进入一个死循环，我们看官方注释，”might block”(当MessageQueue为空时)，所以此时主线程就阻塞在这个地方了，从而导致main方法不会结束而退出而因此避免APP一启动就退出的状况。 那么问题来了，既然阻塞了主线程，那又是如何响应用户操作和回调activity生命周期方法的呢？ 答： 1，这就涉及到了Android中的Handler机制原理和IPC机制，简单概括如下：首先启动一个APP时，此时应该还有其他两个Binder线程(用来和系统进行通信操作，接收系统进程发送的通知)。在thread.attach(false)就创建了新binder线程(具体指ApplicationThread，Binder的服务端，用于接收系统服务AMS发送来的事件)，该Binder线程通过Handler将Message发送给主线程，而ActivityThread并非线程，它没有继承Thread类。其次，主线程的MeassageQueue没有消息时，便阻塞在loop的queue.next()的nativePollOnce()方法里，此时主线程慧释放cpu资源进入休眠状态，直到下个消息到达或有事务发生，通过pipe管道写端写入数据来唤醒主线程工作。这里采用epoll机制，是一种IO多复用机制，可以监听多个描述符，当某个描述符就绪(读或写就绪)，就立即通知相应的程序进行读或者写操作，同步IO，即读写是阻塞的。所以主线程大部分时间是阻塞的，并不会消耗大量CPU资源。 2，Activity的生命周期是怎么实现在死循环体外能够执行起来？ActivityThread的内部类H继承于Handler，通过handler消息机制，简单说Handler机制用于同一个进程的线程间通信。Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施：在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过反射机制，创建Activity实例，然后再执行Activity.onCreate()等方法； 再比如收到msg=H.PAUSE_ACTIVITY，则调用ActivityThread.handlePauseActivity()方法，最终会执行Activity.onPause()等方法。 上述过程，我只挑核心逻辑讲，真正该过程远比这复杂。主线程的消息又是哪来的呢？当然是App进程中的其他线程通过Handler发送给主线程，请看接下来的内容： system_server进程是系统进程，java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。 App进程则是我们常说的应用程序，主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），除了图中画的线程，其中还有很多线程，比如signal catcher线程等，这里就不一一列举。 Binder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事务，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息。 结合图说说Activity生命周期，比如暂停Activity，流程如下： 1，线程1的AMS中调用线程2的ATP；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题） 2，线程2通过binder传输到App进程的线程4； 3，线程4通过handler消息机制，将暂停Activity的消息发送给主线程； 4，主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的调用，最后便会调用到Activity.onPause()，当onPause()处理完后，继续循环loop下去。 参考：https://www.zhihu.com/search?type=content&amp;q=Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BALooper.loop 另附另外两个知乎答案 ActivityThread类是Android App进程的初始类。它里面有我们常见的javamain函数，我们都知道这是java程序的入口。 5.5 使用AsyncTask创建后台线程使用Handler类来发送消息，然后更新UI，这种方式对于整个过程灵活控制，但是也存在缺点，就是代码比较臃肿，当多个任务同时执行时，不易于对线程进行精确控制。为了简化操作，Android提供了工具类android.os.AsyncTask,在代码上要比Handler轻量级。AsyncTask底层是一个线程池，执行多任务时消耗比较少。 AsyncTask的三个参数：Params、Progress和Result。 1，Params：启动任务是需要的参数，例如下载链接地址 2，Progress：执行的进度 3，Result：执行结果 需要重写四个方法：onPreExecute、doInbackground、onProgressUpdate和onPostExecute。 1，onPreExecute：执行任务之前调用 2，doInbackground：执行任务的方法，该方法是多线程调用，所以耗时操作都写在这个方法中，通过调用publishProgress方法更新进度 3，onProgressUpdate：更新任务进度，在调用publishProgress时，这个方法才会被调用，该方法可以把数据直接更新到UI空间上 4，onPostExecute：任务执行完毕调用 以我们使用AsyncTask模拟从网上下载文件为例： 123456789101112131415161718192021222324252627private class DownloadFilesTask extends AsyncTask&lt;String,Integer,Long&gt; &#123; @Override protected void onPreExxcute() &#123; Log.i(&quot;DownloadFilesTask&quot;,&quot;执行任务之前&quot;); &#125; protected Long doInbackground (String... url) &#123; int count = url[0].length();//第一个字符串 long totalSize = 0; for (int i = 0;i &lt; count;i++) &#123; totalSize += i; publishProgress(i);//此方法会调用onProgressUpdate更新下载进度 //如果取消就结束任务 if (isCancled) break; &#125; return totalSize; &#125; protected void onProgressUpdate(Integer... progress) &#123; Log.i(&quot;DownloadFilesTask&quot;,&quot;当前下载进度&quot; + progress[0].intValue()); &#125; protected void onPostExecute(Long result) &#123; Log.i(&quot;DownloadFilesTask&quot;,&quot;下载完成&quot; + result); &#125;&#125; 这是在MainActivity中定义的一个类并让它继承自AsyncTask，定义泛型，重写方法，接下来在onCreate()方法调用这个类。 1new DownloadFilesTask().execute(&quot;www.downloadfile.com); 5.6 线程池的使用线程池是一种多处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。 线程池应用的场景？比如说一个音乐类App，用户需要下载歌曲，下载歌曲很耗时，需要启动一个新的线程进行下载，之前可能会使用如下代码： 12345new Thread(new Runnable() &#123; public void run() &#123; //下载歌曲的代码 &#125;&#125;).start(); 如果要下载1000首歌曲呢？开启1000个线程吗？这会导致什么问题？ 每下载一首歌曲就要新建一个线程，导致频繁的新建销毁线程，会使程序卡主或崩溃 这样创建的线程无法统一管理 不方便统计(例如已下载歌曲的数量) 而线程池能解决以上问题，它的优点如下： 重用已创建线程，不会频繁地创建与销毁线程 对线程统一管理、分配、调优和监控 控制线程数量，合理使用系统资源，这样不会造成程序卡顿或崩溃 Android中的线程操作是通过ThreadPoolExecutor类实现。最长的构造函数有7个参数。 corePoolSize：核心线程数 maximumPoolSize：线程池最大线程数 keepAliveTime：线程空闲保持时间 unit workQueue：线程池中的队列任务，这个队列保存线程池提交的任务，它的使用与线程池中的线程数量有关 threadFactory： handler]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>安卓，多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2018%2F11%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式(Proxy Pattern)也称为委托模式，是结构性模式的一种，它在日常开发中非常常用，实际上在日常生活中也非常常见，对于程序员来讲代理上网，叫同事帮忙买快餐也是代理模式，请律师处理纠纷也是代理模式，总之，它无处不在。 一、代理的定义为其他对象提供一种代理以控制对这个对象的访问。 二、代理模式的使用场景当无法或不想直接访问某个对象时或访问某个对象有困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。 代理模式的UML图如下所示： 代理模式的通用代码： 抽象主题类： 123456public abstract class Subject &#123; /** *一个普通的业务方法 */ public abstract void visit();&#125; 真实主题类： 1234567public class RealSubject extends Subject &#123; public void visit() &#123; //RealSubject中visit的具体实现 System.out.println(&quot;Real Subject!&quot;); &#125;&#125; 代理类： 12345678910111213public class ProxySubject extends Subject &#123; //持有真实主题的引用 private RealSubject mSubject; public ProxySubject (RealSubject mSubject) &#123; this.mSubject = mSubject; &#125; public void visit() &#123; //通过真实主题引用的对象调用真是主题中逻辑方法 mSubject.visit(); &#125;&#125; 客户类： 12345678910111213public classClient &#123; public static void main(String[] args) &#123; //构造一个真实主题对象 RealSunject real = new RealSubject(); //通过真实主题对象构造一个代理对象 ProxySubject proxy = new ProxySubject(real); //调用代理的相关方法 proxy.visit(); &#125;&#125; 以上就是代理模式的通用代码。 三、代理模式的简单实现我们模拟一个打官司的例子，具体的代码如下。 诉讼接口类： 12345678910public interface ILawsuit &#123; //提交申请 void submit(); //进行举证 void burden(); //开始辩护 void defend(); //诉讼完成 void finish();&#125; 可以看到，里面有四个诉讼常规的流程。我们在接口定义四个抽象方法。 具体诉讼人。 1234567891011121314151617public class XiaoMin implements ILawsuit &#123; public void submit () &#123; System.out.println(&quot;老板欠工资，特此申请仲裁！&quot;); &#125; public void burden () &#123; System.out.println(&quot;这是合同书和过去一年银行流水&quot;); &#125; public void defend () &#123; System.out.println(&quot;证据确凿，抵赖也没有用~&quot;); &#125; public void finish () &#123; System.out.println(&quot;诉讼成功，判决老板即日起七天内结算工资！&quot;); &#125;&#125; 如上所述，类实现ILawsuit接口并实现四个抽象方法，实现具体的业务逻辑，接下来是代理类。 代理律师： 1234567891011121314151617181920212223public class Lawyer implements ILawsuit &#123; private ILawsuit mLawsuit; public Lawyer(ILawsuit lawsuit) &#123; mLawsuit = lawsuit; &#125; public void submit () &#123; mLawsuit.submit(); &#125; public void burden () &#123; mLawsuit.bueden(); &#125; public void defend () &#123; mLawsuit.defend(); &#125; public void finish () &#123; mLawsuit.finish(); &#125;&#125; 律师类代表律师，在该类里面会有一个被代理者的引用，律师所执行的方法实质就是简单地调用被代理者中的方法。接下来是客户类。 客户类： 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; //构造一个小民 ILawsuit xiaomin = new XiaoNin(); //构造一个代理律师并将小民作为参数传入 ILawsuit lawyer = new Lawyer(xiaomin); //律师提交申请 lawyer.submit(); //律师举证 lawyer.burden(); //律师辩护 lawyer.defend(); //完成诉讼 lawyer.finish(); &#125;&#125; 这就代理模式，这是一种委托机制，真是对象把方法的执行委托给代理对象，所以代理模式也叫委托模式，代理类也可以代理多个被代理类，就像上面的例子一样，律师可以代理多个人打官司，这也符合现实状况，而具体代理哪个人，则要看代理类持有的实际对象类型。 代理小辉打官司可以吗？当然可以，我们只需要再定义一个XiaoHui类即可，再在客户类新增小辉这个类的引用，作为参数传入代理类的构造方法中。 四、静态代理和动态代理代理模式分为静态代理和动态代理，静态代理如上述例子那样，代理者的代码由程序员自己或者通过一些自动化的工具生成固定的代码再对其进行编译，也就是说我们的代码运行前代理类的class编译文件就已存在；而动态代理则相反，通过反射机制动态地生成代理者的对象，也就是说我们在code阶段压根不需要知道代理谁，代理谁我们将在执行阶段决定，而Java也给我们提供了一个便捷的动态接口InvocationHandler，实现该接口要复写invoke()方法。 123456public class DynamicProxy implements InvocationHandler &#123; public Object invoke (Object args 0,Method args1,Object[] args2) throws Throwable&#123; return null; &#125;&#125; 我们通过invoke方法来调用具体的被代理方法，也就是真实的方法，动态代理可以使我们的代码更简洁，不过我们先要完善代理类。 动态代理类 12345678910111213public class DynamicProxy implements InvocationHandler &#123; private Object obj; public DynamicProxy (Object obj) &#123; this.obj = obj; &#125; public Object invoke (Object proxy,Method method,Object[] args) throws Throwable &#123; //调用被代理类的方法 Object result = method.invoke(obj,args); return result; &#125;&#125; 如上所示，我们申明一个Object的引用，该引用将指向被代理类，而我们调用被代理类的具体方法则在invoke方法中执行。也就是说我们原来由代理类所做的工作现在由InvocationHandler来处理，不需要关心到底代理谁。接下来修改客户类的逻辑。 修改后的客户类： 1234567891011121314151617181920212223242526public static void main (String[] args) &#123; //构造一个小民 ILawsuit xiaomin = new XiaoMn(); //构造一个动态代理 DynamicProxy proxy = new DynamicProxy(xiaomin); //获取被代理类小民的ClassLoader ClassLoader loader = xiaomin.getClass().getClassLoader(); //动态构造一个代理者律师 ILawsuit lawyer = (ILawsuit) proxy.newProxyInstance(loader,new Class[]&#123;ILawsuit.class&#125;,proxy); //律师提交诉讼 lawyer.submit(); //律师进行举证 lawyer.bueden(); //律师替小民进行辩护 lawyer.defend(); //完成诉讼 lawyer.finish();&#125; 结果和以前一致，由此可见动态代理可以通过一个代理类来代理N个被代理类，其实质是对代理者和被代理者进行解耦，使两者没有直接的耦合关系，相对而言静态代理则只能为给定接口下的实现类进行代理，如果接口不同那就需要重新定义不同的代理类，较为复杂，不过静态代理类更符合面向对象原则，在开发时具体使用哪种方式，看我们的业务模式和自己的偏好了。 静态代理和动态代理都是从code方面来区分代理模式的两种方式，我们也可以从其适应范围来区分两种不同类型的代理实现。 远程代理为对象在不同的内存地址空间提供局部代理。使系统可以将server部分的实现隐藏，以便client可以不必考虑server的存在 虚拟代理使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建 保护代理使用代理控制对原始对象的访问。该类型的代理常被用于原始对象有不同访问权限的情况 智能引用在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数 四、Android源码中的代理模式Android源码中有不少使用代理模式的设计，比如源码中ActivityManagerProxy代理类，具体代理的是a、ActivityManagerService的子类ActivityManagerService。ActivityManagerProxy与ActivityManagerNative这个类在同一文件中。 123class ActivityManagerProxy implements IActivityManager &#123;&#125; ActivityManagerProxy实现了IActivityManager接口，该接口定义了一些Activity相关的接口方法，其中有一些我们平时开发也常用到的。 12 IActivityManager接口类就相当于是代理类中的抽象主题，真正的实现主题是谁呢？就是我们提到的继承于ActivityManagerNative的ActivityManagerService类，这几个类之间的大致关系如下： 如上UML图我们可知，ActivityManagerProxy和ActivityManagerNative都实现了IActivityManager，严格来说，ActivityManagerProxy就是代理部分，而ActivityManagerNative就是真是部分，不过ActivityManagerNative是个抽象类，并不处理具体逻辑，大部分逻辑的实现都由其子类ActivityManagerService承担，这也是我们说真是部分是ActivityManagerService而不是ActivityManagerNative，ActivityManagerService是系统级的Service并且运行于独立的进程空间中，可以通过ServiceManager来获取它，而AMP也运行于自己所处的进程空间中，两者并不相同，因此AMP和AMS的通信必定是通过进程间通信来实现的，这里的跨进程实现是基于Android的Binder机制，同时通过上图我们对代理模式的4种适应场景可以判断，此处源码所实现的代理实质为远程代理。AMP在实际的逻辑处理中并未过多地被外部类使用，因为在Android中管理与维护activity相关信息的类是另外一个叫做ActivityManager的类，ActivityManager虽说管理着activity的信息，但是实质大部分逻辑是由AMP承担，以getAppTasks为例，ActivityManager的getAppTasks的逻辑如下： 1234567891011121314public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123; ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;(); List&lt;IBinder&gt; appTasks; try &#123; appTasks = getService().getAppTasks(mContext.getPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; int numAppTasks = appTasks.size(); for (int i = 0; i &lt; numAppTasks; i++) &#123; tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i)))); &#125; return tasks;&#125; 可以看到，逻辑很简单，只是简单地调用了ActivityManager的getService方法获取了一个IActivityManager类型的对象，再调用getAppTasks方法。 注意：在API 26之后，ActivityManagerProxy被移除了，取而代之的是AIDL方式，]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计原则之依赖倒置原则]]></title>
    <url>%2F2018%2F11%2F30%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[依赖倒置原则，英文Dependence Inversion Principle,缩写–DIP。它具体指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次模块的实现细节，依赖模块被颠倒了。总结它的概念有如下几点： 1，高层次模块不依赖于低层次模块，两者都应该依赖其抽象 2，抽象不应该依赖细节 3，细节应该依赖抽象 java中，抽象就是指接口类或者抽象类，他们都不能被实例化，细节就是实现类，实现接口或者继承抽象类类而new的类就是细节，其特点就是，可以直接被实例化。而高层模块就是指调用端，底层模块就是具体实现类。依赖倒置原则在Java中的表现是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类实现的。这又是一个将理论抽象化的实例，一句话概括就是：面向接口编程，或者说面向抽象编程，这里的抽象当然指的是抽象类或接口，面向接口编程是面向对象精髓之一，也就是抽象。 如果类与类之间直接依赖于细节，那他们之间就有直接的耦合，当具体实现需要变化时，意味着要同时修改依赖者的代码，这限制系统的可扩展性。我们来看一个例子： 12345678910111213141516171819public class ImageLoader &#123; //内存缓存 MemoryCache mMemoryCache = new MemoryCache(); //加载图片到ImageView中 public void displayImage(String url,ImageView imageView) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; downloaderImage(url,imageView); &#125; else &#123; imageView.setImageBitmap(bitmap); &#125; &#125; public void setImageCache(MemoryCache cache) &#123; mCache = cache; &#125; //代码省略&#125; 上述代码中，ImageLoader直接依赖于MemoryCache，这个MemoryCache是一个具体实现，而不是一个抽象类或者接口，这导致了ImageLoader直接依赖了细节，当MemoryCache不能满足ImageLoader而需要被其他缓存实现替换时，此时就必须修改ImageLoader的代码。随着产品的升级，MemoryCache不能满足要求，用户需要的ImageLoader可以将图片同时缓存到内存和SD卡中，或者让用户自己自定义实现缓存，这个时候MemoryCache就不能满足需求了。需要重构，如果将MemoryCache修改为DoubleCache，然后在DoubleCache中实现具体的缓存功能，代码修改如下： 123456789101112131415161718192021public class ImageLoader &#123; //双缓存，直接依赖于细节 DoubleCache mCache = new DoubleCache(); //加载图片到ImageView中 public void displayImage(String url,ImageView imageView) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; //异步下载图片 downloaderImageAsync(url,imageView); &#125; else &#123; imageView.setImageBitmap(bitmap); &#125; &#125; public void setImageCache(DoubleCache cache) &#123; mCache = cache; &#125; //代码省略&#125; 这样就好像满足了新的需求，我们将MemoryCache改成了DoubleCache，然后修改了ImageLoader中缓存类的具体实现，轻轻松松搞定了？不是，这还是依赖于具体的实现类(DoubleCache类)细节的，当用户需求再改变时呢？我们再修改源码吗？这违背了开放封闭原则。 解决问题的方法就是依赖于抽象，而不依赖于具体实现。针对图片缓存，建立ImageCache抽象，增加get和set方法用以实现图片的缓存，每种缓存都必须实现这个接口，并且实现自己的存取方法，当用户需要使用不同的缓存实现时，直接通过依赖注入即可，保证了系统的灵活性。 1234567891011121314151617181920212223242526272829303132333435//抽象类public interface ImageCache &#123; public Bitmap get(String url); public Bitmap set(String urk);&#125;//ImagerLoader类public class ImageLoader &#123; //图片缓存类，依赖于抽象，并且有一个默认的实现 ImageCache mCache = new MemoryCache(); //加载图片到ImageView中 public void displayImage(String url,ImageView imageView) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; //异步下载图片 downloaderImageAsync(url,imageView); &#125; else &#123; imageView.setImageBitmap(bitmap); &#125; &#125; public void setImageCache(DoubleCache cache) &#123; mCache = cache; &#125; /** 设置缓存策略，依赖于抽象 */ public void setImageCache (ImageCache cache) &#123; mCache = cache; &#125; //代码省略&#125; 这里，我们建立了ImageCache抽象，ImageLoader依赖于抽象而不是细节。当需求发生变化时，我们只要实现ImageCache类或者继承其他已有的ImageCache子类完成相应的缓存功能，然后将具体的实现注入ImageLoader即可实现缓存功能的替换，这就保证了缓存系统的高可扩展性，有了拥抱变化的能力，这就依赖倒置原则。从上述的学习中，我们发现抽象几乎成为了让系统变得更灵活的唯一选择。]]></content>
      <categories>
        <category>设计原则</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Activity知识相关]]></title>
    <url>%2F2018%2F11%2F29%2FAndroid%E4%B9%8BActivity%E7%9F%A5%E8%AF%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[一、Activity生命周期解析1，典型状态下的activity生命周期 a,onCreate()方法 状态：Activity正在被创建 执行的任务：一般做一些初始化工作，如setContentView界面资源、初始化数据 注意：此方法的传参Bundle为该activity上次被异常情况销毁时保存的状态信息 b,onStart()方法 状态: Activity 正在启动，这时Activity 可见但不在前台，此时activity无法和用户交互 c,onResume()方法 状态：Activity 获得焦点，此时Activity 可见且在前台并开始活动 d,onPause()方法 Activity 正在停止 任务：可做 数据存储、停止动画等操作 注意，Activity切换时，旧Activity的onPause会先执行，然后才会启动新的Activity e,onStop()方法 状态：Activity 即将停止 任务：可做稍微重量级回收工作，如取消网络连接、注销广播接收器等 注意：新Activity是透明主题时，旧Activity都不会走onStop()方法 f,onDestroy()方法 状态：Activity 即将销毁 任务：做回收工作、资源释放 g,onRestart()方法 状态：Activity 重新启动，Activity由后台切换到前台，由不可见到可见 onStart()和onResume()、onPause()和onStop()的区别： onStart与onStop是从Activity是否可见这个角度调用的，onResume和onPause是从Activity是否显示在前台这个角度来回调的，在实际使用没其他明显区别 2,Activity生命周期的切换过程 1) 启动一个Activity：onCreate()–&gt;onStart()–&gt;onResume() 2) 打开一个新Activity：旧Activity的onPause() –&gt;新Activity的onCreate()–&gt;onStart()–&gt;onResume()–&gt;旧Activity的onStop() 3) 返回到旧Activity：新Activity的onPause（）–&gt;旧Activity的onRestart()–&gt;onStart()–&gt;onResume()–&gt;新Activity的onStop()–&gt;onDestory(); 4) Activity1上弹出对话框Activity2：Activity1的onPause()–&gt;Activity2的onCreate()–&gt;onStart()–&gt;onResume() 5) 关闭屏幕/按Home键：Activity2的onPause()–&gt;onStop()–&gt;Activity1的onStop() 6) 点亮屏幕/回到前台：Activity2的onRestart()–&gt;onStart()–&gt;Activity1的onRestart()–&gt;onStart()–&gt;Activity2的onResume() 7) 关闭对话框Activity2：Activity2的onPause()–&gt;Activity1的onResume()–&gt;Activity2的onStop()–&gt;onDestroy() 8) onPause()–&gt;onStop()–&gt;onDestroy() 3,生命周期的各个阶段 1，完整生命周期：Activity在onCreate()和onDestroy()之间所经历的。在onCreate()中完成各初始化操作，在onDestroy()中释放资源。 2，可见生命周期：Activity在onStart()和onStop()之间所经历的。活动对于用户是可见的，但仍无法与用户进行交互。 3，前台生命周期：Activity在onResume()和onPause()之间所经历的。活动可见，且可交互。 4，onSaveInstanceState方法和onRestoreInstanceState方法 a, 出现的时机：异常 情况下Activity 重建，非用户主动去销毁 b, 系统异常终止时，调用onSavaInstanceState来保存状态,该方法调用在onStop之前，但和onPause没有时序关系。 onSaveInstanceState与onPause的区别：前者适用于对临时性状态的保存，而后者适用于对数据的持久化保存。 c, Activity被重新创建时，调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。 可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。另外，谷歌更推荐使用onRestoreInstanceState进行数据恢复。 5, Activity异常情况下生命周期分析 a,由于资源相关配置发生改变，导致Activity被杀死和重新创建,例如屏幕发生旋转：当竖屏切换到横屏时，会先调用onSaveInstanceState来保存切换时的数据，接着销毁当前的Activity，然后重新创建一个Activity，再调用onRestoreInstanceState恢复数据。生命周期方法调用：onSaveInstanceState–&gt;onPause（不定）–&gt;onStop–&gt;onDestroy–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState–&gt;onResume b, 由于系统资源不足，导致优先级低的Activity被回收。 1, Activity优先级排序：前台可见Activity&gt;前台可见不可交互Activity（前台Activity弹出Dialog)&gt;后台Activity（用户按下Home键、切换到其他应用） 2, 当系统内存不足时，会按照Activity优先级从低到高去杀死目标Activity所在的进程。 3, 若一个进程没有四大组件在执行，那么这个进程将很快被系统杀死。 二、Activity四种启动模式1，设置activity启动模式的方法： a, 在AndroidManifest.xml中给对应的Activity设定属性android:launchMode=”standard|singleInstance|single Task|singleTop”。 b, 通过标记位设定，方法是intent.addFlags(Intent.xxx)。 2, Activity的四种LaunchMode a, standard：标准模式、默认模式:含义：每次启动一个Activity就会创建一个新的实例。注意：使用ApplicationContext去启动standard模式Activity就会报错。因为standard模式的Activity会默认进入启动它所属的任务栈，但是由于非Activity的Context没有所谓的任务栈。 b, singleTop：栈顶复用模式:含义：如果新Activity已经位于任务栈的栈顶，就不会重新创建，并回调onNewIntent(intent)方法。 c, singleTask：栈内复用模式:含义：只要该Activity在一个任务栈中存在，都不会重新创建，并回调onNewIntent(intent)方法。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，并把该Activity放进去；如果存在，就会创建到已经存在的栈中。 d, singleInstance：单实例模式:含义： 具有此模式的Activity只能单独位于一个任务栈中，且此任务栈中只有唯一一个实例。 标识Activity任务栈名称的属性：android：taskAffinity，默认为应用包名。 3, 常用的可设定Activity启动模式的标记位 a, FLAG_ACTIVITY_SINGLE_TOP:对应singleTop启动模式。 b, FLAG_ACTIVITY_NEW_TASK ：对应singleTask模式。 三、IntentFilter匹配规则 原则： a, 一个intent只有同时匹配某个Activity的intent-filter中的action、category、data才算完全匹配，才能启动该Activity。 b, 一个Activity可以有多个 intent-filter，一个 intent只要成功匹配任意一组 intent-filter，就可以启动该Activity。 1, action匹配规则： a, 要求intent中的action 存在且必须和intent-filter中的其中一个 action相同。 b, 区分大小写 2, category匹配规则： a, intent中的category可以不存在，这是因为此时系统给该Activity 默认加上了&lt; category android:name=”android.intent.category.DEAFAULT” /&gt;属性值。 b, 除上述情况外，有其他category，则要求intent中的category和intent-filter中的所有category 相同。 3, data匹配规则 a, 如果intent-filter中有定义data，那么Intent中也必须也要定义date。 b, data主要由mimeType(媒体类型)和URI组成。在匹配时通过intent.setDataAndType(Uri data, String type)方法对date进行设置。 c, 要求和action相似：如果没有指定URI，默认值为content和file; 有多组data规则时，匹配其中一组即可。 采用隐式方式启动Activity时，可以用PackageManager的resolveActivity方法或者Intent的resolveActivity方法判断是否有Activity匹配该隐式Intent。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发艺术探索第二章学习笔记]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本章主要学习IPC机制，首先介绍Android中多进程以及多进程开发中的常见注意事项，接着介绍Android中的序列化和Binder，然后详细介绍Bundle、文件共享、AIDL、Messenger、ContentProvider和Socket等进程通信模式。2.1 Android IPC简介IPC(Inter-Process Communication)，即为跨进程通信，先理解线程和进程；线程：CPU调度的最小单元，同时线程是一种有限的系统资源，单个进程不单独享有能够使其独立运行的资源。而进程一般指一个独立单元，在PC和移动设备上指一个应用程序或者一个应用。一个进程包含多个线程。在Android中，主线程也叫UI线程，在UI线程里才可以操作界面元素。很多时候，一个进程要执行大量的耗时任务，如果这些任务放在主线程去执行就会导致界面无法响应，严重影响用户体验，会导致ANR(Application Not Responding)，即应用无响应，解决问题时，把耗时操作放在线程(非UI线程)中即可。 IPC方式：Windows：剪切板、管道、邮槽进行进程间通信；Linux通过命名管道、共享内容、信号量来进行进程间通信。不同的操作系统采用不同的方式。Android基于Linux内核，但是也有自己独有的进程间通信方式，在Android中最有特色的就是Binder了，Binder可以轻松地实现进程间通信，Android还支持Socket进行进程间通信。 2.2 Android中的多进程模式通过给四大组件指定android:process属性，我们可以轻易地开启多进程模式，但是多进程在使用的时候却有很多需要注意的地方。 2.2.1 开启多进程模式一般多进程指一个应用中存在多个进程的情况。给四大组件指定android:process属性开启多进程，除此之外没有其他的方法，当然还有一种非常规的方法，就是通过JNI在native层去fork一个新的进程，但是这种方法特殊，不是常见的创建多进程的方法。 Android系统会给每个应用分配一个U唯一的ID，具有相同的UID的应用才能共享数据，两个应用通过sharedUID跑在同一个进程中是有要求的，需要这两个应用有相同的SHaredUID并且签名相同才可以。在这种情况下，他们可以互相访问对方的数据，比如data目录、组件信息，不管他们是否是跑在同一个进程中。当然如果他们跑在同一个进程中，那么除了能共享data目录、组件信息外，还能共享内存数据，或者说他们看起来像一个应用的两部分。 2.2.2 多进程模式运行机制2.3.3 BinderBinder是一个很深入的话题，这里先不深入探讨Binder的底层细节，因为Binder太复杂了。本章侧重Binder的使用以及上层原理。 直观来说，Binder是Android中的一个类，它实现了IBinder接口，从IPC角度来说，Binder是Android中进程间通信的一种方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有，从Android Framework来说，Binder是ServiceManager连接各种manager(ActivityManager、WindowManager)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，客户端可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓，IPC机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发艺术探索第一章学习笔记]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[先附上Activity的生命周期官方经典图： 针对此图：再具体说明一下，分如下几种情况： 1，针对一个特定的activity，第一次启动，回调方法如下：onCreate()–&gt;onStart()–&gt;onResume()。 2，当用户打开新的activity时或者切换到桌面的时候，回调方法如下：onPause()–&gt;onStop()。还有一种特殊情况，如果新Activity采用了透明主题，那么当前Activity不会回调onStop()。 3，当用户再次回到原Activity时，回调方法如下：onRestart()–&gt;onStart()–&gt;onResume()。 4，当用户按back键返回时，回调方法如下：onPause()–&gt;onStop()–&gt;onDestroy()。 5，当Activity被系统回收后再次打开，生命周期方法回调和步骤1一样，注意只是生命周期方法一样，不代表所有过程都一样，这个问题下一节详细说明。 6，从整个生命周期来说，onStart()和onDestroy()是一对，分别标识着Activity的创建和销毁，并且只有可能调用一次。从Activity是否可见来说，onStart()和onStop()是配对的，从Activity是否在前台来说，onResume()和onPause()是配对的，随着用户操作或者设备屏幕的点亮和熄灭，这两个方法可能会调用多次。 问题：1，onSatrt和onResume、onPause和onStop有什么区别呢？对开发者来讲有什么实质不同？ 2，假设当前Activity为A，如果这是用户打开一个新的Activity B，那么B的onResume和A的onPause哪个先执行呢？ 第一个问题，这两对回调方法的意义不同，onStart和onStop是从Activity是否可见这个角度来说的，而onResume和onPause这对方法是从Activity是否位于前台来讲的。 第二个问题，从源码看可以得到解释，Activity的启动比较复杂，涉及到，Instrumentation、ActivityThread和ActivityManagerService(简称AMS)。简单理解，启动Activity的请求由Instrumentation处理，然后它通过Binder来向AMS发请求，AMS内部维护一个ActivityStack并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期方法的调用，在ActivityStack中的resumeTopActivityInnerLocked方法中，有这么一段代码： 12 从代码看出，在新Activity启动之前，栈顶的Activity需要先onPause()，新的Activity才能启动，最终，在ActivityStackSupervisor中的realStartActivityLocked方法才会调用如下代码： 12 不能在onRause做重量级的耗时操作，因为必须onPause后新Activity才能执行onResume方法，所以onPause和onStop都不能执行耗时的操作，我们应该尽量在onStop执行操作，使得Activity尽快显示出来并切换到前台。 1.2 异常情况下的生命周期分析1，情况一：资源相关的系统配置发生改变导致Activity被杀死并重新创建 IntentFilter的匹配规则启动Activity分为两种方式，显式调用和隐式调用。区别是显式调用要明确指定被启动对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息。原则上一个Intent不应该既是显式调用又是隐式调用，如果二者共存的话以显式为主。显示调用较为简单，这里介绍隐式调用。隐式调用要求Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。IntentFilter中的过滤信息有action、category、data。下面详细分析各种属性的规则。 1，action的匹配规则 2，category的匹配规则 3，data的匹配规则]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap原理]]></title>
    <url>%2F2018%2F11%2F10%2FHashMap%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1，HashMap可以接受null键值和值，而HashTable则不能，HashMap是非synchronized的；存储的是键值对 2，HashMap是基于hashing原理,使用put(key,value)存储对象到HashMap中，使用get(key)从HashMap中获取对象，当我们给put方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来存储键对象和值对象，作为Map.Entry. 3，如果两个对象hashCode相同： 存储时：他们会找到相同的bucket位置，发生碰撞，因为HashMap使用链表存储对象（每个Map.Entry都有一个next指针），这个Entry会存储在链表中。 获取时:会用hashCode找到bucket位置，然后调用key.equals()方法找到链表中正确的节点.最终找到要找的值对象. 减少碰撞：使用final修饰的对象、或不可变的对象作为键，使用(Integer、String)（是不可变、final的,而且已经重写了equals和hashCode方法）这样的wrapper类作为键是非常好的，（我们可以使用自定义的对象作为键吗？答：当然可以，只要它遵守了equals和hashCode方法定义规则，并且当对象插入到Map中之后将不会再改变。） 4，HashMap负载因子默认是0.75，可设置，当map填满了75%的bucket时候，将会创建原来HashMap大小两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中,这个过程叫做rehashing，因为它调用hash方法找到新的bucket位置。 5，重新调整map大小可能会发生竞争问题：如果两个线程都发现HashMap需要调整大小了，它们都会尝试进行调整，在调整中，存储在链表中的元素的次序会反过来，因为移动bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历，如果条件竞争发生了，就死循环了。 转载： HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道HashMap和Hashtable之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！ “你用过HashMap吗？” “什么是HashMap？你为什么用到它？” 几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” 你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。” 但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： “当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问： “如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。 其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 如果你能够回答这道问题，下面的问题来了：“你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：） 热心的读者贡献了更多的关于HashMap的问题： 1，为什么String, Interger这样的wrapper类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 2，我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 3，我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点： 1， hashing的概念 2， HashMap中解决碰撞的方法 3， equals()和hashCode()的应用，以及它们在HashMap中的重要性 4， 不可变对象的好处 5， HashMap多线程的条件竞争 6， 重新调整HashMap的大小 总结HashMap的工作原理： HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。 当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。 因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓进阶解密第十章学习笔记]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%AE%89%E5%8D%93%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[java虚拟机概述我们常说的JDK(Java Development Kit)包含了Java语言、Java虚拟机和Java API类库三部分，这是java开发的最小环境，而JRE(Java Runtime Environment)包括了Java API中的Java SE API子集和Java虚拟机这两部分，是Java程序运行的标准环境。可以看出Java虚拟机的重要性，它是整个Java平台的基石，是Java语言编译代码的运行平台。你可以把Java虚拟机看作一个抽象的计算机，它有各种指令集和各种运行时数据区域。Java虚拟机不仅仅可以运行Java，还可以运行kotlin、Croovy、Scala、Jython等。 Java虚拟机家族Java虚拟机不是一个，而是有很多实现。很多人认为一般说Java虚拟机就是指Oracle的HotSpot虚拟机，实际上不是，不过HotSpot虚拟机应用最广泛就是了，下面简单介绍几种主流的虚拟机实现。 1,HotSpot VMOracle JDK和OpenJDK中自带的虚拟机，是最主流和使用最广泛的Java虚拟机。介绍Java虚拟机的文章，如果不做特殊说明，一般都指HotSpot VN。HotSpot VM并非是Sun公司开发的，而是由Longview Technologies这家小公司设计的，它在1997年被Sun收购，Sun公司又在2009年被Oracle收购。 2，J9 VMJ9 VM是IBM开发的，目前是其主力发展的Java虚拟机。J9 VM的市场定位和HotSpot VM接近，它是一款设计上从服务器到桌面应用再到嵌入式都考虑到的多用途虚拟机，目前J9 VM的性能水平大致与HotSpot是一个档次的。 3，Zing VM以Oracle的HotSpot VM为基础，改进了许多影响延迟的细节。最大的3个卖点如下： a,低延迟,”无暂停”的C4 GC，GC带来的暂停可以控制在10ms以下的级别，支持的Java堆大小可以达到1TB。 b,启动后快速预热功能 c，可管理性：零开销、可在生产环境全时开启、整合在JVM内的监控工具Zing Vision。 需要注意的是，Android中的Dalvik和ART虚拟机并不属于Java虚拟机，因此这里没有列出他们，11章学习Dalvik和ART虚拟机。 Java虚拟机执行流程执行一个Java程序时，它的执行流程是这样,如下图所示： 可以看出Java虚拟机执行流程分为两大部分：编译时环境和运行时环境，当一个Java文件经过Java编译器编译后会生成class文件，它会由Java虚拟机来处理。Java虚拟机与Java虚拟机语言没有什么必然的关系，它只与特定的二进制文件：class文件有关。因此无论任何语言只要能编译成class文件，就能被Java虚拟机识别并执行。如下图所示 Java虚拟机结构如图所示，这里讲的体系结构，是指Java虚拟机的抽象行为，而不是具体的比如HotSpot VM的实现。按照Java虚拟机规范，抽象的java虚拟机如图3所示。 java虚拟机结构包括运行时数据区域、执行引擎、本地库接口和本地方法库，方法区和堆是所有线程共享的数据区域。 类的生命周期一个Java文件加载到Java虚拟机内存中从内存中卸载的过程被称为类的生命周期。类的生命周期包括的阶段：加载、链接、初始化、使用和卸载。广义上类的加载分为：加载、链接(验证、准备和解析)、初始化。 接下来介绍各个阶段所做的工作，如下所示： 1，加载：查找并加载class文件 2，链接：包括验证、准备和解析 a,验证：确保被导入类型的正确 b,准备：为类的静态字段分配字段，并用默认值初始化这些字段 c,解析：虚拟机将常量池内的符号引用替换为直接引用 3，初始化：将类变量初始化为正确初始值根据《深入理解Java虚拟机》，加载阶段(并非类的加载)主要做了三件事： 1，根据特定名称查找类或接口类型的二进制字节流 2，将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构 3，在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 类加载子系统Java虚拟机中有两种类加载器：系统加载器和自定义加载器。其中系统加载器包括以下三种： 1，Bootstrap ClassLoader (引导类加载器) 用c/c++实现的，用于加载指定的JDK核心类库，java.lang.,java.uti.等。它用来加载/jre/lib和-Xbootclasspath参数指定的目录。 JVM就是通过引导类加载器创建一个初始类来完成的，由于类加载器是C/C++实现的，所以该加载器不能被Java代码所访问，但是可以查询某个类是否被引导类加载器加载过。 2，Extensions ClassLoader (扩展类加载器) Java实现，加载以下目录的类文件: a,/jre/lib/ext b,系统属性java.ext.dir所指定的目录 3，Application ClassLoader (应用程序加载器) 又称作System ClassLoader(系统类加载器)，这是因为这个类加载器可以通过ClassLoader的getSystemClassLoader方法获取到，用于加载以下类库文件： a,当前应用程序ClassPath目录 b,系统属性java.class.path指定的目录 运行时数据区域通常我们将Java的内存分为堆内存(Heap)和栈内存(Stack)，实际上这种分发并不准确，Java的内存区域划分实际上比这要复杂，Java虚拟机在执行的Java的过程中会把它所管理的内存划分为不同的数据区域，根据《Java虚拟机规范(Java SE7)》的规定，这些数据区分为程序计数器PC、Java虚拟机栈、本地方法栈、Java堆和方法区。下面一一对他们进行介绍。 1，程序计数器PC 当前线程所执行的字节码行号指示器，每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；当线程正在执行的一个Native方法时，PC计数器则为空(Undefined)。 2，虚拟机栈 虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)执行的同时都会创建一个栈帧结构，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。 栈帧(Stack Frame)结构栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机站的栈元素。见上图， 栈帧包括： a, 局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位。 b, 操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配 c, 动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。 1, 前面的解析过程其实是静态解析； 2, 对于运行期转化为直接引用，称为动态解析。 d, 方法返回地址 1, 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者 2, 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。 e, 额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。 Java虚拟机规范规定该区域有两种异常： a,StackOverFlowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出 b,OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出 3,本地方法栈 本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。 异常(Exception)：Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。 4,java堆 Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。 a, 从内存回收角度，Java堆被分为新生代和老年代；这样划分的好处是为了更快的回收内存； b, 从内存分配角度，Java堆可以划分出线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)；这样划分的好处是为了更快的分配内存；对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。 另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存。 异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 5，方法区方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。GC在该区域出现的比较少。 异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 6，运行时常量池 运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。 1， 字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。 2， 符号引用：编译语言层面的概念，包括以下3类： a，类和接口的全限定名 b，字段的名称和描述符 c， 方法的名称和描述符 但是该区域不会抛出OutOfMemoryError异常。 以上运行时数据区域内容学习自gityuan博客，gityuan.com。 GC算法垃圾标记算法1，引用计数法每个对象有一个引用计数器，当对被引用时它的引用计数器就加1，引用失效就减1，引用计数器中的值为0时，则该对象不能被使用，变成了垃圾。这不是主流的垃圾标记算法，不选择引用计数法来判断垃圾主要是因为引用计数法没有解决对象之间相互引用的问题。 2，根搜索法 这是目前主流的垃圾标记算法 垃圾收集算法垃圾被标记后，GC就会对垃圾进行收集，接下来介绍常用的垃圾回收算法 1，标记清除 标记阶段：标记出可以被回收的对象清除阶段: 回收被标记的对象所占用的空间标记–清除算法是基础的，是因为后面的几个算法都是在此基础上进行改造的。标记清除算法有两个缺点： a,标记的效率不高， b,容易产生大量的不连续的碎片，碎片太多可能会导致后续没有足够的连续内存分配给较大的对象，从而提前出发GC。 2，复制算法 复制算法是每次只使用一半的内存，GC时，遍历当前的区域，把存活的对象复制到另外一个区域中，最后将当前使用的区域的可回收对象进行回收，复制算法每次都对半个区域进行回收，不需要考虑碎片的问题，缺点是每次只能使用一半的内存。复制算法的效率和存活的对象数目有很大的关系，如果存活的对象很少，那么效率就高，由于绝大多数对象的生命周期很短，并且这些对象都在新生代中，所以复制算法被广泛应用于新生代中。 3，标记-压缩算法 新生代使用复制算法，老年代就不适合使用了，因为老年代的对象存活率高，若在老年代使用复制算法，这样就会产生较多的复制操作，导致效率变低。与标记清除算法不同的是，在标记可回收的对象之后，将存活的对象压缩到内存的一端，使它们紧紧排列在一起，然后对边界以外的内存进行回收，回收后，已用的和未被使用的内存各占一边。 4，分代收集 Minor Collection:新生代垃圾收集Full Collection:对老年代进行收集，又称Major Collection，Full Collection通常情况下会伴随至少一次的Minor Collection，它的收集频率低，耗时较长 执行一次Minor Collection时，Eden空间的存活对象会被复制到To Survivor空间，并且之前进过一次Minor Collection并在From Survivor空间的对象也会被复制到To Survivor空间。两种情况下不会复制到To Survivor空间而是晋升到老年代。一种是存活的对象的分代年龄超过-XX:MaxTenuringThreshold (用于控制对象经历多少次Minor GC才晋升到老年代)所指定的阈值；另一种是To Survivor空间满了，也是达到阈值。当所有存活对象都被复制到To Survivor空间，或者晋升到老年代，也就意味着Eden区和From Survivor区剩下的都是可回收对象。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F09%2F07%2Ftest%2F</url>
    <content type="text"><![CDATA[这是一个测试文档，测试Markdown语法，在这里是测试插入一张图片。 添加一张风景图 测试。测试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式]]></title>
    <url>%2F2018%2F08%2F31%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1，单例设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的继承覆盖]]></title>
    <url>%2F2018%2F08%2F27%2F%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%AD%90%E7%88%B6%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9%E4%BD%93%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[当子父类中出现成员函数一模一样的情况，会运行子类的函数。这种现象，称为覆盖操作，这是函数在子父类中的特性。函数两个特性：1，重载：在同一个类中。overload2，覆盖，子类中，也称为重写。override 覆盖注意事项：1，子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限。2，静态只能覆盖静态，或被静态覆盖。 什么时候使用覆盖操作？当对一个类进行子类的拓展时，子类要保留父类的功能申明，但是需要定义子类该功能的的特有内容时，就使用覆盖操作完成。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java程序输出100至200的所有素数]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%87%BA100%E8%87%B3200%E7%9A%84%E6%89%80%E6%9C%89%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[解决思路：1，定义一个类，名字为TestPrimeNumber。2，在类中定义主函数。3，用for循环打印出所有在100至200之间的质数。4，在for循环中，判断每当循环执行一次，就判断循环变量的值是否为素数，如果是，就把循环变量的当前值大于出来。5，比如一个数为n，就用2至n-1来除n，以此来判断是否是素数。如果从2至n-1都无法整除n，就是素数。 123456789101112class printPrimeNumber&#123; public static void main(String[] args) &#123; for (int i = 100;i &lt;= 200;i++&gt;) &#123; for (int j = 2;j &lt; i;j++&gt;) &#123; if (i % j == 0) &#123; break; &#125; &#125; System.out.print(i + &quot; &quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类:抽象：笼统，模糊，不具体。 特点:1,方法只有申明没有实现时，该方法就是抽象方法，需要abstract修饰。抽象方法必须定义在抽象类中，该类必须也被abstract修饰。 2，抽象类不可以被实例化，为什么？因为调用抽象方法没意义。 3，抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化，否则，子类还是抽象类。 1)，抽象类中有构造函数吗？有，用于给子类对象初始化。 2)，抽象类可以不定义抽象方法吗？ 可以的，但是很少见，目的就是不让该类创建对象，AWT的适配器对象就是这 种类。通常这个类中的方法 有方法体却没有内容。 3)，抽象关键字不可以和哪些关键字共存？private 不行。static不行。final不行。 4，抽象类和一般类的异同点。相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员。不同点：1)，一般类有足够的信息描述事物。抽象类描述事物的饿信息有可能不足。2)，一般类中不能定义抽象方法，只能定义非抽象方法。抽象类中可以定义抽象方法，也可以定义非抽象方法。3)，一般类可以被实例化抽象类不可以被实例化。 5，抽象类一定是个父类吗？是的，因为需要子类覆盖其方法后才可以对子类实例化。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java接口初步理解]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[12345abstract class AbsDemo&#123; abstract void show1(); abstract void show2();&#125; 当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式来定义和表示，就是 接口： interface 定义接口使用的关键字不是class而是 interface。对于接口中常见的成员：而且这些成员都有固定的修饰符。1，全局常量：public static final2，抽象方法：pulbic abstract由此得出结论，接口中的成员变量都是公共的权限。 123456interface Demo&#123; public static final int NUM = 4; public abstract void show1(); public abstract void show2();&#125; 类与类之间是继承关系，类与接口之间是实现关系接口不可以实例化。 1234567891011class DemoImpl implements /*实现*/Demo&#123; public void show1() &#123; &#125; public void show2() &#123; &#125;&#125; 在java中不直接支持多继承，因为会出现调用的不确定性所以java将多继承机制进行改良，在java中变成多实现。一个类可以实现多个接口。 1234567891011121314151617181920interface A&#123; public void show();&#125;interface Z&#123; public void show();&#125;class Test implements A,Z//多实现&#123; public int add(int a,int b) &#123; return a+b+3; &#125; public void show()&#123;&#125;&#125; 一个类在继承另一个类的同时，还可以实现多个接口。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类小demo]]></title>
    <url>%2F2018%2F08%2F27%2FString%E7%B1%BB%E5%B0%8Fdemo%2F</url>
    <content type="text"><![CDATA[关于string类的一些小demo。 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast.String.demo;public class StringDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub /* * String类的特点; * 字符串对象一旦被初始化就不会被改变。 */ StringDemo2(); &#125; public static void StringDemo2() &#123; // TODO Auto-generated method stub String s = &quot;abc&quot;;//创建一个字符串对象在常量池中 String s1 = new String(&quot;abc&quot;);//创建两个对象一个new，一个字符串对象在堆内存中。 System.out.println(s==s1);//，比较地址值，是同一个字符串指向不同的引用，所以是false System.out.println(s.equals(s1));//true//String类的中equals复写了object中的equals方法，建立了String类自己 //判断字符串对象是否相同的依据，实际上就是比较字符串的内容(不是地址值)。// System.out.println(&quot;s=&quot;+s);// System.out.println(&quot;s1=&quot;+s1); &#125; /** * 演示字符串定义的第一中方式，并明确字符串常量池特点， * 池中没有就建立，有就直接用。 */ private static void StringDemo1() &#123; String s = &quot;abc&quot;;//&quot;abc&quot;存储在字符串常量池中。// s = &quot;nba&quot;; String s1 = &quot;abc&quot;; System.out.println(s==s1);//true ==比较地址值// System.out.println(&quot;s=&quot;+s); &#125;&#125; 再看一段代码,我们看看String的intern()方法： 123456789String ss = &quot;abc&quot;;String s = new String(&quot;abc&quot;);String s1 = new String(&quot;abc&quot;).intern(); System.out.println(ss == s);System.out.println(ss == s1);//打印结果falsetrue 为什么会是一个false一个true呢？一个String实例str调用intern()方法时，java会查找常量池中是否有相同unicode的字符串常量，如果有就返回它的引用，如果没有就则在常量池中增加一个unicode等于str的字符串并返回它的引用。那上面的代码为什么会打印出不同的结果呢？字面量和运行时常量池JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化，为了减少在JVM中创建的字符串常量，字符串类维护了一个字符串常量池。在JVM运行时区域的方法中，有一块区域是运行时常量池，主要用来存储编译期生成的各种字面量和符号引用。比如java的反编译，在java代码被javac编译后，文件结构中是包含一部分Constant pool的，比如如下代码： 123public static void main(String[] args) &#123; String ss = &quot;abc&quot;;&#125; 经过编译后，在常量池有如下几个重要的内容： 12#21 = Utf8 ss#22 = Utf8 abc ss是符号引用，而abc就是我们提到的字面量，class文件中的常量池部分的内容，会在运行期间被运行时常量池加载进去。new String究竟创建了几个对象String ss = new String(“abc”);创建了几个对象，我们可以知道的信息时s和abc被加载到class文件的常量池中，然后在类加载阶段，这两个常量会进入常量池。不过这个”进入常量池”阶段，并不会直接把所有类中定义的常量全部加载进来，而是会做个比较，如果需要加到字符串常量池中的字符串已经存在，那就不需要再把字符串字面量加载进来了。所以，我们说”若常量池中已经存在”abc”，则直接引用，也就是说此时只会创建一个对象”说的就是这个字符串字面量在字符串池中被创建的过程。再看看运行期间，new String(“abc”);执行的时候是要在java堆中创建一个字符串的，而这个对象所对应的字符串字面量是保存在字符串常量池中的。但是 String s = new String(“abc”);对象的符号引用s是保存在java虚拟机的栈上的，它保存的是堆中刚刚创建出来的字符串对象的引用。所以对于如下代码： 1234String ss = new String(&quot;abc&quot;);String s = new String(&quot;abc&quot;);//输出falseSystem.out.println(ss == s); 输出false，因为 == 比较的是两个对象的地址值。但是使用equals()方法做比较就是比较字符串的字面量了，就会得到true(实际上Object中的equals方法的默认实现也是比较地址值，只不过String类复写了Object类中的equals方法，有自己的实现，这点要搞清楚，equals方法通常在需要比较两个对象的时候调用，一般这个时候我们都会复写它)。常量池的对象时在编译期就确定好了的，在类被加载的时候创建的，如果类被加载时，该字符串常量在常量池中已经有了，这一步就省略了。堆中的对象时在运行期才确定的，在代码执行期到new的时候创建的。 运行时常量池的动态扩展编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但并不是全部。那么还有一种情况，可以在运行期间向运行时常量池中增加常量，这就是String的intern()方法。String类的对象调用intern()方法时，java查找常量池中是否有相同unicode的字符串常量，若有，则返回其引用；若没有则在常量池中增加一个Unicode等于str的字符串并返回它的引用。intern()方法有两个作用，第一个是将字符串字面量放入常量池，第二个是返回这个常量的引用。再看这个例子： 123456789String ss = &quot;abc&quot;;String s = new String(&quot;abc&quot;);String s1 = new String(&quot;abc&quot;).intern(); System.out.println(ss == s);System.out.println(ss == s1);//运行结果falsetrue 可以简单理解为String ss = “abc”;和String s1 = new String(“abc”).intern();做的事是一样的(实际有区别，暂时不展开)，都是定义一个字符串对象，然后将其字面量保存在常量池中，并把这个字面量的引用返回给定好的对象引用。对于String s1 = new String(“abc”).intern();在不调用intern的情况下，s1是指向JVM在堆中创建的那个对象的引用，但执行了intern方法，s1将指向字符串常量池中的字符串常量。由于ss和s1都是字符串常量池中的字面量的引用，所以ss == s1，但是s的引用是堆中的对象，ss != s。intern的正确用法常量池是要保存已确定的字面量值。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串常量池。如果在字符串的拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成StringBuilder.append，这种情况编译器是无法知道其确定值的。只有在运行期间才能确定。有这个特性，intern就派上用场了，很多时候，程序中得到的字符串是只有在运行期才能确定的，在编译器间是无法确定的，那么也就没办法在编译期间被加入到常量池中。这时候，对于那种可能被经常使用的字符串，使用intern进行定义，每次JVM运行代这段代码的时候会直接返回常量池中该字面量的引用，这样就可以减少大量字符串对象的创建了。为什么java把字符串设计成不可变的 12String s =&quot;abc&quot;;String s1 = &quot;abc&quot;; 只会在堆中的常量池建立一个对象。如果可变的话，当两个引用指向同一个字符串时，对其中一个做修改就会影响另外一个。缓存hash码java中会经常用到字符串的hash码(hashcode)，例如，在hashmap中，字符串的不变性能保证其hashcode永远保持一致，这样就可以避免一些不必要的麻烦，也意味着每次在使用一个字符串的hashcode的时候不用重新计算一次，这样更加高效。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java一些面试题]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[12，java创建线程有几种方式？ 有三中方式可以创建线程： 1，继承Thread类 2，实现Runnable接口 3，应用程序可以使用Executor框架来创建线程池 一般来说实现Runnable接口方式更受欢迎，因为这不需要继承，java只支持单继承，在应用已经设计成继承了别的类的时候，就只能实现接口来提高扩展性了。同时，线程池也是非常高效的。 13，线程状态 就绪(Runnable)：线程准备运行，不一定立马就执行 运行(Running):进程正在执行线程的代码 等待(Waiting):线程处于阻塞状态，等待外部的处理结果。 睡眠(Sleeping):线程被强制睡眠。 I/O阻塞:等待I/O操作完成。 同步阻塞(Blocked n Synchronized):等待获得锁。 14，同步方法和同步代码块区别？ 在java中，没一个对象都有一把锁，线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。 15，在监视器(Monitor)内部，是如何做线程同步的？程序该做哪种级别的同步？ 监视器和锁在java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取所之前不允许执行同步代码。 16，什么是死锁(deadlock)？ 两个线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁，结果就是两个进程都陷入了无限的等待中。 17，如何确保n个线程可以访问n个资源同时又不导致死锁？ 使用多线程时候，一种非常简单的避免死锁的方式是:指定获得锁的顺序，并强制线程按照指定的顺序获得锁。因此，如果所有的线程都是以同样的顺序来加锁和释放锁，就不回出现死锁了。18，java集合框架基本接口有哪些？ collection:代表一组对象，每一个对象都是它的子元素。 Set:不包含重复元素的集合。 List:有顺序的集合，并且可以包含重复元素。 Map:存储的是键(key)值(value)对，所以也叫双列集合，可以把键(key)映射到值(value)的对象，键不能重复(值可以)，添加重复的值会把前面的值覆盖掉。19,迭代器 迭代器(Iterator)接口提供了很多对元素集合进行 迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代过程中删除底层集合的元素。 20,Iterator和ListIterator区别？ Iterator可遍历set和list，但ListIterator只能遍历List。 Iterator智能前向遍历，ListIterator即可前向遍历，也可后向遍历。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引。21，快速失败(fail-fast)和安全失败(fail-safe)区别是什么？ 22，java中HashMap的原理是什么？ HashMap是以键值对来存储元素的，HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshoid resizing)。23，hashcode()heequals()的重要性体现在什么地方？ java中的hashmap和equals方法来确定键值对的索引，当根据键获取值得时候也会用到这两个方法。如果没有正确的实现这两个方法两个不同的键可能会有相同的hash值，因此可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素，所以这两个方法的实现对hashmap的精确性和正确性是至关重要的。24,hashmap和hashtable有什么区别？ 他们都实现了map接口，因此很多特性非常相似，但是，它们有以下不同点: 1，hashmap允许键和值是null的，hashtable不允许键和值是null。 2，hashtable是同步的，而hashmap不是。因此，hashmap更适合单线程环境，而hashtable适合于多线程环境。 3，hashmap提供了可供应用迭代的键的集合，因此，hashmap是快速失败的。另一方面，hashtable提供了对键的列举(Enumeration)。 一般认为，hashtable是一个遗留的类。25，array和arraylist区别？ Array可以包含基本类型和对象类型，Arraylist只能包含对象类型。 Array大小固定，ArrayList大小动态变化。 ArrayList提供了更多的方法和特性，如：addAll()、removeAll()、iterator()等等。26，arraylist和linkedlist区别？ 都实现了list接口，有以下不同点: 1,arraylist基于索引，底层是数组，它可以以O(1)时间复杂度进行随机访问。linkedlist是以元素列表形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 2，linkedlist插入、删除操作块，查询慢； arraylist是插入、删除慢，查询块。29，java的优先级队列(Priority Queue)？ 是一个基于优先级的无界队列，元素按照自然顺序排序。30，大O符号？ 31,hashset和treeset区别？ hashset由一个hashmap表来实现，因此，它的元素是无序的，add()，remove()，contains()方法时间复杂度是O(logn)。 GC(Garbage Collectors):垃圾回收32，垃圾回收目的？什么时候进行？ 目的是识别并丢弃应用不再使用的对象来释放和重用资源。33，System.gc(),Runtime.gc()会做什么事？ 都用来提示JVM要进行垃圾回收，但是立即执行还是延迟执行垃圾回收要取决于JVM自身。34，finalize()方法什么时候调用？析构函数(finalization)目的是什么？ 在释放对象占用内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。38，如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 不会，会在下一个垃圾回收周期中，这个对象将是可以被回收的。39，java的堆结构是什么样子的？什么是堆的永久代？ 堆是运行时数据区，所有的类的实例和数组都在堆上分配内存。它在JVM启动时被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器来回收。 堆内存是由死亡的和存活的对象组成的，存活的对策应该是可以访问的，不会被垃圾回收器回收。死亡的对象是应用不可访问尚且还没有被垃圾回收器回收掉的对象。一直垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。41，在java中，对象什么时候可以进行垃圾回收？ 当对象对当前使用这个对象的应用程序变得不可触及的时候，这时候对象就可以被回收了。42,永久代会进行垃圾回收吗？ 不会，若满了或是超过了临界值，会触发完全垃圾回收(Full Gc)，永久代也是被回收的，这就是正确的永久代大小对避免Full Gc是非常重要的。 java8中，移除了永久代，新增了一个叫元数据区的native区。43，java中的两种异常时什么？ Exception和Error，它们都是Throwable的子类，Exception用于程序可以捕捉的异常情况，Error定义了不期望被用户程序捕获的异常，一般直接修改程序。44，throw和throws区别？ throw:用来在程序中明确的抛出异常 throws:用来在表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法调用者才能确保处理可能发生的异常，多个异常用逗号分开。45，异常处理的时候，finally代码块作用(重要性)？ fianlly代码块总会被执行，它主要用来释放资源，如：I/O缓冲区，数据库连接。46，异常处理完成后，Exception对象会发生什么变化？ Exception对象会在下一个垃圾回收过程中被回收掉。47，finally代码块和finalize()区别？ 无论是否有异常，finally块都会执行，主要作用是用来释放被占用的资源。finalize()是Object类的一个protected()方法，它是在对象被垃圾回收之前由java虚拟机来调用的。 java小应用程序Applet48，什么是Applet？ 是能够被包含在HTML页面中的并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中Integer的127和128问题]]></title>
    <url>%2F2018%2F08%2F27%2Fjava%E4%B8%ADInteger%E7%9A%84127%E5%92%8C128%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[有如下代码：1234Integer a = 127,b = 127;Integer c = 128,d = 128;Sysout.out.println(a == b);//trueSystem.out.println(c == d);//false 这是什么原因？ Integer i = 127;的时候会进行自动装箱的操作，就是把基本数据转换成Integer对象，而转换成Integer对象用的是ValueOf方法，看了源码如下(其中一小段)： 1234public static Integer valueOf(int i) &#123; return i &gt;= -128 || i &lt; 128 ? new Integer(i) : SMALL_VALUES[i + 128];&#125;private static final Integer[] SMALL_VALUES = new Integer[256]; 在源码里，Integer把-127-127缓存了下来。认为这些小的数字用到的频率比较高，所以为了优化性能，把这些数缓存了下来。所以当声明的Integer对象值在-128-127之间时，引用的是同一个对象，所以结果是true。 123456String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; String s3 = new String(&quot;abc&quot;);// System.out.println(s1 == s2);//true System.out.println(s1 == s3);//false System.out.println(s2 == s3);//false 这段代码？为什么是这个结果？false可以理解，毕竟是new了不同的对象，第一个为什么是true呢？常量池， 对于String s3 = new String(“abc”);来说，初始化一个新创建的String对象，换句话说，新创建的字符串是参数字符串的一个副本。除非确实需要一份副本，否则这种方法是不必要的，因为String是不可变的。这段话来自官方文档。 意思是：1，在编译器编译的时候，当编译器注意到参数为字符串常量时，即将字符串作为常量放在class文件中的常量区，并在类加载时放入运行时常量池中。2，在new操作符被调用时，在java堆中创建一个新的对象，然后对象的内容为常量池里面对应字符串的一个拷贝。而在String s2 = “abc”被编译的时候，先检查class文件中是否包含该字符串常量，如果包含，直接返回常量池中的对象。因此，在调用new操作时，对象始终存在于堆中，而直接字符串赋值时对象实际上是存在于常量池中的，所以比较结果肯定是false。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this和super关键字的用法]]></title>
    <url>%2F2018%2F08%2F27%2FJava%E4%B8%ADthis%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是从csdn摘抄过来。 this:可以理解为代表自身对象，指向对象本身的一个引用。 1，普通的直接引用 2,局部变量和成员变量重名用this区分，如： 1234567891011121314151617 class Person &#123; private int age = 10; public Person()&#123; System.out.println(&quot;初始化年龄：&quot;+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println(&quot;Harry&apos;s age is &quot;+Harry.GetAge(12)); &#125;&#125; 运行结果为：初始化年龄：10Harry’s age is 12 3，引用构造函数这个和下面super一起讲。 super：可以理解为父类的一个引用，而这个父类指向的是离自己最近的一个父类。super也有三中用法：1，普通的直接引用与this类似，super相当于是指向当前对象的父类，这样可以用super.xxx来引用父类的成员。2，子类中的成员变量或方法与父类中的成员或方法同名。 123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = &quot;China&quot;; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = &quot;Shanghai&quot;; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果为：初始化年龄：10Harry’s age is 12可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。 3，引用构造函数 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt(&quot;父类·无参数构造方法： &quot;+&quot;A Person.&quot;); &#125;//构造方法(1) Person(String name) &#123; prt(&quot;父类·含一个参数的构造方法： &quot;+&quot;A person&apos;s name is &quot; + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt(&quot;子类·调用父类”无参数构造方法“： &quot;+&quot;A chinese coder.&quot;); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt(&quot;子类·调用父类”含一个参数的构造方法“： &quot;+&quot;his name is &quot; + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt(&quot;子类：调用子类具有相同形参的构造方法：his age is &quot; + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese(&quot;codersai&quot;); cn = new Chinese(&quot;codersai&quot;, 18); &#125; &#125; 运行结果：父类·无参数构造方法： A Person.子类·调用父类”无参数构造方法“： A chinese coder.父类·含一个参数的构造方法： A person’s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai父类·含一个参数的构造方法： A person’s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 super和this的异同： super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。super()和this()均需放在构造方法内第一行。尽管可以用this调用一个构造器，但却不能调用两个。this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 9.0正式版发布]]></title>
    <url>%2F2018%2F08%2F27%2FAndroid%209.0%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[注：此篇文章内容来自于刘望舒的公众号。历时一年google于昨天发布了android 9.0正式版，并宣布系统版本android p被正式命名为”Pie”(馅饼)。此名并不意外，此前有关android 9.0系统的活动就是在3月14号举行的，而3月14号正是有名的”Pie”日(圆周率)纪念日。 android 9.0系统重大更新 在正式版本推送前，google曾经陆续发布了三个预览版本，根据google官方博客表示，在这期间共有超过140000名开发者通过android beta项目试用了之前发布的开发者预览版，收到了超过1000条报错与特性请求。 然后经过一系列的开发和反复测试，终于于昨天发布了正式版本，谷歌已经向全球的pixel设备推送了正式版的更新。 动态电量管理 android 9.0主打 AI技术，声称”让智能手机变得更便捷、操作更简单更贴合需求”，利用机器学习技术对系统资源进行有效分配。它能够记录用户最常用的应用，并为这些应用进行有限分配。它能够记录用户最常用的应用，并为这些应用有限分配电量；而一些不常用的应用则会被智能休眠，从而保证充足的电池续航时间。 文本识别与Smart Linkify android 9中对识别文本的机器学习模型进行了扩展，使其可以识别出类似日期或航班号这样的信息，此外，smart linkify还允许开发者通过linkify api使用文本识别模式完成多项操作，比如对用户可采取的操作提出建议，让系统在文本识别精确度与速度上都有所提升。 神经网络 API 1.1 优化了对神经网络api，进行了扩展与改进，进一步优化了android对机器学习硬件加速的支持。神经网络api 1.1,共增加了9个新算子的支持，他们分别是Pad、BatchToSpaceND、SpaceToBatchND、Transpace、Strided Slice、Mean、Div、Sub和Squeeze。TensorFlow Lite就是一个已经用上此API的典型机器学习框架。 凹口屏支持 增加了凹口屏的支持，系统会通过调整状态栏高度将应用内容与屏幕缺口区域分开。如果用户的应用含有沉浸式内容，可调用displaycutout apis确认缺口形状与位置，然后请求围绕缺口进行全面布局。另外，系统还加入了开发者选项模拟任意设备上的凹口形状，极大简化了应用支持凹口屏幕所需要的构建以及测试流程。 文本放大镜 android 9中添加了文字放大镜工具(Magnifier widget)。由于该放大器提供了可以在文本上拖拽的文本放大面板，所以有助于用户精准地定位光标或文本选择手柄。这个功能能够运用在所有附加在窗口的视图上，比如个性化小部件和定制文本呈现等等。而且，该放大器工具还可以提供任何视图或界面的放大版本，而不仅仅是文本。 默认使用HTTPS 为了将所有的网络流量从明文逐渐迁移至TLS，系统改变了从网络安全配置的默认设置，以阻止所有明文流量，强制应用通过TLS建立网络连接，除非开发者明确允许特定域名使用明文传输。 用户隐私保护 android 9新加入了多项机制，加强了对用户隐私的保护。系统禁止所有处于空闲状态的应用对话筒、摄像头和所有sensormanager传感器的访问。当应用的UID空闲时，麦克风将会报告”无音频信号”,传感器将会停止报告事件，应用使用的摄像头也会断开连接，并在应用试图访问时生成错误。 使用wifi-rtt,进行室内定位 android 9为IEEE 802.11mc Wi-Fi协议添加了平台支持(也成为WiFi往返时间，RTT)，可以让用户在应用中使用室内定位功能。在提供硬件支持的android 9设备上，在启动位置服务并勾选”允许获取地理位置信息”选项后，应用就可以使用RTT API测量与附近WiFi接入点的距离。除此之外，android 9中还包括大量其他的新特性，比如借助ART运行时显著提高了应用的特性表现与运行效率；改进和优化了Kotlin代码性能；改善了通知的实用性和可操作性，可以调用新的messagingstyle api来显示对话、附加照片、表情和智能回复建议；引入了统一的身份验证对话框，支持指纹识别、面部识别以及虹膜识别等等更多性能可查看谷歌官方微博。 从今天开始，pixel设备将陆续获取android 9的更新推送。 除此之外，android碎片化问题仍然存在，在android系统版本中，android 6.0占比最多，7.0、7.1占比之和30.8超过6.0，android 8.0份额在提升，速度也很快。 对于开发者有什么意义? 值得关注的是project treble机制，这个机制在9.0开始，google深度集成这一特性，并且不允许厂商进行阉割。这就是为什么今年vivo、小米等国产厂商都在今年的io大会就支持了android p的升级，这也是必须支持。 pt机制带来的好处是，能够帮助oem厂商更快地为旗下android智能手机推送最新的系统版本，同时也能够让厂商更加便利地定制和修改自己的系统。另一方面，也可以让手机厂商绕过芯片厂商直接提供最新的android版本升级。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>google io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓基础]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[3.2 activity相关 一、activity生命周期 avtivity就是负责与用户交互的组件。 1),activity的四种状态，running(运行状态,处于栈顶)/paused()(被透明的activity覆盖或非全屏的activity覆盖，)/stopped()(被另外一个activity完全覆盖)/killed()(activity被回收了，保存的信息不存在了)。 2),activity生命周期。 activity启动：oncreate()(资源加载)–&gt;onstart()(可见,不能交互)–&gt;onresume()(开始与用户开始交互，也可以初始化一些资源)。 点击home键后回到主界面(activity不可见)–&gt;onpause()–&gt;onstop()。 再次回到原activity时，onrestart()(重新启动)–&gt;onstart()–&gt;onresume()。 退出当前activity时–&gt;onpause()–&gt;onstop()–&gt;ondestroy() 3) 安卓进程优先级 前台进程/可见进程/服务进程/后台进程/空进程 二、安卓任务栈 一个task就是若干个activity的集合。三、activity的启动模式 1),standard模式，每次都创建一个activity，标准模式，默认的启动模式 2),singleTop模式，栈顶复用，当activity在栈顶时，再启动该activity时，就不会再创建activity。 3),singleTask模式，栈内复用，若存在栈中则不创建activity，并将activity放于栈顶。 4),singleinstance模式，比较少用四、 scheme跳转协议 页面跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面；通过scheme协议，服务器可以定制化告诉app跳转哪个页面，可以通过通知栏消息定制化跳转页面，可以通过h5页面跳转页面等(推广使用)。 3.3 fragment相关 1),fragment为什么会称为”第五大”组件。 相比activity更节省内存，使用频率高，ui切换更加流畅，可以灵活地加载到activity中。当然它必须依附于activity。 2),fragmnet的加载方式 方式一：动态加载， 方式二：在布局文件中添加fragment 3),fragmentpageradapter和fragmnetstatepageradapter区别？ 答：fragmentpageradapter适用于页面较少的情况，而fragmnetstatepageradapter适用于页面较多的情况，fragmnetstatepageradapter中的destroyItem方法中，有一行mCurTransaction.remove(fragment)。会释放fragment，释放内存。而在fragmentpageradapter类中，destroyItem方法中，代码：mCurTransaction.detach(Fragment(object))。detach并不是真正的回收，而是把fragment与activity分离，适合用于页面较少的情况。 3.4 fragment的生命周期 onAttach()--&gt;onCreate()--&gt;onCreateView()--&gt;onViewCreated()--&gt;Activity-onCreate()--&gt; 3.5 3.6 service有关 一、service应用场景，以及和Thread的区别 service是四大组件之一，可以在后台处理任务，服务没有用户界面，service保活，服务启动后后会一直运行。不能处理耗时操作。 service与thread区别 thread：可以执行异步操作，可独立运行；service则依赖于activity。 service有什么作用呢？service运行在主线程中，实际开发中， 二、 startservice 这种方式启动服务后，即使activity销毁后，服务也会一直存活，除非手动关闭]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java函数式编程之Lambda表达式]]></title>
    <url>%2F2018%2F08%2F26%2Fjava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[“lambda表达式”(lambda expression)是一个匿名函数，lambda表达式是基于数学中符号而得名，是一个匿名函数，即没有函数名的函数。lambda表达式可以表示闭包。 认识lambda。 12345678public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;匿名内部类的执行&quot;); &#125; &#125;).start(); &#125; 设计匿名内部类的目的，就是为了方便程序员将代码作为数据来传递。但是你会发现，这个对象看起来是很多余的，所以我们不想传入对象，只想传入行为。 123new Thread(()-&gt;&#123; System.out.println(&quot;lambda代替内部类&quot;);&#125;).start(); 和实现某接口的对象不同，我们传入了一段代码块–一个没有名字的函数。–&gt;将参数和表达式主题分开，左边是参数，右边是方法体。 Lambda的不同形式1Runnable runnable = ()-&gt; System.out.println(&quot;hello world&quot;); 该lambda表达式不包含参数(因为是空括号)。 123456interface Test &#123; void oneParam(String name); &#125; Test test = s -&gt; System.out.println(&quot;oneParam方法传递参数：&quot; + s); test.oneParam(&quot;我是传递的值&quot;); 控制台输出：oneParam方法传递参数：我是传递的值 (lambda只能用于函数式接口)，如果参数只包含一个参数，可以省略参数的括号。 12345678interface Test2&#123; int add(int a,int b);&#125;Test2 test2 = (x,y) -&gt; x + y;int add = test2.add(10,10);System.out.println(add);控制台输出：20 可以看到，我们在使用lambda的时候创建了一个函数x+y，Test2对象不是表示两个数字的和，而是表示两个数字相加的代码。以上的代码中，参数类型都是由编译器自己推断的，同样，我们可以明确的声明参数类型： 12345interface Test3&#123; long add(long a,long b);&#125;Test3 test3 = (long x,long y) -&gt; x + y;long add = test3.add(10,10); 引用值的要求lambda可以引用非final变量这个属性已经了解，但是要知道，java 8只是放松了这一语法的限制，但实际上要求该变量还是final。String name = “aaa”;不管name在使用lambda的前还是后改动，lambda都会报错：表达式引用的本地变量必须是最终变量或者实际上的最终变量，简单的，我们可以称它为既成事实上的final变量。所以，lambda也称为闭包。lambda表达式类型java中，所有的表达式都有返回值类型，那lambda的返回值类型是什么呢。 123interface Test &#123; void oneParam(String name);&#125; 拿这个例子来说，oneParam方法表示一种行为：接受一个String，返回void。只要方法名和行为和lambda表达式匹配即可完成调用。注意：如果编译器猜不出参数和返回只的类型，则都将视为Object处理。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2018%2F08%2F26%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[kmp算法初探，左神进阶班第一课。 先理解一个字符串的最长匹配长度，前缀和最长后缀，如abcabcd,对于字符d，它的最长前缀的最长后缀的匹配长度是3，abc=abc。aaaaab，这个字符串的最长前缀和最长后缀匹配长度是4，aaaa和aaaa(第一个a开始和最后一个a往前，前缀不能包括最后一个字符，后缀不能包括第一个字符)，人为规定0位置的最长匹配长度为-1，1位置人为规定为0。对于后面的每个位置，都用某种方式求出它的最长前缀和最长后缀。形成一个数组，每个位置就是相对应的这个字符串的最长前缀和最长后缀的长度，当然数组大小等于字符串长度。我们称为next数组。如[-1,0,1,1,3,5]。string 1,string 2,假设有这两个字符串，我们要解决的是str1包含不包含str2，现在假设str1从i位置和str2从0位置开始一一配对，假设到str1的X位置和str2的Y位置不相等，常理来讲我们应该从str1的i+1位置重新开始与str2的0位置开始再进行对比，这是暴力的方法，时间复杂度很高。 KMP算法不是这样，我们先找到str2 Y位置字符的最长字符串匹配长度，这个信息我们之前已经求到了，就是那个next数组，是包含str2所有位置的最长字符匹配长度。这个Y位置的最长后缀所对应的str1的那段字符串，我们规定第一个位置为j位置，重点：现在是j位置和str2的0位置开始配，但是注意最长前缀和最长后缀相等，所以相应的取str2的Z位置与str1的x位置开始配(比较)，这样就大大加速了，这就是kmp的加速方式。加速的实质是我们没有否定从j位置可以配出str2，但是我们否定了i位置到j位置可以配出str2，为什么？假设有一个k位置可以配出str2，k位置对应str2的0位置，那么从k出发到x位置这部分字符串应该等于str2等量的前缀相同，同时这段字符串又与str2的Y位置的前缀一一对应，这样得出来的最长前缀就比之前求出来的最长前缀还要长，可是我们之前是求出了最长字符串匹配长度，这显然不符合已知的情况，所以i到x位置之间是配不出str2字符串的。就是这样就省去了中间这一部分字符串的比较，加快了速度。这是KMP的精髓所在。如此重复，直到一个字符的最长前缀是0的时候，str1的x位置的下一个位置再与str2的0位置开始重新配。kmp算法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static int getIndexOf(String s, String m) &#123; if (s == null || m == null || m.length() &lt; 1 || s.length() &lt; m.length()) &#123; return -1; &#125; char[] str1 = s.toCharArray(); char[] str2 = m.toCharArray(); int i1 = 0; int i2 = 0; int[] next = getNextArray(str2); while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123; if (str1[i1] == str2[i2]) &#123; i1++; i2++; &#125; else if (next[i2] == -1) &#123; i1++; &#125; else &#123; i2 = next[i2]; &#125; &#125; return i2 == str2.length ? i1 - i2 : -1; &#125; public static int[] getNextArray(char[] ms) &#123; if (ms.length == 1) &#123; return new int[] &#123; -1 &#125;; &#125; int[] next = new int[ms.length]; next[0] = -1; next[1] = 0; int i = 2; int cn = 0; while (i &lt; next.length) &#123; if (ms[i - 1] == ms[cn]) &#123; next[i++] = ++cn; &#125; else if (cn &gt; 0) &#123; cn = next[cn]; &#125; else &#123; next[i++] = 0; &#125; &#125; return next; &#125; public static void main(String[] args) &#123; String str = &quot;abcabcababaccc&quot;; String match = &quot;ababa&quot;; System.out.println(getIndexOf(str, match)); &#125;&#125; 以上是代码。假设str和要匹配的string(称之为matchString)匹配到str的字符A和matchString的B字符不相等(意味着前面都一一对应并匹配)，只是从字符A和字符B开始就不匹配，而此时我们已经求到了matchString字符B的最长字符匹配长度以及那个字符串。因为现在已经有了matchString字符串的nextArr数组，nextArr[B]的值表示matchString[0…B]这一段字符串与后缀的最长匹配。我们把这串后缀记为b，前缀记为a。那么下一次匹配检查不再像普通解法那样退回到stri+1重新开始与match[0]的匹配过程，而是直接让strj与matchk开始进行匹配检查。str要匹配的位置仍然是j，不进行退回，对于matchString来说，相当于向右滑动，让match[k]滑动到与str[j]同一位置，然后进行匹配。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher算法分析]]></title>
    <url>%2F2018%2F08%2F26%2FManacher%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Manacher算法是经典的算法，它的作用是给定一个字符串，返回str中最长回文字串的长度。举例，str=”123”，其中的最长回文字串是”1”、”2”、”3”，所以返回1。str=”abc1234321ab”，其中最长的回文字串为”1234321”，所以返回7。 进阶题目分析：给定一个字符串，想通过添加字符的方式使得str整体都变成回文字符串，但要求只能在str的末尾添加字符，请返回在str后面的最短字符串。举例，str=”12”，在str后添加”1”后str变为回文字符串，添加”21”后也是回文串，但是添加”1”的情况是所有的方案中最短的，所以返回”1”。解答：本题重点是介绍Manachre算法，该算法是由Glenn Manacher于1975年首次发明的。Manacher解决的是在线性时间内找到一个字符串的最长回文子串，比起能够解决该问题的其他算法，Manacher算法都比较好理解和实现。先说一个比较好理解的方法。从左到右遍历字符串，遍历到每个字符的时候，都看看以这个字符作为中心能够产生多大的回文字符串。比如str”abacaba”，以str[0]=’a’为中心的回文字符串最大长度为1，以str=’b’为中心的回文字符串最大长度为3,……其中最大的回文字串是以str[3]=’c’为中心的时候。这种方法很好理解，只要解决奇回文和偶回文寻找方式不同就可以。”121”是奇回文。”1221”是偶回文，没有确定的轴，回文的虚轴在”22”中间。但是这种方法有明显的问题，之前遍历过的字符完全无法指导后面的过程，也就是对每个字符来说都是从自己的位置出发，往左右两个方向扩出去检查。这样，对每个字符来说，往外扩的代价都是一个级别的。举一个极端的例子，字符串”aaaaaaaaaaaaaaaa”，对于每一个’a’来讲，都是扩到边界才停。所以对每一个字符扩出去检查的代价都是O(n)，所以总的时间复杂度为O(N*N)。Manacher算法可以做到O(N)的时间复杂度，精髓是之前字符的”扩”的过程可以指导后面字符”扩”的过程，使得每次的”扩”的过程都不是从无开始，以下是Manacher算法的详细过程。 1，因为奇回文和偶回文在判断时比较麻烦，所以对字符串进行一个处理，在每个字符的开头、结尾和中间都加入一个特殊字符’#’，比如”bcb”，处理后变为”#b#c#b#”，然后从每个字符左右扩出去的方式找到最大回文字串就容易多了。对奇回文来说，不这么处理也能通过扩的方式找到，比如”bcb”，从’c’开始向左右两侧扩出去能找到最大回文。处理后为”#b#c#b#”，从’c’往左右两侧扩依然能找到最大回文字串。对偶回文来说，不处理而直接通过扩的方式是找不到的，比如”aa”，因为没有确定的轴，但是处理后为”#a#a#”，就可以通过从中间的’#’扩出去找到最大回文字串。所以通过这样的处理方式，最大回文字串无论是奇回文还是偶回文，都可以通过统一的”扩”的过程找到，解决了差异性的问题。同时要说的是这个特殊字符是什么无所谓，甚至可以是字符串中出现的字符，也不会影响最终的结果，就是起到一个辅助的作用。 具体的处理过程看如下的manacherString方法： 123456789 public static char[] manacherString(String str) &#123; char[] charArr = str.toCharArray(); char[] res = new char[str.length() * 2 + 1]; int index = 0; for (int i = 0; i != res.length; i++) &#123; res[i] = (i &amp; 1) == 0 ? &apos;#&apos; : charArr[index++]; &#125; return res;&#125; 2，假设str处理之后的字符串记为charArr，对每个字符(包括特殊字符)都进行”优化后”的”扩”过程。在介绍”优化后”的扩过程之前，先解释下面三个辅助变量的意义。 1)，数组pArr，长度与charArr一样。pArr[i]的意义是以i位置上的字符(charArr[i])作为回文中心的情况下，扩出去得到的最大回文半径是多少。举个例子，对”#c#a#b#a#c#”来说，pArr[0..9]为[1,2,1,2,1,6,1,2,1,2,1]。我们的整个过程就是在从左到右遍历的过程中，依次计算每个位置的最大回文半径值。 2),整数pR，这个变量的意义是之前遍历的所有字符的所有回文半径中，最右即将到达的位置。还是以”#c#a#b#a#c#”为例来说，还没遍历之前，pR初始值设置为-1，charArr[0]=’#’的回文半径为1，所以目前回文半径向右只能扩到位置0，回文半径最右即将到达的位置为1(pR=1)。charArr[1]=’c’的回文半径为2，此时所有的回文半径向右能扩到位置2，所以回文半径最右即将到达的位置为3(pR=3)。依次类推，在charArr[2]位置的pR为3，charArr[3]=4,charArr[4]=4,charArr[5]=11,此时已经到达整个字符数组的结尾，之后pR不再变化了，换句话说，pR就是遍历过的所有字符中向右扩出来的最大右边界。只要右边界更往右，pR就更新。 整数index，这个变量表示最近一次pR更新时，那个回文中心的位置，以刚刚的例子来说，index就更新为1，……遍历到charArr[5]时pR更新，index就更新为5。之后的过程中，pR不再更新，所以index一直为5。 3，只要能够从左到右一次计算出数组pArr每个位置的值，最大的那个值实际上就是处理后的charArr中最大的回文半径，根据最大的回文半径，再对应回原字符串的话，整个问题就解决了。步骤3就是从左到右依次计算出pArr数组每个位置的值得过程。 1),假设现在计算到i位置，在计算过程中都会不断更新pR和index的值，即位置i之前的index这个回文中心扩出了一个目前最右的回文右边界pR。 2),如果pR-1没有包住当前的i的值，比如”#c#a#b#a#c#”，计算到charArr[1]=’c’的时，pR=1，也就是说，右边界在1的位置，1位置为最右回文半径即将到达但还没有到达的位置，所以当前的pR-1位置没有包住当前i的位置，此时和普通做法一样，从i位置字符开始，向左右扩出去检查，此时的”扩”的过程并没有获得加速。 3),如果pR-1位置包住了当前的i位置，比如”#c#a#b#a#c#”，计算到charArr[6…10]时，pR都为11，此时pR-1包住了位置6~10。这种情况下，检查过程是可以获得优化的，这也是Manacher算法的核心精髓所在。 在一个字符数组中，位置i是要计算回文半径(pArr[i])的位置。pR-1位置此时是包住i的。同时根据index的定义，index是pR更新时那个回文中心的位置，所以如果是pR-1位置以index为中心对称，那么”左大”位置到pR-1位置一定是以index为中心的回文串，我们把这个回文串叫作大回文串，同时把pR-1位置称为”右大”的位置。既然回文半径数组pArr是从左到右计算的，所以位置i之前的位置都已经计算过了回文半径。假设位置i以index为中心向左对称过去的位置为i’，那么i’位置的回文半径也是计算过的。那么以i’为中心的最大回文串大小(pArr[i’])必然只有三种情况，我们一一来分析下，假设以i’为中心的最大回文串的左边界和右边界分别记为”左小”和”右小”。 情况一，”左小”和”右小”完全在”左大”和”右大”内部，即以i’为中心的最大回文串完全在以index为中心的最大回文串的内部。 如果处在情况一下，那么以位置i为中心的最大回文串可以直接确定，就是从”右小’”到”左小’”这一段。 情况二，”左小”和”右小”左侧部分在”左大”和”右大”的外部。这种情况i位置的最大回文串是”右大’”到”右大”这一段。 情况三，”左小”和”左大”是同一个位置，即以i’为中心的最大回文串在以index为中心的最大回文串的边界上。这个要看情况。 4，按照步骤3的逻辑从左到右计算出pArr数组，计算完成后再遍历一遍pArr数组，找出最大回文半径，假设i位置的回文半径最大，即pArr[i]=max,但max只是charArr的最大回文半径，还得对应回原来的字符串，求出最大回文半径的长度(其实就是max-1)。比如原字符串为”121”，处理成charArr之后为”#1#2#1#”。在charArr中位置3的回文半径最大，最大值为4(即pArr[3]=4),对应原字符串的最大回文字串长度为4-1=3. Manacher算法时间复杂度是O(n)的证明，虽然我们可以很明显地看到Manacher算法与普通方法相比，在扩出去检查这一行为上有明显的优化，但如何证明该算法的时间复杂度就是O(N)呢？关键之处在于估算扩出去检查这一行为发生的数量。原字符串在处理后的长度由n变为2n，从步骤3的主要逻辑来看，要么在计算第一个位置的回文半径时完全不需要扩出去检查，比如，步骤3中的3)介绍的情况一和情况二，都可以直接获得位置i的回文半径长度；要么每一次扩出去检查都会导致pR变量的更新，比如步骤3中的2)和3)介绍的情况三，扩出去检查时都让回文半径到达更右的位置，当然会使pR更新，然而pR最多是-1增加到2n(右边界)，并且从来不减小，所以扩出去检查的次数就是O(n)的级别，所以Manacher算法的时间复杂度是O(n)，具体参看如下的maxlength方法。 1234567891011121314151617181920212223242526 public static int maxLcpsLength(String str) &#123; if (str == null || str.length() == 0) &#123; return 0; &#125; char[] charArr = manacherString(str); int[] pArr = new int[charArr.length]; int index = -1; int pR = -1; int max = Integer.MIN_VALUE; for (int i = 0; i != charArr.length; i++) &#123; pArr[i] = pR &gt; i ? Math.min(pArr[2 * index - i], pR - i) : 1; while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) &#123; if (charArr[i + pArr[i]] == charArr[i - pArr[i]]) pArr[i]++; else &#123; break; &#125; &#125; if (i + pArr[i] &gt; pR) &#123; pR = i + pArr[i]; index = i; &#125; max = Math.max(max, pArr[i]); &#125; return max - 1;&#125; 进阶问题，在字符串后面的最后添加最少字符，使整个字符串是回文字符串其实就是查找在必须包含最后一个字符的情况下，最长的回文字串是什么。那么之前不是回文字串的部分逆序过来，就是应该添加的部分。比如”abcd123321”，在必须包含最后一个字符的情况下，最长的回文字串是”123321”，之前不是最长回文字串的部分是”abcd”，所以末尾应该添加的部分就是”dcba”，那么只要把Manacher算法稍作调整就可以。具体改成，从左到右计算回文半径时，关注回文半径最右即将到达的位置(pR),一旦发现已经到达最后(pR=charArr.length)，说明必须包含最后一个字符的最长回文半径已经找到，直接退出检查过程，返回该添加的字符串即可，具体参看如下代码： 123456789101112131415161718192021222324252627282930313233 public static String shortestEnd(String str) &#123; if (str == null || str.length() == 0) &#123; return null; &#125; char[] charArr = manacherString(str); int[] pArr = new int[charArr.length]; int index = -1; int pR = -1; int maxContainsEnd = -1; for (int i = 0; i != charArr.length; i++) &#123; pArr[i] = pR &gt; i ? Math.min(pArr[2 * index - i], pR - i) : 1; while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) &#123; if (charArr[i + pArr[i]] == charArr[i - pArr[i]]) pArr[i]++; else &#123; break; &#125; &#125; if (i + pArr[i] &gt; pR) &#123; pR = i + pArr[i]; index = i; &#125; if (pR == charArr.length) &#123; maxContainsEnd = pArr[i]; break; &#125; &#125; char[] res = new char[str.length() - maxContainsEnd + 1]; for (int i = 0; i &lt; res.length; i++) &#123; res[res.length - 1 - i] = charArr[i * 2 + 1]; &#125; return String.valueOf(res);&#125; 以上就是Manacher算法以及衍生问题的全过程。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和矩阵系列算法]]></title>
    <url>%2F2018%2F08%2F26%2F%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5%E7%B3%BB%E5%88%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1，转圈打印矩阵 题目：给定一个矩阵，请按照转圈打印的方式打印它。 例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 转圈打印结果：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。要求：时间复杂度O(1)。解答：矩阵分圈处理，在矩阵式利用左上角的坐标(tR,tC)和右下角的坐标(dR,dC)就可以表示一个子矩阵，比如，题目中的矩阵，当(tR,tC)=(0,0)、(dR,dC)=(3,3)时，表示的矩阵就是整个矩阵，那么这个字矩阵最外层的部分就是： 1 2 3 4 5 8 9 12 13 14 15 16这就是当(tR,tC)=(0,0)、(dR,dC)=(3,3)时的子矩阵。接下来令tR和tC加1，即(tR,tC)=(1,1),令dR和dC减1，即(dR,dC)=(2,2),此时表示的子矩阵如下： 6 7 10 11再转圈打印这个矩阵，tR和tC加1，dR和dC减1，如果发现左上角坐标跑到了右下角坐标的右方或下方，整个过程就停止。参看如下的代码，spiralOrderPrint方法，其中printEdge就是转圈打印一个子矩阵的外层。 12345678910111213141516171819202122232425262728293031323334353637383940public static void spiralOrderPrint(int[][] matrix) &#123; int tR = 0; int tC = 0; int dR = matrix.length - 1; int dC = matrix[0].length - 1; while (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123; printEdge(matrix, tR++, tC++, dR--, dC--); &#125;&#125;public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) &#123; if (tR == dR) &#123; for (int i = tC; i &lt;= dC; i++) &#123; System.out.print(m[tR][i] + &quot; &quot;); &#125; &#125; else if (tC == dC) &#123; for (int i = tR; i &lt;= dR; i++) &#123; System.out.print(m[i][tC] + &quot; &quot;); &#125; &#125; else &#123; int curC = tC; int curR = tR; while (curC != dC) &#123; System.out.print(m[tR][curC] + &quot; &quot;); curC++; &#125; while (curR != dR) &#123; System.out.print(m[curR][dC] + &quot; &quot;); curR++; &#125; while (curC != tC) &#123; System.out.print(m[dR][curC] + &quot; &quot;); curC--; &#125; while (curR != tR) &#123; System.out.print(m[curR][tC] + &quot; &quot;); curR--; &#125; &#125;&#125; 2，将正方形矩阵顺时针转动90度 题目：将一个nn矩阵顺时针转90度，例如 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 顺时针转90度后的矩阵 13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 要求：额外空间复杂度为O(1)。 这里仍然使用分圈打印的方式，在矩阵的左上角和右下角的坐标就可以表示一个矩阵，比如，题目中的矩阵，当(tR,tC)=(0,0)、(dR,dC)=(3,3)时，表示的子矩阵就是整个矩阵，那么这个子矩阵最外层的部分如下： 1 2 3 4 5 8 9 12 13 14 15 16 在这个外圈中，1，4，16，13为一组，然后让1占据4的位置，4占据16的位置，16占据13的位置，13占据1的位置，一组就调整完了。然后2，8，15，9，继续占据调整的过程，最后3，12 ，14 ，5为一组，继续占据调整的过程。然后(tC,tC)、(dR,dC)=(3,3)的子矩阵外层就调整完毕。接下来令tR和tC加1，即(tR,tC)=(1,1),令dR和dC减1，即(dR,dC)=(2,2),此时表示的矩阵如下 6 7 10 11 这个外层只有一组，就是6，7，10，11，占据调整之后即可，所以如果子矩阵的大小是mm，一共就有m-1组，分别进行占据调整即可。 请参考如下代码中的rotate方法。 static void rotate(int[][] matrix) &#123;1234567891011121314151617181920 int tR = 0; int tC = 0; int dR = matrix.length - 1; int dC = matrix[0].length - 1; while (tR &lt; dR) &#123; rotateEdge(matrix, tR++, tC++, dR--, dC--); &#125;&#125;public static void rotateEdge(int[][] m, int tR, int tC, int dR, int dC) &#123; int times = dC - tC; int tmp = 0; for (int i = 0; i != times; i++) &#123; tmp = m[tR][tC + i]; m[tR][tC + i] = m[dR - i][tC]; m[dR - i][tC] = m[dR][dC - i]; m[dR][dC - i] = m[tR + i][dC]; m[tR + i][dC] = tmp; &#125;&#125; 3，“之”字型打印矩阵 题目：给定一个矩阵，按照“之”字型打印矩阵，例如: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 “之”字型打印矩阵的结果为：1，2，5，9，6，3，4，7，10，13，14，11，8，12，15，16。 12345678910111213141516171819202122232425262728293031 public static void printMatrixZigZag(int[][] matrix) &#123; int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length - 1; int endC = matrix[0].length - 1; boolean fromUp = false; while (tR != endR + 1) &#123; printLevel(matrix, tR, tC, dR, dC, fromUp); tR = tC == endC ? tR + 1 : tR; tC = tC == endC ? tC : tC + 1; dC = dR == endR ? dC + 1 : dC; dR = dR == endR ? dR : dR + 1; fromUp = !fromUp; &#125; System.out.println();&#125;public static void printLevel(int[][] m, int tR, int tC, int dR, int dC, boolean f) &#123; if (f) &#123; while (tR != dR + 1) &#123; System.out.print(m[tR++][tC--] + &quot; &quot;); &#125; &#125; else &#123; while (dR != tR - 1) &#123; System.out.print(m[dR--][dC++] + &quot; &quot;); &#125; &#125;&#125; 4，找到无序数组中最小的k个数题目：给定一个无序的整型数组arr，找到其中最小的k个数。要求：数组长度为n，排序之后自然可以得到最小的k个数，此时时间复杂度与排序的时间复杂度相同，均为O(logn)。本体要求读者实现时间复杂度为O(nlogk)和O(n)的方法。O(nlogk)时间复杂度的方法：用堆结构解决，已知维护一个有k个元素的大根堆，这个堆代表目前选出的k个最小的数，在堆里的k个元素中堆顶的元素是最小的k个数里最大的那个。接下里遍历数组，遍历的过程中看当前数是否比堆定元素小，若是，就把堆顶的元素替换成当前的数，然后从堆定的位置调整整个堆，让替换操作后的最大元素继续处在堆定的位置；若不是，则不进行任何操作，继续遍历下一个数；在遍历完成后，堆中的k个数就是所有数组中最小的k个数。参看下面的getMinKNumsByHeap方法，代码中的heapinsert和heapfy方法分别为堆排序中的建堆和调整堆的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// O(N*logK) public static int[] getMinKNumsByHeap(int[] arr, int k) &#123; if (k &lt; 1 || k &gt; arr.length) &#123; return arr; &#125; int[] kHeap = new int[k]; for (int i = 0; i != k; i++) &#123; heapInsert(kHeap, arr[i], i); &#125; for (int i = k; i != arr.length; i++) &#123; if (arr[i] &lt; kHeap[0]) &#123; kHeap[0] = arr[i]; heapify(kHeap, 0, k); &#125; &#125; return kHeap; &#125; public static void heapInsert(int[] arr, int value, int index) &#123; arr[index] = value; while (index != 0) &#123; int parent = (index - 1) / 2; if (arr[parent] &lt; arr[index]) &#123; swap(arr, parent, index); index = parent; &#125; else &#123; break; &#125; &#125; &#125; public static void heapify(int[] arr, int index, int heapSize) &#123; int left = index * 2 + 1; int right = index * 2 + 2; int largest = index; while (left &lt; heapSize) &#123; if (arr[left] &gt; arr[index]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != index) &#123; swap(arr, largest, index); &#125; else &#123; break; &#125; index = largest; left = index * 2 + 1; right = index * 2 + 2; &#125; &#125; public static void swap(int[] arr, int index1, int index2) &#123; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125; O(n)的算法，会用到经典的bfprt算法，该算法于1973年由blum、floyd、pratt、rivest、tarjan联合发明，它解决了这样一个问题，在O(n)时间复杂度内,从无序的数组中找到第k小的数，显而易见的是，如果我们找到了第k小的数，那么想求arr中最小的k个数，就是再遍历一次数组的工作量而已，所以关键的问题就变成了如何理解并实现brprt算法。 bfprt算法是如何找到第k小的数？以下是算法的过程，假设bfprt算法的函数是int select(int[]arr,k)，该函数的功能为在arr中找到第k小的数，然后返回该数。 select(arr,k)的过程如下： 1),将arr中的n个元素划分成n/5组，每组5个元素，如果最后的组不够5个元素，那么最后的元素成为一组(n%5个元素)。 2),对每个数组进行插入排序，只针对每个组最多5个元素之间的组内排序，组与组之间并不排序。排序之后找到每个组的中位数，如果组的元素个数为偶数，这里规定找不到中位数。 3),步骤2中一共会找到n/5个中位数，让这些中位数组成一个新的数组，记为mArr。递归调用select(mArr,mArr.length/2)，意义是找到mArr这个数组中的中位数，即mArr中的第(mArr.length/2)小的数。 4),假设步骤3递归调用select(mArr,mArr.length/2)后，返回的数为x，根据这个x划分整个arr数组(partition过程)，划分的过程为：在arr中，比x小的数都在x的左边，比x大的数都在x的右边，x在中间。假划分完成后，x在arr中的位置记为i。 5)，如果i==k，说明x为整个数组中第k小的数，直接返回。 如果i&lt;k，说明x处在第k小的数的左边，应该在x的右边寻找第k小的数，所以递归调用select函数，在右半区寻找第k-i小的数。 如果i&gt;k，说明x处在第k小的数的右边，应该在x的左边寻找第k小的数，所以递归调用select函数，在左半区寻找第k-i小的数。 bfprt算法为什么能做到O(n)的时间复杂度呢？以下是bfprt时间复杂度的分析： 1，在上述过程，除了步骤3和步骤5要用递归函数外，其他的所有处理过程都可以在O(n)时间内完成。 2，步骤3中有递归函数的调用，且递归处理的数组大小为n/5(即T(n/5))。 3，步骤5也递归调用了select函数，那么递归处理的数组大小最大为多少呢？具体地说，我们关心的是由x划分出的左半区最大有多大和由x划分出去的右半区最大有多大。 数学证明了bfprt算法的时间复杂度是O(n)。 具体请参看如下代码中的getMinKnumsByBFPRT方法。static int[] getMinKNumsByBFPRT(int[] arr, int k) &#123;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 if (k &lt; 1 || k &gt; arr.length) &#123; return arr; &#125; int minKth = getMinKthByBFPRT(arr, k); int[] res = new int[k]; int index = 0; for (int i = 0; i != arr.length; i++) &#123; if (arr[i] &lt; minKth) &#123; res[index++] = arr[i]; &#125; &#125; for (; index != res.length; index++) &#123; res[index] = minKth; &#125; return res;&#125;public static int getMinKthByBFPRT(int[] arr, int K) &#123; int[] copyArr = copyArray(arr); return select(copyArr, 0, copyArr.length - 1, K - 1);&#125;public static int[] copyArray(int[] arr) &#123; int[] res = new int[arr.length]; for (int i = 0; i != res.length; i++) &#123; res[i] = arr[i]; &#125; return res;&#125;public static int select(int[] arr, int begin, int end, int i) &#123; if (begin == end) &#123; return arr[begin]; &#125; int pivot = medianOfMedians(arr, begin, end); int[] pivotRange = partition(arr, begin, end, pivot); if (i &gt;= pivotRange[0] &amp;&amp; i &lt;= pivotRange[1]) &#123; return arr[i]; &#125; else if (i &lt; pivotRange[0]) &#123; return select(arr, begin, pivotRange[0] - 1, i); &#125; else &#123; return select(arr, pivotRange[1] + 1, end, i); &#125;&#125;public static int medianOfMedians(int[] arr, int begin, int end) &#123; int num = end - begin + 1; int offset = num % 5 == 0 ? 0 : 1; int[] mArr = new int[num / 5 + offset]; for (int i = 0; i &lt; mArr.length; i++) &#123; int beginI = begin + i * 5; int endI = beginI + 4; mArr[i] = getMedian(arr, beginI, Math.min(end, endI)); &#125; return select(mArr, 0, mArr.length - 1, mArr.length / 2);&#125;public static int[] partition(int[] arr, int begin, int end, int pivotValue) &#123; int small = begin - 1; int cur = begin; int big = end + 1; while (cur != big) &#123; if (arr[cur] &lt; pivotValue) &#123; swap(arr, ++small, cur++); &#125; else if (arr[cur] &gt; pivotValue) &#123; swap(arr, cur, --big); &#125; else &#123; cur++; &#125; &#125; int[] range = new int[2]; range[0] = small + 1; range[1] = big - 1; return range;&#125;public static int getMedian(int[] arr, int begin, int end) &#123; insertionSort(arr, begin, end); int sum = end + begin; int mid = (sum / 2) + (sum % 2); return arr[mid];&#125;public static void insertionSort(int[] arr, int begin, int end) &#123; for (int i = begin + 1; i != end + 1; i++) &#123; for (int j = i; j != begin; j--) &#123; if (arr[j - 1] &gt; arr[j]) &#123; swap(arr, j - 1, j); &#125; else &#123; break; &#125; &#125; &#125;&#125;public static void swap(int[] arr, int index1, int index2) &#123; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp;&#125;public static void printArray(int[] arr) &#123; for (int i = 0; i != arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println();&#125; 5，需要排序的最短子数组长度题目：一个无序数组arr，求出需要排序的最短子数组长度。例如：arr={1,5,3,4,2,6},返回4，因为只有[5,3,4,2]需要排序。解答：可以做到时间复杂度O(n)，额外空间复杂度O(1)。初始化变量noMinIndex=-1，从右向左遍历，遍历的过程中记录右侧出现过的数的最小值，记为min。假设当前数为arr[i]，如果arr[i]&gt;min,说明如果要整体有序，min值必然会挪到arr[i]的左边。用noMinIndex记录最左边出现这种情况的位置。如果遍历完成后，noMinIndex依然等于-1，说明从右到左始终不升序，原本数组就有序，直接返回0，即完全不需要排序。接下来从左往右遍历，遍历的过程中记录左侧出现过的数的最大值，记为max。假设当前数为arr[i]，如果arr[i]&lt;max,说明如果有序，max值必然会挪到arr[i]的右边。用变量noMaxIndex记录最右边出现这种情况的位置。遍历完成后，arr[noMinIndex…noMaxIndex]就是需要排序的那部分，返回它的长度即可。具体过程参看下面的getMinLength方法。 123456789101112131415161718192021222324252627 public static int getMinLength(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; int min = arr[arr.length - 1]; int noMinIndex = -1; for (int i = arr.length - 2; i != -1; i--) &#123; if (arr[i] &gt; min) &#123; noMinIndex = i; &#125; else &#123; min = Math.min(min, arr[i]); &#125; &#125; if (noMinIndex == -1) &#123; return 0; &#125; int max = arr[0]; int noMaxIndex = -1; for (int i = 1; i != arr.length; i++) &#123; if (arr[i] &lt; max) &#123; noMaxIndex = i; &#125; else &#123; max = Math.max(max, arr[i]); &#125; &#125; return noMaxIndex - noMinIndex + 1;&#125; 6，在数组中找到出现次数大于n/k的数题目：给定一个数组，打印其出现次数大于一半的数，如果没有这样的数，打印提示信息。进阶：给定一个数组arr，再给定一个整数k，打印所有出现次数大于n/k的数，如果没有这样的数，打印提示信息。要求：原问题要求的时间复杂度为O(n),额外空间复杂度为O(1)，进阶问题要求时间复杂度为O(n*k)，额外空间复杂度为O(k)。解答：无论是原问题还是进阶问题，都可以用哈希表记录每个数及其出现的次数，但是额外空间复杂度为O(n)，不符合题目要求，所以本书不再详细讲这种方法。本书提供方法的核心思路是，一次在数组中删除k个不同的数，不停地删除，直到剩下数的种类不足k就停止删除，那么，如果一个数在数组中出现的次数大于n/k，则这个数最后一定会被生下来。原问题，出现次数大于一半的数最多只会有一个，还可能不存在这样的数。具体的过程为，一次在数组中删除两个不的数，不停地删除，直到剩下的数只有一种，如果一个数出现次数大于一半，这个数最后一定会剩下来。如下代码中的printHalfMajor方法。 12345678910111213141516171819202122232425 public static void printHalfMajor(int[] arr) &#123; int cand = 0; int times = 0; for (int i = 0; i != arr.length; i++) &#123; if (times == 0) &#123; cand = arr[i]; times = 1; &#125; else if (arr[i] == cand) &#123; times++; &#125; else &#123; times--; &#125; &#125; times = 0; for (int i = 0; i != arr.length; i++) &#123; if (arr[i] == cand) &#123; times++; &#125; &#125; if (times &gt; arr.length / 2) &#123; System.out.println(cand); &#125; else &#123; System.out.println(&quot;no such number.&quot;); &#125;&#125; 第一个for循环就是一次在数组中删除掉两个不同的数的代码实现。把cand变量叫候选，times叫作次数，读者先不用纠结这两个变量是什么意义，我们看在第一个for循环中发生了什么。 times=0时，表示当前没有候选，则把当前数arr[i]设为候选，同时把times设置成1. times!=0时，表示当前有候选，如果当前的数arr[i]与候选一样，同时把times加1，如果当前的数att[i]与候选不一样，就把times减1，减到0则表示又没有候选了。进阶问题也是类似的思想，一次在数组中删除k个不同的数，不停地删除，直到剩下的数的种类不足k，那么，如果某些数在数组中出现次数大于n/k，则这些数最后一定会剩下来。具体参看如下的printKMajor方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 public static void printKMajor(int[] arr, int K) &#123; if (K &lt; 2) &#123; System.out.println(&quot;the value of K is invalid.&quot;); return; &#125; HashMap&lt;Integer, Integer&gt; cands = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i != arr.length; i++) &#123; if (cands.containsKey(arr[i])) &#123; cands.put(arr[i], cands.get(arr[i]) + 1); &#125; else &#123; if (cands.size() == K - 1) &#123; allCandsMinusOne(cands); &#125; else &#123; cands.put(arr[i], 1); &#125; &#125; &#125; HashMap&lt;Integer, Integer&gt; reals = getReals(arr, cands); boolean hasPrint = false; for (Entry&lt;Integer, Integer&gt; set : cands.entrySet()) &#123; Integer key = set.getKey(); if (reals.get(key) &gt; arr.length / K) &#123; hasPrint = true; System.out.print(key + &quot; &quot;); &#125; &#125; System.out.println(hasPrint ? &quot;&quot; : &quot;no such number.&quot;);&#125;public static void allCandsMinusOne(HashMap&lt;Integer, Integer&gt; map) &#123; List&lt;Integer&gt; removeList = new LinkedList&lt;Integer&gt;(); for (Entry&lt;Integer, Integer&gt; set : map.entrySet()) &#123; Integer key = set.getKey(); Integer value = set.getValue(); if (value == 1) &#123; removeList.add(key); &#125; map.put(key, value - 1); &#125; for (Integer removeKey : removeList) &#123; map.remove(removeKey); &#125;&#125;public static HashMap&lt;Integer, Integer&gt; getReals(int[] arr, HashMap&lt;Integer, Integer&gt; cands) &#123; HashMap&lt;Integer, Integer&gt; reals = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i != arr.length; i++) &#123; int curNum = arr[i]; if (cands.containsKey(curNum)) &#123; if (reals.containsKey(curNum)) &#123; reals.put(curNum, reals.get(curNum) + 1); &#125; else &#123; reals.put(curNum, 1); &#125; &#125; &#125; return reals;&#125; 7，在行列都排好序的矩阵中找数 题目：给定一个m*n的整型矩阵matrix和一个整数k，matrix的每一行和每一列都是排好序的。实现函数，判断k是否在matrix中。 例如： 0 1 2 3 2 3 4 7 4 4 4 7 5 7 7 9 如果k为7，返回true；如果k为6，返回false。 要求：时间复杂度为O(n+m)，额外空间复杂度为O(1)。 思路:用以下步骤解决 1),从矩阵最右上角的数开始寻找(row=0,col=m-1)。 2),比较当前数matrix[row][col]与k的关系： 如果与k相等，说明已找到，直接返回true。 如果比k大，因为矩阵每一列都已拍好，所以在当前数所在的列中，处于当前数下方的数都会比k小，则没必要继续在第col列上寻找，令col=col-1，重复步骤2。 如果比k小，因为矩阵每一行都已排好序，所以在当前数所在的行中，处于当前数左方的数都会比k小，则没有必要继续在第row行上寻找，令row=row-1，重复步骤2. 3),如果找到越界都没有发现与k相等的数，则返回false。 或者，也可以用以下步骤。 1),从矩阵最左下角的数开始寻找(row=n-1,col=0)。 2),比较当前数matrix[row][col]与k的关系： 如果比与k相等，说明找到了，返回true。 如果比k大，因为矩阵每一行都已经排好序，所以在当前数所在的行中，当前数右方的数都会比k大，则没有必要继续在第row行上寻找，令row=row-1，重复步骤2. 如果比k小，因为矩阵每一列都已排序，所以在当前数所在的列中，处于数上方的数都会比k小，则没有必要继续在第col列上寻找，令col=col+1，重复步骤。 3),如果越界还没有发现与k相等的数，则返回false。 具体请参看如下代码中的isContains方法： 1234567891011121314 public static boolean isContains(int[][] matrix, int K) &#123; int row = 0; int col = matrix[0].length - 1; while (row &lt; matrix.length &amp;&amp; col &gt; -1) &#123; if (matrix[row][col] == K) &#123; return true; &#125; else if (matrix[row][col] &gt; K) &#123; col--; &#125; else &#123; row++; &#125; &#125; return false;&#125; 8， 最长的可整合子数组的长度 题目：给出最长可整合子数组长度定义，一个数组在排序后，每相邻两个数差值的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2],符合每相邻两个数差的绝对值都为1，所以这个数组为可整合数组。 给定一个整型数组arr，请返回其中最大可整合子数组的长度。例如，[5,5,3,2,6,3]的最大可整合子数组为[5,3,2,6,4]。 解答：时间复杂度高但简单的解法，对arr中的每一个子数组arri…j，都验证一下是否符合可整合数组的定义，也就是把arr[i..j]排序一下，看是否依次递增且每次递增1。然后在所有符合可整合数组定义的子数组中，记录最大的那个长度，返回即可。需要注意的是，在考察每一个arr[i…j]是否符合数组定义的时候，都得把arr[i…j]单独复制成一个新的数组，然后把这个新的数组排序、验证，而不能直接改变arr中元素的顺序。所以大体过程如下： 1)，依次考查每一个子数组arr[i…j]，一共有n的平方。 2),对每一个子数组arr[i…j]，复制成一个新的数组，记为newArr，把newArr排序，然后验证是否可整合数组的定义，这一步代价为O(nlogn)。 3),步骤3中符合条件的、最大的那个子数组的长度就是结果。 具体参看如下代码中的getLIL1方法，时间复杂度为O(nn) * O(nlogn)–&gt;O（nn*n * logn）。 代码如下： 12345678910111213141516171819202122232425public static int getLIL1(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; int len = 0; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i; j &lt; arr.length; j++) &#123; if (isIntegrated(arr, i, j)) &#123; len = Math.max(len, j - i + 1); &#125; &#125; &#125; return len;&#125;public static boolean isIntegrated(int[] arr, int left, int right) &#123; int[] newArr = Arrays.copyOfRange(arr, left, right + 1); // O(N) Arrays.sort(newArr); // O(N*logN) for (int i = 1; i &lt; newArr.length; i++) &#123; if (newArr[i - 1] != newArr[i] - 1) &#123; return false; &#125; &#125; return true;&#125; 这是时间复杂度非常高的方法。更高效的方法，有没有更高效的判断可整合数组的方法呢？也就是有没有更高效的方法来加速验证呢？判断一个数组是否是可整合数组还可以用以下方法来判断，一个数组中如果没有重复元素，并且如果最大值减去最小值，再加1的结果等于元素个数(max-min+1==元素个数),那么这个数组就是可整合数组。比如[3,2,5,6,4]，max-min+1=6-2+1=元素个数，所以这个数组是可整合数组。这样，验证一个数组是否是可整合数组的时间复杂度可以从O(nlogn)加速至O(1)，整个过程的时间复杂度就可加速到O(n*n)。具体参看如下代码中的getLIL2方法。 1234567891011121314151617181920212223242526 public static int getLIL2(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; int len = 0; int max = 0; int min = 0; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; max = Integer.MIN_VALUE; min = Integer.MAX_VALUE; for (int j = i; j &lt; arr.length; j++) &#123; if (set.contains(arr[j])) &#123; break; &#125; set.add(arr[j]); max = Math.max(max, arr[j]); min = Math.min(min, arr[j]); if (max - min == j - i) &#123; len = Math.max(len, j - i + 1); &#125; &#125; set.clear(); &#125; return len;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组和矩阵问题算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1，不用额外变量交换两个整数的值 题目：如何不用任何额外变量交换两个整数的值。 解答：给定a、b、c，以下三行代码就可以交换a和b的值 123a = a ^ b;b = a ^ b;a = a ^ b; 如何理解呢？理解异或运算符的特点：一个数异或另一个数两次得到的还是这个数。 2，不用任何比较判断找出两个数中较大的数 题目:给定两个32位的整数a和b，返回a和b中较大的数。 要求：不用任何比较。 解答：方法一：得到a-b的值得符号，就可以知道是返回a还是返回b。具体请参看如下代码： 1234567891011121314public static int flip(int n) &#123; return n ^ 1;&#125;public static int sign(int n) &#123; return flip((n &gt;&gt; 31) &amp; 1);&#125;public static int getMax1(int a, int b) &#123; int c = a - b; int scA = sign(c); int scB = flip(scA); return a * scA + b * scB;&#125; 方法二代码如下： 1234567891011 public static int getMax2(int a, int b) &#123; int c = a - b; int sa = sign(a); int sb = sign(b); int sc = sign(c); int difSab = sa ^ sb; int sameSab = flip(difSab); int returnA = difSab * sa + sameSab * sc; int returnB = flip(returnA); return a * returnA + b * returnB;&#125; 方法一是有局限性的，因为如果a和b的值溢出，返回结果会不正确。方法二解决了溢出的问题。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据和空间限制]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1，布隆过滤器及其应用 此题在另一篇博客已经有介绍。 2，只用2GB内存在20亿个整数中找到出现次数最多的数 题目：有一个包含20亿个全是32位整型的大文件，在其中找到出现次数最多的数。 要求：内存限制为2GB。 思路：要找出出现次数最多的数，通常的做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某一个整数，value是这个数出现的次数。就本题来说，一共有20亿个数，哪怕只是一个数出现了20亿次，用32位的整数也可以表示其出现的次数而不会产生溢出，所以哈希表的key需要占用4B，value也是4B。那么哈希表的一条记录(key,value)需要占用8B，当哈希表记录数为2亿个时，需要至少1.6GB内存。但如果20亿个数中不同的数超过2亿种，最极端的情况是20亿个数都不同，那么在哈希表中可能需 要产生20亿条记录，这样内存会不够用，所以一次性用哈希表统计20亿个数的方法是有很大风险的。解决方法是把20亿个数用哈希函数分成16个小文件，根据哈希函数的性质，同一种数不可能被哈希到不同的小文件上，同时每个小文件中不同的数一定不会大于2亿种，假设哈希函数足够好。然后对每一个小文件用哈希表来统计其中每种数出现的次数，这样我们就得到了16个小文件中各自出现次数最多的数，还有各自的统计次数。接下来只要选出16个小文件各自的第一名中谁出现的次数最多即可。把一个大的集合通过哈希函数分配到多台机器中，或者分配到多个文件里，这种技巧是处理大数据面试题时常有的技巧之一。但是到底分配多少台机器、分配多少文件，在解题时一定要确定下来。可能是在与面试官沟通的过程中由面试官指定，也可能是根据具体的限制来确定，比如本题确定分成16个文件，就是根据内存限制2GB的条件来确定的。3，40亿个非负整数中找到没出现的数题目：32位无符号数的范围是0~4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有没出现过的数？进阶问题：内幕才能限制为10MB,但是只用找到一个没出现过的数即可。思路：原问题，若用哈希表来保存出现过的数，那么如果40亿个数都不同，则哈希表的记录数为40亿条，存一个32位整型需要4B，所以最差情况下需要40亿 * 4B=160亿字节，大约需要16GB的空间，这是不符合要求的。4，找到100亿个URL中重复的URL以及搜索词汇的topK问题题目：有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出所有重复的URL。补充题目：某搜索公司一天的用户搜索词汇是海量(百亿数据量)的，请设计一种求出每天最热top100词汇的可行方法。思路： 5，一致性哈希算法的基本原理题目：工程师经常使用服务器集群来设计和实现数据缓存，以下是常见的策略： 1)，无论是添加、查询还是删除数据，都是先将数据的id通过哈希函数转换成一个哈希值，记为key。 2),如果目前机器有n台，则计算key%n的值，这个值就是该数据所属的机器编号，无论是添加、删除还是查询操作，都只在这台机器上进行。 请分析这种策略可能带来的问题，并提出改进的方案。 解答：题目描述的缓存策略的潜在问题是如果增加或删除机器时(n变化)代价会很高，所有的数据都不得不根据id重新计算一遍哈希值，并将哈希值对新的机器数进行取模操作，然后进行大规模的数据迁移。 为了解决这些问题，下面介绍一下一致性哈希算法，这是一种很好的数据缓存设计方案。我们假设数据的id通过哈希函数转换成的哈希值范围是2的32次方，这样我们可以将这些数头尾相连，想象成一个闭合的环，那么一个数据id在计算出哈希值之后认为对应到环中的一个位置上。 接下来想象有三台机器也处在这样一个环中，这三台机器在环中的位置根据机器id计算出的哈希值来决定。那么一条数据如何确定属于哪台机器呢？首先把该数据的id用哈希函数算出哈希值，并映射到环中的相应位置，然后顺时针寻找离这个位置最近的机器，那台机器就是该数据的归属。 机器负载不均时的处理。如果机器较少，很有可能造成机器在整个环上的分布不均匀，从而导致机器之间的负载不均衡。 为了解决问题，一致性哈希算法引入了虚拟节点机制，即对每一台机器通过不同的哈希函数计算出多个哈希值，对多个位置都放置一个服务节点，称为虚拟节点。具体做法可以在机器ip或主机名的后面增加编号或端口来实现。 基于一致性哈希的原理有多重具体的实现，包括Chord算法、KAF算法。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>空间限制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串问题]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1,判断两个字符串是否互为变形词 题目：给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样，那么str1和str2互为变形词。请实现判断两个字符串是否为变形词的函数。 举例：str1=”123”，str2=”231”，返回true；str1=”123”，str2=”2331”，返回false。 思路：如果str1和str2长度不同，那么直接返回false。如果长度相同，假设出现字符的编码值在0-255之间，那么申请一个长度为255的整型数组map，map[a]=b代表字符编码为a的字符出现了b次，初始时map[0…255]的值都是0。然后遍历字符串str1，统计每种字符出现的数量，比如遍历到字符’a’，其编码为97，则令map[97]++。这样map就成了str1中每种字符的词频统计表。然后遍历字符串str2，每遍历到一个字符都在map中把词频减下来，比如遍历到字符’a’，其编码值为97，则令map[97]–，如果减少之后的值小于0，直接返回false，如果遍历完str2，map中的值也没出现负值，则返回true。 具体参看如下代码中的isDeformation方法 1234567891011121314151617public static boolean isDeformation(String str1, String str2) &#123; if (str1 == null || str2 == null || str1.length() != str2.length()) &#123; return false; &#125; char[] chas1 = str1.toCharArray(); char[] chas2 = str2.toCharArray(); int[] map = new int[256]; for (int i = 0; i &lt; chas1.length; i++) &#123; map[chas1[i]]++; &#125; for (int i = 0; i &lt; chas2.length; i++) &#123; if (map[chas2[i]]-- == 0) &#123; return false; &#125; &#125; return true;&#125; 如果字符的类型很多，可以用哈希表代替长度为255的整型数组，但整体过程不变。如果字符的种类为M，str1和str2的长度为N，那么该方法的时间复杂度为O(N)，额外空间复杂度为O(M)。 2,字符串中数字字串的求和 题目：给定一个字符串str，求其中的全部数字串所代表的数字之和。 要求： 1，忽略小数点字符，例如”A1.3”，其中包含两个数字1和3。 2，如果紧贴数字字串的左侧出现字符”-“，当连续出现的数量为奇数时，则数字为负，连续出现的数量为偶数时，则数字为正。例如，”A-1BC–12”，其中包含数字为-1和12。 举例：str=”A1CD2E33”，返回36。str=”A-1B–2C–D6E”，返回7。 思路：本题能做到O(n)的时间复杂度，额外空间复杂度为O(1)，且有多种方法，本书提供一种供参考。解法的关键是如何在从左到右遍历str时，准确收集每个数字并累加起来。具体过程如下： 1),生成三个变量。整型变量res，表示目前的累加和；整型变量num，表示当前收集到的数字；布尔型变量posi，表示如果把num累加到res里，num是正还是负。初始时，res=0，num=0，posi=true。 2),从左到右遍历str，假设遍历到字符cha，根据具体的cha有不同的处理。 3), 请参看下面的numSum方法。 123456789101112131415161718192021222324252627282930public static int numSum(String str) &#123; if (str == null) &#123; return 0; &#125; char[] charArr = str.toCharArray(); int res = 0; int num = 0; boolean posi = true; int cur = 0; for (int i = 0; i &lt; charArr.length; i++) &#123; cur = charArr[i] - &apos;0&apos;; if (cur &lt; 0 || cur &gt; 9) &#123; res += num; num = 0; if (charArr[i] == &apos;-&apos;) &#123; if (i - 1 &gt; -1 &amp;&amp; charArr[i - 1] == &apos;-&apos;) &#123; posi = !posi; &#125; else &#123; posi = false; &#125; &#125; else &#123; posi = true; &#125; &#125; else &#123; num = num * 10 + (posi ? cur : -cur); &#125; &#125; res += num; return res;&#125; 3，去掉字符串中连续出现k个0的字串 题目：给定一个字符串和一个整数k，如果str中正好有连续的k个’0’出现时，把k个连续的’0’字符去除，返回处理后的字符串。 举例，str=”A00B”,K=2,返回”A00B”。str=”A0000B000”,K=3,返回”A0000B”。 思路： 方法如下： 12345678910111213141516171819202122232425public static String removeKZeros(String str, int k) &#123; if (str == null || k &lt; 1) &#123; return str; &#125; char[] chas = str.toCharArray(); int count = 0, start = -1; for (int i = 0; i != chas.length; i++) &#123; if (chas[i] == &apos;0&apos;) &#123; count++; start = start == -1 ? i : start; &#125; else &#123; if (count == k) &#123; while (count-- != 0) chas[start++] = 0; &#125; count = 0; start = -1; &#125; &#125; if (count == k) &#123; while (count-- != 0) chas[start++] = 0; &#125; return String.valueOf(chas);&#125; 4，判断两个字符串是否互为旋转词 题目：一个字符串str，把字符串str前面任意的部分挪到后面形成的字符串叫作str的旋转词。比如str=”12345”，str的旋转词有”12345”、”23451”、”34512”、”45123”、”51234”。给定两个字符串a和b，请判断a和b是否互为旋转词。 举例：a=”cdab”,b=”abcd”,返回true；a=”1ab2”，b=”ab12”,返回false； a=”2ab1”，b=”ab12”,返回true。 要求：如果a和b长度不一样，那么a和b必然不互为旋转词，可以直接返回false。当a和b长度一样，都为n时，要求的解法时间复杂度为O(n)。 思路：a和吧长度不一样，不可能互为旋转词。如果长度一样，先生成一个大字符串b2，b2是两个字符串b拼在一起的结果，即String b2 = b + b。然后看b2中是否包含字符串a，如果包含，说明字符串a和b互为旋转词，否则说明两个字符串不互为旋转词。这是为什么呢？举例说明，这对于所有的情况都是对的，所以这种方法是有效的。请参看下面的isRotation方法。 1234567public static boolean isRotation(String a, String b) &#123; if (a == null || b == null || a.length() != b.length()) &#123; return false; &#125; String b2 = b + b; return getIndexOf(b2, a) != -1;&#125; KMP算法 12345678910111213141516171819202122// KMP Algorithm public static int getIndexOf(String s, String m) &#123; if (s.length() &lt; m.length()) &#123; return -1; &#125; char[] ss = s.toCharArray(); char[] ms = m.toCharArray(); int si = 0; int mi = 0; int[] next = getNextArray(ms); while (si &lt; ss.length &amp;&amp; mi &lt; ms.length) &#123; if (ss[si] == ms[mi]) &#123; si++; mi++; &#125; else if (next[mi] == -1) &#123; si++; &#125; else &#123; mi = next[mi]; &#125; &#125; return mi == ms.length ? si - mi : -1; &#125; 以上是主方法，isRotation方法中getIndexOf方法的功能是如果b2中包含a，则返回a在b2中的开始位置，如果不包含a，则返回-1，即getIndexOf是解决匹配的问题的函数，如果想让整个过程在O(n)时间复杂度内完成，那么字符串匹配问题也需要在O(n)时间复杂度内完成。这正是KPM算法做的事情，getIndexOf函数就是KMP算法的过程和实现。在本书KMP算法中有讲解。 5，将整数字符串转成整数值 题目：给定一个字符串str，如果str符合日常书写的整型形式，并且属于32位整数的范围，返回str所代表的整数值，否则返回0。 举例:str=”123”,返回123。str=”023”,因为023不符合平常书写习惯，所以返回0。str=”A13”，返回0；str=”2147483647”，返回2147483647。str=”2147483648”，因为溢出了，返回0。str=”-123”，返回-123。 本书提供一种解法如下： 1),若str不以”-“开头，也不以数字字符开头，例如，str==”A12”，返回false。 2),若str以”-“开头，但是str长度为1，即str=”-“，返回false。若str长度大于1，但是”-“的后面紧跟着”0”，例如，str=”-0”或”-012”，返回false。 3),若str以”0”开头，但是str的长度大于1，例如，str=”023”，返回false。 4),如果经过以上三个步骤都没有返回false，接下来检查str[1..n-1]是否都是数字字符，如果有一个不是数字字符，返回false。如果都是数字字符，说明符合日常书写，返回true。 具体参考下面isValid方法: 1234567891011121314151617public static boolean isValid(char[] chas) &#123; if (chas[0] != &apos;-&apos; &amp;&amp; (chas[0] &lt; &apos;0&apos; || chas[0] &gt; &apos;9&apos;)) &#123; return false; &#125; if (chas[0] == &apos;-&apos; &amp;&amp; (chas.length == 1 || chas[1] == &apos;0&apos;)) &#123; return false; &#125; if (chas[0] == &apos;0&apos; &amp;&amp; chas.length &gt; 1) &#123; return false; &#125; for (int i = 1; i &lt; chas.length; i++) &#123; if (chas[i] &lt; &apos;0&apos; || chas[i] &gt; &apos;9&apos;) &#123; return false; &#125; &#125; return true;&#125; 如果str不符合书写形式，返回0即可，若符合，则用如下方法进行转换过程。 12345678910111213141516171819202122232425public static int convert(String str) &#123; if (str == null || str.equals(&quot;&quot;)) &#123; return 0; // can not convert &#125; char[] chas = str.toCharArray(); if (!isValid(chas)) &#123; return 0; // can not convert &#125; boolean posi = chas[0] == &apos;-&apos; ? false : true; int minq = Integer.MIN_VALUE / 10; int minr = Integer.MIN_VALUE % 10; int res = 0; int cur = 0; for (int i = posi ? 0 : 1; i &lt; chas.length; i++) &#123; cur = &apos;0&apos; - chas[i]; if ((res &lt; minq) || (res == minq &amp;&amp; cur &lt; minr)) &#123; return 0; // can not convert &#125; res = res * 10 + cur; &#125; if (posi &amp;&amp; res == Integer.MIN_VALUE) &#123; return 0; // can not convert &#125; return posi ? -res : res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归和动态规划]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[1，斐波那契数列问题的递归和动态规划 补充题目1： 给定整数n，代表台阶数，1次可以跨2个或者1个台阶，返回有多少种走法。 举例：n=3，可以三次都跨一个台阶；也可以先跨2个台阶，再跨一个台阶；还可以先跨1一个台阶，再跨两个台阶。所以有三种方法。 补充题目2：假设母牛每年生1头小母牛，并且永远不会死。第一年有1只成熟的母牛，从第二年开始，母牛开始生小牛。每只小母牛3年之后成熟又可以生小母牛。给定整数n，求出n年后的数量。 举例：n=6，第一年1头母牛记为a；第二年a生了新的小母牛，记为b，总数为2；第三年a生了新的小母牛，记为c，总牛数为3；第4年a生了新的小母牛，记为d，总数为4。第五年b成熟了，a和b分别生了新的小母牛，总数为6；第6年c也成熟了，a、b和c分别生了新的小母牛，总数为9，返回9。 要求：时间复杂度O(logn)。 原问题的解答： 很容易写出暴力递归的解法,时间复杂度为O(2的n次方)。 代码如下：123456789public static int f1(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; return f1(n - 1) + f1(n - 2);&#125; O(n)复杂度的方法： 1234567891011121314151617public static int f2(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; int res = 1; int pre = 1; int tmp = 0; for (int i = 3; i &lt;= n; i++) &#123; tmp = res; res = res + pre; pre = tmp; &#125; return res;&#125; 这没有用递归，斐波那契数列可以根据前两项求出后一项的值。 方法三：O(logn)时间复杂度的方法。 分析：用矩阵乘法的方式可以将时间复杂度降为O(logn)。f(n) = f(n-1) + f(n-2)，是一个二阶递推数列，一定可以用矩阵乘法的形式表示，且状态矩阵为2*2的矩阵(这个太难，暂时理解不了)。 补充问题1：台阶只有1个，走法只有一种，有两个方法2种，如果有n级，最后跳上第n级的情况，要么是从n-2级台阶直接跨2级台阶，要么是n-1级跨1级台阶，所以台阶有n级的方法数，为跨到n-2级台阶的方法数加上跨到n-1级台阶的方法数，即s(n) = s(n-1) + s(n-2)，初始项s(1) = 1,s(2) = 2，所以类似于斐波那契数列，但是不同的是初始项不同，可以很轻易地写出2的n次方与O(n)的方法，请看下面的s1方法和s2方法。 12345678910public static int s1(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return n; &#125; return s1(n - 1) + s1(n - 2); &#125; 1234567891011121314151617public static int s2(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return n; &#125; int res = 2; int pre = 1; int tmp = 0; for (int i = 3; i &lt;= n; i++) &#123; tmp = res; res = res + pre; pre = tmp; &#125; return res;&#125; 以上是2的n次方和O(n)复杂度的方法。 下面讲解O(logn)复杂度的方法，也是求状态矩阵，用矩阵乘法。 补充问题2：所有的牛都不会死，c(n) = c(n-1) + c(n-3)。与斐波那契数列类似，不过是c(n)项依赖于c(n-1)和c(n-3)项的值，而斐波那契数列依赖于f(n-1)和f(n-2)项的值。 c1和c2方法分别是2的n次方和O(n)时间复杂度的方法。 123456789public static int c1(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2 || n == 3) &#123; return n; &#125; return c1(n - 1) + c1(n - 3);&#125; 123456789101112131415161718192021public static int c2(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2 || n == 3) &#123; return n; &#125; int res = 3; int pre = 2; int prepre = 1; int tmp1 = 0; int tmp2 = 0; for (int i = 4; i &lt;= n; i++) &#123; tmp1 = res; tmp2 = pre; res = res + prepre; pre = tmp1; prepre = tmp2; &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树系列问题]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1，分别用递归和非递归方式实现二叉树的遍历 题目：要求用非递归和递归方式分别按照先序、中序、后序遍历二叉树；约定先序遍历顺序为：根、左、右，中序：左、中、右，后序：左、右、中。 递归方式较为简单，代码如下： 先序： 12345678public static void preOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; System.out.print(head.value + &quot; &quot;); preOrderRecur(head.left); preOrderRecur(head.right);&#125; 中序： 12345678public static void inOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; inOrderRecur(head.left); System.out.print(head.value + &quot; &quot;); inOrderRecur(head.right);&#125; 后序： 12345678public static void posOrderRecur(Node head) &#123; if (head == null) &#123; return; &#125; posOrderRecur(head.left); posOrderRecur(head.right); System.out.print(head.value + &quot; &quot;);&#125; 注意：这就是打印的时机不一样，形成了三种遍历方式。 用递归方式解决的问题都能用非递归来解决。这是因为递归函数无非就是利用函数栈来保存信息，如果自己申请的数据结构来代替函数栈，也可以实现相同的功能。 用非递归方式实现先序遍历具体规则如下： 1),申请一个新的栈，记为stack。然后将头节点head压入stack。 2),从stack中弹出栈顶结点，记为cur，然后打印cur的值，再将节点cur的右孩子(不为空的话)先压入stack中，最后将cur的左孩子(不为空的话)压入stack中。 3),不断重复步骤2，直到stack为空，全部过程为结束。 123456789101112131415161718public static void preOrderUnRecur(Node head) &#123; System.out.print(&quot;pre-order: &quot;); if (head != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.add(head); while (!stack.isEmpty()) &#123; head = stack.pop(); System.out.print(head.value + &quot; &quot;); if (head.right != null) &#123; stack.push(head.right); &#125; if (head.left != null) &#123; stack.push(head.left); &#125; &#125; &#125; System.out.println();&#125; 以上是非递归实现先序的代码。 用非递归方式实现中序遍历的规则： 1),申请新的栈，记为stack，初始时，令变量cur=head。 2),先把cur节点压入栈中，对以cur为头的整颗子树来说，依次把左边界压入栈中，即不停地令cur=cur.left，然后重复步骤2。 3),不断重复步骤2，直到cur为空，此时从stack中弹出一个节点，记为node，打印node的值，并且让cur=node.right，然后继续重复步骤2. 4),当stack为空且cur为空时，整个过程停止 1234567891011121314151617public static void inOrderUnRecur(Node head) &#123; System.out.print(&quot;in-order: &quot;); if (head != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (!stack.isEmpty() || head != null) &#123; if (head != null) &#123; stack.push(head); head = head.left; &#125; else &#123; head = stack.pop(); System.out.print(head.value + &quot; &quot;); head = head.right; &#125; &#125; &#125; System.out.println();&#125; 以非递归方式实现后序遍历的规则： 代码： 12345678910111213141516171819202122public static void posOrderUnRecur1(Node head) &#123; System.out.print(&quot;pos-order: &quot;); if (head != null) &#123; Stack&lt;Node&gt; s1 = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; s2 = new Stack&lt;Node&gt;(); s1.push(head); while (!s1.isEmpty()) &#123; head = s1.pop(); s2.push(head); if (head.left != null) &#123; s1.push(head.left); &#125; if (head.right != null) &#123; s1.push(head.right); &#125; &#125; while (!s2.isEmpty()) &#123; System.out.print(s2.pop().value + &quot; &quot;); &#125; &#125; System.out.println();&#125; 方法二非递归实现后序遍历，只使用一个栈。 1234567891011121314151617181920public static void posOrderUnRecur2(Node h) &#123; System.out.print(&quot;pos-order: &quot;); if (h != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.push(h); Node c = null; while (!stack.isEmpty()) &#123; c = stack.peek(); if (c.left != null &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123; stack.push(c.left); &#125; else if (c.right != null &amp;&amp; h != c.right) &#123; stack.push(c.right); &#125; else &#123; System.out.print(stack.pop().value + &quot; &quot;); h = c; &#125; &#125; &#125; System.out.println();&#125; 2，打印二叉树的边界节点 题目：给定一棵二叉树的头节点，按照如下两种标准分别实现二叉树边界节点的逆时针打印。 标准一： 1，头节点为边界节点。 2，叶节点为边界节点。 3，如果节点在其所在的层中是最左或最右的，那么也是边界节点。 标准二： 1，头节点为边界节点 2，叶节点为边界节点 3，树左边界延伸下去的路径为边界节点 4，树右边界延伸下去的路径为边界节点 按照标准一打印的全部过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void printEdge1(Node head) &#123; if (head == null) &#123; return; &#125; int height = getHeight(head, 0); Node[][] edgeMap = new Node[height][2]; setEdgeMap(head, 0, edgeMap); // print left edge for (int i = 0; i != edgeMap.length; i++) &#123; System.out.print(edgeMap[i][0].value + &quot; &quot;); &#125; // print leaf node but not in map printLeafNotInMap(head, 0, edgeMap); // print right edge but not left edge for (int i = edgeMap.length - 1; i != -1; i--) &#123; if (edgeMap[i][0] != edgeMap[i][1]) &#123; System.out.print(edgeMap[i][1].value + &quot; &quot;); &#125; &#125; System.out.println();&#125;public static int getHeight(Node h, int l) &#123; if (h == null) &#123; return l; &#125; return Math.max(getHeight(h.left, l + 1), getHeight(h.right, l + 1)); &#125; public static void setEdgeMap(Node h, int l, Node[][] edgeMap) &#123; if (h == null) &#123; return; &#125; edgeMap[l][0] = edgeMap[l][0] == null ? h : edgeMap[l][0]; edgeMap[l][1] = h; setEdgeMap(h.left, l + 1, edgeMap); setEdgeMap(h.right, l + 1, edgeMap); &#125; public static void printLeafNotInMap(Node h, int l, Node[][] m) &#123; if (h == null) &#123; return; &#125; if (h.left == null &amp;&amp; h.right == null &amp;&amp; h != m[l][0] &amp;&amp; h != m[l][1]) &#123; System.out.print(h.value + &quot; &quot;); &#125; printLeafNotInMap(h.left, l + 1, m); printLeafNotInMap(h.right, l + 1, m);&#125; 按照标准二的要求实现打印的具体过程如下： 1234567891011121314151617181920212223242526272829303132333435public static void printEdge2(Node head) &#123; if (head == null) &#123; return; &#125; System.out.print(head.value + &quot; &quot;); if (head.left != null &amp;&amp; head.right != null) &#123; printLeftEdge(head.left, true); printRightEdge(head.right, true); &#125; else &#123; printEdge2(head.left != null ? head.left : head.right); &#125; System.out.println(); &#125; public static void printLeftEdge(Node h, boolean print) &#123; if (h == null) &#123; return; &#125; if (print || (h.left == null &amp;&amp; h.right == null)) &#123; System.out.print(h.value + &quot; &quot;); &#125; printLeftEdge(h.left, print); printLeftEdge(h.right, print &amp;&amp; h.left == null ? true : false); &#125; public static void printRightEdge(Node h, boolean print) &#123; if (h == null) &#123; return; &#125; printRightEdge(h.left, print &amp;&amp; h.right == null ? true : false); printRightEdge(h.right, print); if (print || (h.left == null &amp;&amp; h.right == null)) &#123; System.out.print(h.value + &quot; &quot;); &#125;&#125; 3，如何较为直观打印二叉树 二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树有重复值得时候，仅仅通过三种遍历的结果来构造二叉树的真实结构更是难上加难，有时则根本可能。给定一颗二叉树的头节点head，已知二叉树节点值的类型为32位整型，请实现一个打印二叉树的函数，可以直观地展树的形状，也便于画出真是的结构。 代码如下： 12345678910111213141516171819202122232425262728public static void printTree(Node head) &#123; System.out.println(&quot;Binary Tree:&quot;); printInOrder(head, 0, &quot;H&quot;, 17); System.out.println(); &#125; public static void printInOrder(Node head, int height, String to, int len) &#123; if (head == null) &#123; return; &#125; printInOrder(head.right, height + 1, &quot;v&quot;, len); String val = to + head.value + to; int lenM = val.length(); int lenL = (len - lenM) / 2; int lenR = len - lenM - lenL; val = getSpace(lenL) + val + getSpace(lenR); System.out.println(getSpace(height * len) + val); printInOrder(head.left, height + 1, &quot;^&quot;, len); &#125; public static String getSpace(int num) &#123; String space = &quot; &quot;; StringBuffer buf = new StringBuffer(&quot;&quot;); for (int i = 0; i &lt; num; i++) &#123; buf.append(space); &#125; return buf.toString();&#125; 4，二叉树的序列化和反序列化 题目：二叉树被记录成文件的过程叫做二叉树的序列化，通过文件重建成原来的二叉树的过程叫做二叉树的反序列化。给定一颗二叉树的头节点hed，并已知二叉树节点值得类型为32位整型，请设计一种二叉树序列化和反序列化的方案，并用代码实现。 思路： 方法一：先介绍下先序遍历下的序列化过程，首先假设序列化的结果字符串为str，初始时str=””。先序遍历二叉树，如果遇到null节点，就在字符串末尾加上”#!”，”#”表示这个节点为空，节点值不存在，”!”表示一个值的结束；如果遇到不为空的节点，假设节点值为3，就在str的末尾加上”3!”。 代码如下： 12345678910111213141516171819 public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125; &#125;public static String serialByPre(Node head) &#123; if (head == null) &#123; return &quot;#!&quot;; &#125; String res = head.value + &quot;!&quot;; res += serialByPre(head.left); res += serialByPre(head.right); return res; &#125; 接下来介绍通过先序遍历序列化的结果字符串str，重建二叉树的过程，即反序列化。 把结果字符串str变成字符串类型的数组，记为values，数组代表一棵二叉树先序遍历的节点顺序。例如，str=”12!3!#!#!#!”，生成的values为[“12”,”3”,”#”,”#”,”#”]，然后用values[0…4]按照先序遍历的顺序建立整棵树。 1，遇到”12”，生成节点值为12的节点(head)，然后用values[0…4]建立节点12的左子树， 2，遇到”3”，生成节点值为3的节点，它是节点12的左孩子，然后用values[2…4]建立节点3的左子树。 3，”#”，生成null节点，它是节点3的左孩子，该节点为null，所以这个节点没有后续建立子树的过程。回到节点3后，继续用values[3…4]建立节点3的右子树。 4，后续过程就是依次。 先序遍历反序列化的全部过程代码如下： 12345678910111213141516171819 public static Node reconByPreString(String preStr) &#123; String[] values = preStr.split(&quot;!&quot;); Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); for (int i = 0; i != values.length; i++) &#123; queue.offer(values[i]); &#125; return reconPreOrder(queue);&#125;public static Node reconPreOrder(Queue&lt;String&gt; queue) &#123; String value = queue.poll(); if (value.equals(&quot;#&quot;)) &#123; return null; &#125; Node head = new Node(Integer.valueOf(value)); head.left = reconPreOrder(queue); head.right = reconPreOrder(queue); return head; &#125; 方法二：通过层遍历实现序列化和反序列化。首先假设序列化的结果字符串为str，初始时str为空，然后实现二叉树的按层遍历，具体方式是利用队列结构，这也是宽度遍历图的常见方式。 代码： 123456789101112131415161718192021222324 public static String serialByLevel(Node head) &#123;if (head == null) &#123; return &quot;#!&quot;;&#125;String res = head.value + &quot;!&quot;;Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();queue.offer(head);while (!queue.isEmpty()) &#123; head = queue.poll(); if (head.left != null) &#123; res += head.left.value + &quot;!&quot;; queue.offer(head.left); &#125; else &#123; res += &quot;#!&quot;; &#125; if (head.right != null) &#123; res += head.right.value + &quot;!&quot;; queue.offer(head.right); &#125; else &#123; res += &quot;#!&quot;; &#125;&#125;return res; &#125; 5，遍历二叉树的神级方法–Morris方法 题目：给定一个二叉树的head，完成先序、中序、后续遍历。要求时间复杂度为O(n)，额外空间复杂度为O(1)。 思路：难度在于复杂度的要求，尤其是额外空间复杂度为O(1)的要求。之前的遍历方法虽然常用但无法做到额外空间复杂度为O(1)。这是因为遍历二叉树的递归方法实际上利用了函数栈(系统帮压栈)，非递归的方法使用了申请的栈，两者的额外空间复杂度都与树的高度有关，所以空间复杂度为O(h)，h为树的高度。那么完全不用栈结构能完成三种遍历吗？可以，答案是使用二叉树节点中大量指向null的指针，本提就是大名鼎鼎的Morris遍历，由Joseph Morris于1979年发明。 中序代码如下： 12345678910111213141516171819202122232425 public static void morrisIn(Node head) &#123;if (head == null) &#123; return;&#125;Node cur1 = head;Node cur2 = null;while (cur1 != null) &#123; cur2 = cur1.left; if (cur2 != null) &#123; while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123; cur2 = cur2.right; &#125; if (cur2.right == null) &#123; cur2.right = cur1; cur1 = cur1.left; continue; &#125; else &#123; cur2.right = null; &#125; &#125; System.out.print(cur1.value + &quot; &quot;); cur1 = cur1.right;&#125;System.out.println(); &#125; 先序遍历代码： 123456789101112131415161718192021222324252627 public static void morrisPre(Node head) &#123;if (head == null) &#123; return;&#125;Node cur1 = head;Node cur2 = null;while (cur1 != null) &#123; cur2 = cur1.left; if (cur2 != null) &#123; while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123; cur2 = cur2.right; &#125; if (cur2.right == null) &#123; cur2.right = cur1; System.out.print(cur1.value + &quot; &quot;); cur1 = cur1.left; continue; &#125; else &#123; cur2.right = null; &#125; &#125; else &#123; System.out.print(cur1.value + &quot; &quot;); &#125; cur1 = cur1.right;&#125;System.out.println(); &#125; 后续遍历代码： 1234567891011121314151617181920212223242526 public static void morrisPos(Node head) &#123;if (head == null) &#123; return;&#125;Node cur1 = head;Node cur2 = null;while (cur1 != null) &#123; cur2 = cur1.left; if (cur2 != null) &#123; while (cur2.right != null &amp;&amp; cur2.right != cur1) &#123; cur2 = cur2.right; &#125; if (cur2.right == null) &#123; cur2.right = cur1; cur1 = cur1.left; continue; &#125; else &#123; cur2.right = null; printEdge(cur1.left); &#125; &#125; cur1 = cur1.right;&#125;printEdge(head);System.out.println(); &#125; 6，在二叉树中找到累加和为指定值得最长路径长度 题目：给定一颗二叉树头节点head和一个32位整数sum，二叉树节点值类型为整型，求累加和为sum的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。 7，找到二叉树中的最多搜索二叉子树 题目：给定一颗二叉树的头节点head，已知所有节点值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点。 要求：如果节点数为n，要求时间复杂度为O(n)，额外空间复杂度为O(h)，h为二叉树高度。 思路： 以节点node为头的树中，最大的搜索二叉树只能来自于以下两种情况。 第一种：如果来自node左子树上的最大搜索二叉子树是以node.left为头的；来自node右子树上的最大搜索二叉子树是以node.left为头的，node左子树上的最大搜索二叉子树的最大值小于node.value；node右子树上的最大搜索二叉子树的最小值大于node.value，那么以节点node为头的整棵树都是二叉搜索树。 第二种：如果不满足第一种，说明以节点node为头的树整体不能连成搜索二叉树。这种情况下，以node为头的树的最大搜索二叉树是来自于node的左子树上的最大搜索二叉子树和来自于node右子树上的最大搜索二叉子树之间，节点数较多的那个。 求解的具体步骤： 1，整体过程是二叉树的后续遍历 2，遍历到当前节点记为cur时，先遍历cur的左子树收集4个信息，分别是左子树上最大搜索二叉子树的头节点(IBST)、节点数(ISize)、最小值(IMin)、和最大值(IMax)。再遍历cur的右子树收集4个信息，分别是右子树上最大搜索二叉子树的头节点(rBST)、节点数(rSize)、最小值(rMin)和最大值(rMax)。 3，根据步骤2所收集的信息，判断是否满足第一种情况，如果满足第一种情况，就返回cur节点，如果满足第二种，就返回lBST和rBST中较大的一个。 4，可以使用全局变量的方式实现步骤2中收集节点数、最小值和最大值的问题。找到最大搜索二叉子树的具体过程参看下面代码中的biggestSubBST。 1234567891011121314151617181920212223242526272829303132 public static Node biggestSubBST(Node head) &#123; int[] record = new int[3]; // 0-&gt;size, 1-&gt;min, 2-&gt;max return posOrder(head, record);&#125;public static Node posOrder(Node head, int[] record) &#123; if (head == null) &#123; record[0] = 0; record[1] = Integer.MAX_VALUE; record[2] = Integer.MIN_VALUE; return null; &#125; int value = head.value; Node left = head.left; Node right = head.right; Node lBST = posOrder(left, record); int lSize = record[0]; int lMin = record[1]; int lMax = record[2]; Node rBST = posOrder(right, record); int rSize = record[0]; int rMin = record[1]; int rMax = record[2]; record[1] = Math.min(lMin, value); record[2] = Math.max(rMax, value); if (left == lBST &amp;&amp; right == rBST &amp;&amp; lMax &lt; value &amp;&amp; value &lt; rMin) &#123; record[0] = lSize + rSize + 1; return head; &#125; record[0] = Math.max(lSize, rSize); return lSize &gt; rSize ? lBST : rBST; &#125; 8，找到二叉树中符合搜索二叉树条件的最大拓扑结构 题目：给定一棵二叉树头节点head，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小。 9，二叉树的按层打印与ZigZag打印 题目：给定一颗二叉树的头节点head，分别实现按层打印和zigzag打印二叉树的函数。例如：头节点1，左孩子2，右孩子为3，节点2左孩子为4，右孩子为空，节点3左孩子为5，右孩子为6，节点5左孩子为7，节点5右孩子为8。 按层打印时，输出格式如下： level 1：1 level 2：2 3 level 3：4 5 6 level 4：7 8 zigzag打印时，如下输出： level 1 from left to right：1 level 1 from right to left：3 2 level 1 from left to right：4 5 6 level 1 from right to left：8 7 二叉树按层打印的代码：12345678910111213141516171819202122232425262728 public static void printByLevel(Node head) &#123;if (head == null) &#123; return;&#125;Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();int level = 1;Node last = head;Node nLast = null;queue.offer(head);System.out.print(&quot;Level &quot; + (level++) + &quot; : &quot;);while (!queue.isEmpty()) &#123; head = queue.poll(); System.out.print(head.value + &quot; &quot;); if (head.left != null) &#123; queue.offer(head.left); nLast = head.left; &#125; if (head.right != null) &#123; queue.offer(head.right); nLast = head.right; &#125; if (head == last &amp;&amp; !queue.isEmpty()) &#123; System.out.print(&quot;\nLevel &quot; + (level++) + &quot; : &quot;); last = nLast; &#125;&#125;System.out.println(); &#125; 思路：按层打印对二叉树做简单的宽度优先遍历即可，但本题有额外的要求，就是同一层的节点必须打印在一行上，并且要输出行号。这就需要在原来的宽度优先遍历做一些改进。关键是如何换行。 只需用两个node型的变量last和nLast即可，last表示当前打印行的最右节点，nLast表示下一行的最右节点，假设我们每一层都做从左到右的宽度优先遍历，如果发现遍历到的节点等于last，说明该换行了。换行之后只要令last=nLast，就可以继续下一行的打印过程，此过程重复，直到所有的节点都打印完。那么问题就变成了如何更新nLast？只需要让nLast一直跟踪记录宽度优先遍历队列中的最新加入的节点即可。这是因为最新加入队列的节点一定是目前已经发现的下一行的最右节点。所以在当前行打印完时，nLast一定是下一行所有节点中的最右节点。 2)二叉树zigzag打印 先介绍不推荐的做法： 使用arraylist结构，两个，分别记为list1.list2，用list1去收集当前层的节点，然后从左到右打印当前层，接着把当前层的孩子节点放进list2，并从右到左打印，接下来再把list2的所有的节点的孩子节点放入list1，如此反复。不推荐的原因是arraylist是动态数组，在这个结构中，当元素达到一定的量时，会发生扩容操作，扩容操作的时间复杂度是O(n)比较高的，这个结构增加删除元素的时间复杂度都比较高。总之，用这种数据结构不够干净和纯粹，最好不要使用。 推荐的方法是双端队列，具体为java的LinkedList结构，这个结构的底层是非常纯粹的双端队列结构，本书的方法也仅使用双端队列结构的基本操作。 先举题目的例子来展示大体过程，首先生成双端队列结构dp，将节点1从dp的头部放入dp。 原则1：如果是从左到右的过程，那么一律从dp的头部弹出节点，如果弹出的节点没有孩子节点，当然不用放入任何节点到dp中；如果当前节点有孩子节点，先让左孩子从尾部进入dp，再让右孩子从尾部进入dp。 根据原则1，先从dp头部弹出节点1并打印，然后先让节点2从dp尾部进入，再让节点3从dp尾部进入。 原则2：如果是从右到左的过程，那么一律从dp的尾部弹出节点，如果弹出的节点没有还节点，当然不能放入任何节点到dp中；如果当前节点有孩子节点，先让右孩子从头部进入dp，再让左孩子从头部进入dp。 根据原则2，先从dp尾部弹出节点3并打印，然后先让节点6从dp头部进入，再让节点5从dp头部进入。 根据原则2，先从dp尾部弹出节点并打印，然后让节点4从dp头部进入。 根据原则1，依次从dp头部弹出节点4、5、6并打印，这期间先让节点7从dp尾部进入，再让节点8从dp尾部进入。 最后根据原则2，依次从dp尾部弹出节点8和节点7并打印即可。 用原则1和2的过程切换，我们可以完成zigzag的打印过程，所以问题在于，如何确定原则1和原则2的切换时机，其实还是如何确定每一层最后一个节点的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 public static void printByZigZag(Node head) &#123;if (head == null) &#123; return;&#125;Deque&lt;Node&gt; dq = new LinkedList&lt;Node&gt;();int level = 1;boolean lr = true;Node last = head;Node nLast = null;dq.offerFirst(head);printLevelAndOrientation(level++, lr);while (!dq.isEmpty()) &#123; if (lr) &#123; head = dq.pollFirst(); if (head.left != null) &#123; nLast = nLast == null ? head.left : nLast; dq.offerLast(head.left); &#125; if (head.right != null) &#123; nLast = nLast == null ? head.right : nLast; dq.offerLast(head.right); &#125; &#125; else &#123; head = dq.pollLast(); if (head.right != null) &#123; nLast = nLast == null ? head.right : nLast; dq.offerFirst(head.right); &#125; if (head.left != null) &#123; nLast = nLast == null ? head.left : nLast; dq.offerFirst(head.left); &#125; &#125; System.out.print(head.value + &quot; &quot;); if (head == last &amp;&amp; !dq.isEmpty()) &#123; lr = !lr; last = nLast; nLast = null; System.out.println(); printLevelAndOrientation(level++, lr); &#125;&#125;System.out.println(); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表问题算法(二)]]></title>
    <url>%2F2018%2F08%2F26%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%8C%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1，打印两个有序链表中的公共部分 题目：给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。 解答思路： 1，如果head1的值小于head2，则head1往下移动 2，如果head2的值小于head1，则head2往下移动 3，如果head1的值与head2的值相等，则打印这个值，然后head1与head2都往下移 4，head1或head2有任何一个移动到null，整个过程停止 代码如下： 123456789101112131415public static void printCommonPart(Node head1, Node head2) &#123; System.out.print(&quot;Common Part: &quot;); while (head1 != null &amp;&amp; head2 != null) &#123; if (head1.value &lt; head2.value) &#123; head1 = head1.next; &#125; else if (head1.value &gt; head2.value) &#123; head2 = head2.next; &#125; else &#123; System.out.print(head1.value + &quot; &quot;); head1 = head1.next; head2 = head2.next; &#125; &#125; System.out.println();&#125;2，在单链表和双链表中删除倒数第K个数 题目：分别实现两个函数，一个可以删除单链表倒数第K个数，另一个可以删除双链表中倒数第K个节点。 要求：如果链表长度为N，要求时间复杂度达到O(N)，额外空间复杂度O(1)。 先看单链表的代码： 123456789101112131415161718192021222324252627282930 public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125;&#125;public static Node removeLastKthNode(Node head, int lastKth) &#123; if (head == null || lastKth &lt; 1) &#123; return head; &#125; Node cur = head; while (cur != null) &#123; lastKth--; cur = cur.next; &#125; if (lastKth == 0) &#123; head = head.next; &#125; if (lastKth &lt; 0) &#123; cur = head; while (++lastKth != 0) &#123; cur = cur.next; &#125; cur.next = cur.next.next; &#125; return head; &#125;双链表调整： 123456789101112131415161718192021222324252627282930313233343536 public static class DoubleNode &#123; public int value; public DoubleNode last; public DoubleNode next; public DoubleNode(int data) &#123; this.value = data; &#125;&#125;public static DoubleNode removeLastKthNode(DoubleNode head, int lastKth) &#123; if (head == null || lastKth &lt; 1) &#123; return head; &#125; DoubleNode cur = head; while (cur != null) &#123; lastKth--; cur = cur.next; &#125; if (lastKth == 0) &#123; head = head.next; head.last = null; &#125; if (lastKth &lt; 0) &#123; cur = head; while (++lastKth != 0) &#123; cur = cur.next; &#125; DoubleNode newNext = cur.next.next; cur.next = newNext; if (newNext != null) &#123; newNext.last = cur; &#125; &#125; return head; &#125;3，删除链表的中间节点和a/b处的节点 题目：给定链表头节点head，实现删除链表的中间节点的函数。 例如： 1–&gt;2:删除1节点； 1–&gt;2–&gt;3:删除2节点; 1–&gt;2–&gt;3–&gt;4:删除2节点; 1–&gt;2–&gt;3–&gt;4–&gt;5:删除3节点; 进阶：给定链表头节点head、整数a和b，实现删除位于a/b处节点的函数。 例如： 链表：1–&gt;2–&gt;3–&gt;4–&gt;5，假设a/b的值为r。 如果r等于0，不删除任何节点; 如果r在区间(0,1/5]上，删除节点1; 如果r在区间(1/5,2/5]上，删除节点2; 如果r在区间(2/5,3/5]上，删除节点3; 如果r在区间(3/5,4/5]上，删除节点4; 如果r在区间(4/5,1/5]上，删除节点5; 删除中间节点的代码： 12345678910111213141516 public static Node removeMidNode(Node head) &#123; if (head == null || head.next == null) &#123; return head; &#125; if (head.next.next == null) &#123; return head.next; &#125; Node pre = head; Node cur = head.next.next; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; pre = pre.next; cur = cur.next.next; &#125; pre.next = pre.next.next; return head;&#125; 进阶问题，删除a/b处的节点。 1234567891011121314151617181920212223 public static Node removeByRatio(Node head, int a, int b) &#123; if (a &lt; 1 || a &gt; b) &#123;` return head; &#125; int n = 0; Node cur = head; while (cur != null) &#123; n++; cur = cur.next; &#125; n = (int) Math.ceil(((double) (a * n)) / (double) b); if (n == 1) &#123; head = head.next; &#125; if (n &gt; 1) &#123; cur = head; while (--n != 1) &#123; cur = cur.next; &#125; cur.next = cur.next.next; &#125; return head;&#125; 4，反转单向链表和双向链表 题目：分别实现反转单向链表和双向链表的函数 要求：长度为n，时间复杂度为O(n)，额外空间复杂度要求为O(1)。 反转单链表代码如下： 12345678910111213 public static Node reverseList(Node head) &#123;Node pre = null;Node next = null;while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next;&#125;return pre; &#125; ``` 反转双向链表代码： public static DoubleNode reverseList(DoubleNode head) { DoubleNode pre = null; DoubleNode next = null; while (head != null) { next = head.next; head.next = pre; head.last = next; pre = head; head = next; } return pre; } 1234567895，反转部分单向链表 题目：给定一个单向链表的头节点，以及两个整数from和to，在单向链表上把第from个节点到第to个节点这一部分进行反转。 例如：1--&gt;2--&gt;3--&gt;4--&gt;5--&gt;null，from=2，to=4. 调整结果为：1--&gt;4--&gt;3--&gt;2--&gt;5--&gt;null 再如：1--&gt;2--&gt;3--&gt;null,from=1，to=3 调整结果为：3--&gt;2--&gt;1--&gt;null 要求： 1，链表长度为n，时间复杂度为O(n)，额外空间复杂度要求为O(1)。 2，如果不满足1&lt;=frim&lt;=to&lt;==n，则不调整。 public static Node reversePart(Node head, int from, int to) { int len = 0; Node node1 = head; Node fPre = null; Node tPos = null; while (node1 != null) { len++; fPre = len == from - 1 ? node1 : fPre; tPos = len == to + 1 ? node1 : tPos; node1 = node1.next; } if (from &gt; to || from &lt; 1 || to &gt; len) { return head; } node1 = fPre == null ? head : fPre.next; Node node2 = node1.next; node1.next = tPos; Node next = null; while (node2 != tPos) { next = node2.next; node2.next = node1; node1 = node2; node2 = next; } if (fPre != null) { fPre.next = node1; return head; } return node1; } 123456，环形单链表的约瑟夫问题 题目：39个犹太人与Josephus以及他的朋友躲到一个洞中，39个犹太人宁愿死也不愿意被敌人抓到，于是决定了一个自杀方式，41个人排成一个圈，由第一个人开始报数，报道3的人开始自杀，然后下一个人继续重新报1，报到3的人再自杀，这样再一次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题，现在请用单向环形链表描述该结构呈现整个自杀过程。 思路： 代码： public static Node josephusKill1(Node head, int m) { if (head == null || head.next == head || m &lt; 1) { return head; } Node last = head; while (last.next != head) { last = last.next; } int count = 0; while (head != last) { if (++count == m) { last.next = head.next; count = 0; } else { last = last.next; } head = last.next; } return head; } 123456 以上代码的时间复杂度是O(n*m)，显然不符合进阶的要求。进阶的代码：7，判断链表是否为回文结构题目：判断是否是回文结构，例如：1--&gt;2--&gt;1，返回true；1--&gt;2--&gt;3,返回false。思路：利用栈即可，遍历栈，遍历过程中把节点压入栈，因为栈是先进后出的，所以在遍历后，从栈顶到栈底的节点值出现顺序会与原链表从左到右的值顺序反过来，那么，如果一个链表是回稳结构，如果出现的值还是一样的，那就是回文结构，否则不是。代码如下： // need n extra space。空间复杂度为O(n/2)。利用栈 public static boolean isPalindrome1(Node head) { Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node cur = head; while (cur != null) { stack.push(cur); cur = cur.next; } while (head != null) { if (head.value != stack.pop().value) { return false; } head = head.next; } return true; } 1需要n/2的额外空间复杂度的代码： // need n/2 extra space，额外空间复杂度为O(n/2)。这个方法是对第一种方法进行了改进，每次压右半部分的节点，这样从栈顶到栈底的顺序就相当于反过来了，然后与前半部分一一比较。 public static boolean isPalindrome2(Node head) { if (head == null || head.next == null) { return true; } Node right = head.next; Node cur = head; while (cur.next != null &amp;&amp; cur.next.next != null) { right = right.next; cur = cur.next.next; } Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (right != null) { stack.push(right); right = right.next; } while (!stack.isEmpty()) { if (head.value != stack.pop().value) { return false; } head = head.next; } return true; } 1空间复杂度为仅仅为O(1)： // need O(1) extra space 方法三：不需要栈和其他数据结构，只用有限几个变量，其额外空间复杂度为O(1)，可以在O(n)内完成所有的过程，也就是满足进阶的要求。具体过程如下： 1，首先改变链表右半部分的结构，使整个右半区反转，最后指向中间节点。 例如：1--&gt;2--&gt;3--&gt;2--&gt;1，通过这一步将其调整之后结构如下：1--&gt;2--&gt;3&lt;--2&lt;--1，链表1--&gt;2--&gt;3--&gt;3--&gt;2--&gt;1，调整后为：1--&gt;2--&gt;3&lt;--3&lt;--2&lt;--1。 我们把左半边区域第一个节点记为leftStart，把反转后的右半部分的最右边的节点记为rightStart。 2，leftStart和rightStart同时向中间点移动，移动每一步都比较leftStart和rightStart节点的值，看是否一样，一样的话，说明链表为为回文结构，否则不是回文结构。 3，不管最后返回时false还是true，在返回前都应该把链表恢复成原来的状况。 4，链表恢复成原来的样子，返回检查结果。以下是代码： public static boolean isPalindrome3(Node head) { if (head == null || head.next == null) { return true; } Node n1 = head; Node n2 = head; while (n2.next != null &amp;&amp; n2.next.next != null) { // find mid node，找到中间节点，和方法二有一点不一样，方法二的中间是从head.next开始，方法三是从head开始，这有什么区别呢？在节点为偶数的时候，方法二得到的中间是中间两个节点的后一个节点，而方法三得到的中间节点得到的是中间两个节点的前一个节点，为什么？因为方法二的情况下要压入节点进栈就是从后半部分开始，这样就可以理解了，实际上理解为后半部分更恰当。 n1 = n1.next; // n1 -&gt; mid n2 = n2.next.next; // n2 -&gt; end } n2 = n1.next; // n2 -&gt; right part first node n1.next = null; // mid.next -&gt; null Node n3 = null; while (n2 != null) { // right part convert n3 = n2.next; // n3 -&gt; save next node n2.next = n1; // next of right node convert n1 = n2; // n1 move n2 = n3; // n2 move } n3 = n1; // n3 -&gt; save last node n2 = head;// n2 -&gt; left first node boolean res = true; while (n1 != null &amp;&amp; n2 != null) { // check palindrome if (n1.value != n2.value) { res = false; break; } n1 = n1.next; // left to mid n2 = n2.next; // right to mid } n1 = n3.next; n3.next = null; while (n1 != null) { // recover list n2 = n1.next; n1.next = n3; n3 = n1; n1 = n2; } return res; } ```]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>zhan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java]]></title>
    <url>%2F2018%2F08%2F25%2F%E8%BF%9B%E9%98%B6%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[java虚拟机概述我们常说的JDK(Java Development Kit)包含了Java语言、Java虚拟机和Java API类库三部分，这是java开发的最小环境，而JRE(Java Runtime Environment)包括了Java API中的Java SE API子集和Java虚拟机这两部分，是Java程序运行的标准环境。可以看出Java虚拟机的重要性，它是整个Java平台的基石，是Java语言编译代码的运行平台。你可以把Java虚拟机看作一个抽象的计算机，它有各种指令集和各种运行时数据区域。Java虚拟机不仅仅可以运行Java，还可以运行kotlin、Croovy、Scala、Jython等。 Java虚拟机家族Java虚拟机不是一个，而是有很多实现。很多人认为一般说Java虚拟机就是指Oracle的HotSpot虚拟机，实际上不是，不过HotSpot虚拟机应用最广泛就是了，下面简单介绍几种主流的虚拟机实现。 1,HotSpot VMOracle JDK和OpenJDK中自带的虚拟机，是最主流和使用最广泛的Java虚拟机。介绍Java虚拟机的文章，如果不做特殊说明，一般都指HotSpot VN。HotSpot VM并非是Sun公司开发的，而是由Longview Technologies这家小公司设计的，它在1997年被Sun收购，Sun公司又在2009年被Oracle收购。 2，J9 VMJ9 VM是IBM开发的，目前是其主力发展的Java虚拟机。J9 VM的市场定位和HotSpot VM接近，它是一款设计上从服务器到桌面应用再到嵌入式都考虑到的多用途虚拟机，目前J9 VM的性能水平大致与HotSpot是一个档次的。 3，Zing VM以Oracle的HotSpot VM为基础，改进了许多影响延迟的细节。最大的3个卖点如下： a,低延迟,”无暂停”的C4 GC，GC带来的暂停可以控制在10ms以下的级别，支持的Java堆大小可以达到1TB。 b,启动后快速预热功能 c，可管理性：零开销、可在生产环境全时开启、整合在JVM内的监控工具Zing Vision。 需要注意的是，Android中的Dalvik和ART虚拟机并不属于Java虚拟机，因此这里没有列出他们，11章学习Dalvik和ART虚拟机。 Java虚拟机执行流程执行一个Java程序时，它的执行流程是这样,如下图所示： 可以看出Java虚拟机执行流程分为两大部分：编译时环境和运行时环境，当一个Java文件经过Java编译器编译后会生成class文件，它会由Java虚拟机来处理。Java虚拟机与Java虚拟机语言没有什么必然的关系，它只与特定的二进制文件：class文件有关。因此无论任何语言只要能编译成class文件，就能被Java虚拟机识别并执行。如下图所示 Java虚拟机结构如图所示，这里讲的体系结构，是指Java虚拟机的抽象行为，而不是具体的比如HotSpot VM的实现。按照Java虚拟机规范，抽象的java虚拟机如图3所示。 java虚拟机结构包括运行时数据区域、执行引擎、本地库接口和本地方法库，方法区和堆是所有线程共享的数据区域。 类的生命周期一个Java文件加载到Java虚拟机内存中从内存中卸载的过程被称为类的生命周期。类的生命周期包括的阶段：加载、链接、初始化、使用和卸载。广义上类的加载分为：加载、链接(验证、准备和解析)、初始化。 接下来介绍各个阶段所做的工作，如下所示： 1，加载：查找并加载class文件 2，链接：包括验证、准备和解析 a,验证：确保被导入类型的正确 b,准备：为类的静态字段分配字段，并用默认值初始化这些字段 c,解析：虚拟机将常量池内的符号引用替换为直接引用 3，初始化：将类变量初始化为正确初始值根据《深入理解Java虚拟机》，加载阶段(并非类的加载)主要做了三件事： 1，根据特定名称查找类或接口类型的二进制字节流 2，将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构 3，在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 类加载子系统Java虚拟机中有两种类加载器：系统加载器和自定义加载器。其中系统加载器包括以下三种： 1，Bootstrap ClassLoader (引导类加载器) 用c/c++实现的，用于加载指定的JDK核心类库，java.lang.,java.uti.等。它用来加载/jre/lib和-Xbootclasspath参数指定的目录。 JVM就是通过引导类加载器创建一个初始类来完成的，由于类加载器是C/C++实现的，所以该加载器不能被Java代码所访问，但是可以查询某个类是否被引导类加载器加载过。 2，Extensions ClassLoader (扩展类加载器) Java实现，加载以下目录的类文件: a,/jre/lib/ext b,系统属性java.ext.dir所指定的目录 3，Application ClassLoader (应用程序加载器) 又称作System ClassLoader(系统类加载器)，这是因为这个类加载器可以通过ClassLoader的getSystemClassLoader方法获取到，用于加载以下类库文件： a,当前应用程序ClassPath目录 b,系统属性java.class.path指定的目录 运行时数据区域GC算法垃圾标记算法1，引用计数法每个对象有一个引用计数器，当对被引用时它的引用计数器就加1，引用失效就减1，引用计数器中的值为0时，则该对象不能被使用，变成了垃圾。这不是主流的垃圾标记算法，不选择引用计数法来判断垃圾主要是因为引用计数法没有解决对象之间相互引用的问题。 2，根搜索法 这是目前主流的垃圾标记算法 垃圾收集算法垃圾被标记后，GC就会对垃圾进行收集，接下来介绍常用的垃圾回收算法 1，标记清除 标记阶段：标记出可以被回收的对象清除阶段: 回收被标记的对象所占用的空间标记–清除算法是基础的，是因为后面的几个算法都是在此基础上进行改造的。标记清除算法有两个缺点： a,标记的效率不高， b,容易产生大量的不连续的碎片，碎片太多可能会导致后续没有足够的连续内存分配给较大的对象，从而提前出发GC。 2，复制算法 复制算法是每次只使用一半的内存，GC时，遍历当前的区域，把存活的对象复制到另外一个区域中，最后将当前使用的区域的可回收对象进行回收，复制算法每次都对半个区域进行回收，不需要考虑碎片的问题，缺点是每次只能使用一半的内存。复制算法的效率和存活的对象数目有很大的关系，如果存活的对象很少，那么效率就高，由于绝大多数对象的生命周期很短，并且这些对象都在新生代中，所以复制算法被广泛应用于新生代中。 3，标记-压缩算法 新生代使用复制算法，老年代就不适合使用了，因为老年代的对象存活率高，若在老年代使用复制算法，这样就会产生较多的复制操作，导致效率变低。与标记清除算法不同的是，在标记可回收的对象之后，将存活的对象压缩到内存的一端，使它们紧紧排列在一起，然后对边界以外的内存进行回收，回收后，已用的和未被使用的内存各占一边。 4，分代收集 Minor Collection:新生代垃圾收集Full Collection:对老年代进行收集，又称Major Collection，Full Collection通常情况下会伴随至少一次的Minor Collection，它的收集频率低，耗时较长 执行一次Minor Collection时，Eden空间的存活对象会被复制到To Survivor空间，并且之前进过一次Minor Collection并在From Survivor空间的对象也会被复制到To Survivor空间。两种情况下不会复制到To Survivor空间而是晋升到老年代。一种是存活的对象的分代年龄超过-XX:MaxTenuringThreshold (用于控制对象经历多少次Minor GC才晋升到老年代)所指定的阈值；另一种是To Survivor空间满了，也是达到阈值。当所有存活对象都被复制到To Survivor空间，或者晋升到老年代，也就意味着Eden区和From Survivor区剩下的都是可回收对象。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列栈和队列算法]]></title>
    <url>%2F2018%2F08%2F25%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1，设计一个具有getMin功能的栈，概念：在实现基本的栈的功能上，再实现返回栈中的最小元素的操作。要求：pop、push、getMin的时间复杂度都是O(1)。设计的栈类型可以使用现成的栈结构。 思路：在设计上我们使用两个栈，一个栈用来保存当前的元素，其功能和一个正常的一样，记为stackMin。具体实现方式如下：假设当前数据为newNum，先将其压入stackData栈，然后判断stackMin是否为空。如果为空，则newNum也压入stackMin；如果不为空，则比较newNum和stackMin的栈顶元素中哪一个更小，如果newNum更小或者相等，则newNum也压入stackMin；如果stackMin中栈顶元素小，则把stackMin元素重复压入stackMin，即在栈顶元素上再压入一个栈顶元素，举例，stackData栈依次压入3、4、5、1、2、1，在这个过程中stackData栈从栈底到栈顶依次是3、4、5、1、2、1。stackMin栈依次是3、3、3、1、1、1。弹出数据规则：弹出的数据记为value，弹出stackMin中的栈顶；返回value。代码如下： 123456789101112131415161718192021222324252627282930313233343536public static class MyStack2 &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; public MyStack2() &#123; stackData = new Stack&lt;Integer&gt;(); stackMin = new Stack&lt;Integer&gt;(); &#125; public void push(int newNum) &#123; if (stackMin.isEmpty()) &#123; stackMin.push(newNum); &#125; else if (newNum &lt; this.getmin()) &#123; this.stackMin.push(newNum); &#125; else &#123; int newMin = this.stackMin.peek(); this.stackMin.push(newMin); &#125; this.stackData.push(newNum); &#125; public int pop() &#123; if (this.stackData.isEmpty()) &#123; throw new RuntimeException(&quot;Your stack is empty.&quot;); &#125; this.stackMin.pop(); return this.stackData.pop(); &#125; public int getmin() &#123; if (this.stackMin.isEmpty()) &#123; throw new RuntimeException(&quot;Your stack is empty.&quot;); &#125; return this.stackMin.peek(); &#125;&#125; 如上所示。2，题目：由两个栈组成的队列，用两个栈实现队列，支持队列的基本操作根据栈和队列的特点，我们可以用两个栈，把顺序反过来实现类似队列的操作。具体上是一个栈作为压入栈，在压入的时候只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，在弹出的时候只从这个栈弹出，记为stackPop。因为数据压入栈的时候，是先进后出的，那么只要把stackPush的数据再压入stackPop中，顺序就变回来了。操作过程中要注意以下几点：1，stackPush栈要往stackPop压入数据，那么必须一次性把stackPush中的数据全部压入。2，stackPop栈不为空，stackPush不能向stackPop栈压入元素。 1234567891011121314151617181920212223242526272829303132333435public static class TwoStacksQueue &#123; public Stack&lt;Integer&gt; stackPush; public Stack&lt;Integer&gt; stackPop; public TwoStacksQueue() &#123; stackPush = new Stack&lt;Integer&gt;(); stackPop = new Stack&lt;Integer&gt;(); &#125; public void add(int pushInt) &#123; stackPush.push(pushInt); &#125; public int poll() &#123; if (stackPop.empty() &amp;&amp; stackPush.empty()) &#123; throw new RuntimeException(&quot;Queue is empty!&quot;); &#125; else if (stackPop.empty()) &#123; while (!stackPush.empty()) &#123; stackPop.push(stackPush.pop()); &#125; &#125; return stackPop.pop(); &#125; public int peek() &#123; if (stackPop.empty() &amp;&amp; stackPush.empty()) &#123; throw new RuntimeException(&quot;Queue is empty!&quot;); &#125; else if (stackPop.empty()) &#123; while (!stackPush.empty()) &#123; stackPop.push(stackPush.pop()); &#125; &#125; return stackPop.peek(); &#125;&#125; 代码如上。3,使用递归函数和栈操作逆序一个栈。题目：一个栈依次压入1、2、3、4、5。那么从栈顶到栈底分别为5、4、3、2、1。也就是实现栈中元素的逆序，但是只能用递归函数，不能使用其他数据结构。考察递归函数和栈的操作，设计两个递归函数。递归函数一：将栈stack的栈底元素返回并移除。设计一个getAndRemoveLastElement方法。 12345678910public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) &#123; int result = stack.pop(); if (stack.isEmpty()) &#123; return result; &#125; else &#123; int last = getAndRemoveLastElement(stack); stack.push(result); return last; &#125;&#125; 代码如上。递归函数二：逆序一个栈，设计reverse方法，该方法用到了上面提到的getAndRemoveLast方法。 12345678public static void reverse(Stack&lt;Integer&gt; stack) &#123; if (stack.isEmpty()) &#123; return; &#125; int i = getAndRemoveLastElement(stack); reverse(stack); stack.push(i);&#125; 代码如上。4，猫狗队列，题目：实现一种猫狗队列的结构，要求如下：1，add方法可将cat类或dog类的实例放入队列中。2，pollAll方法可以将队列所有的实例按照进队列的先后顺序依次弹出。3，pollDog方法可以将队列中的dog类的实例按照进队列的顺序依次弹出。4，pollCat方法，将队列cat类的实例按照进队列的顺序依次弹出。5，isEmpty方法检查队列中是否还有dog或者cat的实例。6，isDogEmpty方法检查队列中是否有dog类的实例。7，isCatEmpty方法检测队列中是否有cat类的实例。本题考查实现特殊数据结构的能力以及针对特殊功能的算法设计能力。代码如下：pet类 1234567891011public static class Pet &#123; private String type; public Pet(String type) &#123; this.type = type; &#125; public String getPetType() &#123; return this.type; &#125;&#125; dog和cat类 1234567891011public static class Dog extends Pet &#123; public Dog() &#123; super(&quot;dog&quot;); &#125;&#125;public static class Cat extends Pet &#123; public Cat() &#123; super(&quot;cat&quot;); &#125;&#125; 主代码： 123456789101112131415161718192021public static class PetEnterQueue &#123; private Pet pet; private long count; public PetEnterQueue(Pet pet, long count) &#123; this.pet = pet; this.count = count; &#125; public Pet getPet() &#123; return this.pet; &#125; public long getCount() &#123; return this.count; &#125; public String getEnterPetType() &#123; return this.pet.getPetType(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static class DogCatQueue &#123; private Queue&lt;PetEnterQueue&gt; dogQ; private Queue&lt;PetEnterQueue&gt; catQ; private long count; public DogCatQueue() &#123; this.dogQ = new LinkedList&lt;PetEnterQueue&gt;(); this.catQ = new LinkedList&lt;PetEnterQueue&gt;(); this.count = 0; &#125; public void add(Pet pet) &#123; if (pet.getPetType().equals(&quot;dog&quot;)) &#123; this.dogQ.add(new PetEnterQueue(pet, this.count++)); &#125; else if (pet.getPetType().equals(&quot;cat&quot;)) &#123; this.catQ.add(new PetEnterQueue(pet, this.count++)); &#125; else &#123; throw new RuntimeException(&quot;err, not dog or cat&quot;); &#125; &#125; public Pet pollAll() &#123; if (!this.dogQ.isEmpty() &amp;&amp; !this.catQ.isEmpty()) &#123; if (this.dogQ.peek().getCount() &lt; this.catQ.peek().getCount()) &#123; return this.dogQ.poll().getPet(); &#125; else &#123; return this.catQ.poll().getPet(); &#125; &#125; else if (!this.dogQ.isEmpty()) &#123; return this.dogQ.poll().getPet(); &#125; else if (!this.catQ.isEmpty()) &#123; return this.catQ.poll().getPet(); &#125; else &#123; throw new RuntimeException(&quot;err, queue is empty!&quot;); &#125; &#125; public Dog pollDog() &#123; if (!this.isDogQueueEmpty()) &#123; return (Dog) this.dogQ.poll().getPet(); &#125; else &#123; throw new RuntimeException(&quot;Dog queue is empty!&quot;); &#125; &#125; public Cat pollCat() &#123; if (!this.isCatQueueEmpty()) &#123; return (Cat) this.catQ.poll().getPet(); &#125; else throw new RuntimeException(&quot;Cat queue is empty!&quot;); &#125; public boolean isEmpty() &#123; return this.dogQ.isEmpty() &amp;&amp; this.catQ.isEmpty(); &#125; public boolean isDogQueueEmpty() &#123; return this.dogQ.isEmpty(); &#125; public boolean isCatQueueEmpty() &#123; return this.catQ.isEmpty(); &#125;&#125; 5，用一个栈实现另一个栈的排序题目：一个栈中元素的类型为整型，现在想将该栈从栈顶到栈底从大到小排序，只许申请一个栈，可以申请新的变量，但不能额外的数据结构，如何完成排序？思路：将要排序的栈记为stack，申请的辅助栈记为help，在stack上执行pop操作，弹出的元素记为cur。1，如果cur小于或等于help栈的栈顶元素，则将cur直接压入help。2，如果cur大于help的栈顶元素，则将help的元素逐一弹出，逐一压入stack，直到cur小于或等于help的栈顶元素，再将cur压入help。一直执行以上操作，直到stack栈中的元素全部压入了help，最后将help中所有的元素逐一压入stack，即完成排序。代码如下： 12345678910111213public static void sortStackByStack(Stack&lt;Integer&gt; stack) &#123; Stack&lt;Integer&gt; help = new Stack&lt;Integer&gt;(); while (!stack.isEmpty()) &#123; int cur = stack.pop(); while (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) &#123; stack.push(help.pop()); &#125; help.push(cur); &#125; while (!help.isEmpty()) &#123; stack.push(help.pop()); &#125;&#125; 6，用栈解决汉诺塔问题题目：经典的汉诺塔问题，现在增加限制，不能从最左侧的塔直接移动到最右侧，也不能从最右侧的塔直接移动到最左侧，而是必须经过中间。递归的方法代码如下。 1234567891011121314151617181920212223242526272829303132333435363738public static int hanoiProblem1(int num, String left, String mid, String right) &#123; if (num &lt; 1) &#123; return 0; &#125; return process(num, left, mid, right, left, right);&#125;public static int process(int num, String left, String mid, String right, String from, String to) &#123; if (num == 1) &#123; if (from.equals(mid) || to.equals(mid)) &#123; System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + to); return 1; &#125; else &#123; System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + mid); System.out.println(&quot;Move 1 from &quot; + mid + &quot; to &quot; + to); return 2; &#125; &#125; if (from.equals(mid) || to.equals(mid)) &#123; String another = (from.equals(left) || to.equals(left)) ? right : left; int part1 = process(num - 1, left, mid, right, from, another); int part2 = 1; System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + to); int part3 = process(num - 1, left, mid, right, another, to); return part1 + part2 + part3; &#125; else &#123; int part1 = process(num - 1, left, mid, right, from, to); int part2 = 1; System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + mid); int part3 = process(num - 1, left, mid, right, to, from); int part4 = 1; System.out.println(&quot;Move &quot; + num + &quot; from &quot; + mid + &quot; to &quot; + to); int part5 = process(num - 1, left, mid, right, from, to); return part1 + part2 + part3 + part4 + part5; &#125;&#125; 非递归的方法代码如下。 123456789101112131415161718192021222324252627282930313233343536public static enum Action &#123; No, LToM, MToL, MToR, RToM&#125;public static int hanoiProblem2(int num, String left, String mid, String right) &#123; Stack&lt;Integer&gt; lS = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; mS = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; rS = new Stack&lt;Integer&gt;(); lS.push(Integer.MAX_VALUE); mS.push(Integer.MAX_VALUE); rS.push(Integer.MAX_VALUE); for (int i = num; i &gt; 0; i--) &#123; lS.push(i); &#125; Action[] record = &#123; Action.No &#125;; int step = 0; while (rS.size() != num + 1) &#123; step += fStackTotStack(record, Action.MToL, Action.LToM, lS, mS, left, mid); step += fStackTotStack(record, Action.LToM, Action.MToL, mS, lS, mid, left); step += fStackTotStack(record, Action.RToM, Action.MToR, mS, rS, mid, right); step += fStackTotStack(record, Action.MToR, Action.RToM, rS, mS, right, mid); &#125; return step;&#125;public static int fStackTotStack(Action[] record, Action preNoAct, Action nowAct, Stack&lt;Integer&gt; fStack, Stack&lt;Integer&gt; tStack, String from, String to) &#123; if (record[0] != preNoAct &amp;&amp; fStack.peek() &lt; tStack.peek()) &#123; tStack.push(fStack.pop()); System.out.println(&quot;Move &quot; + tStack.peek() + &quot; from &quot; + from + &quot; to &quot; + to); record[0] = nowAct; return 1; &#125; return 0;&#125; 7，生成窗口最大值，有一个整型数组arr和一个大小为w的窗口从数组的最左边滑动到最右边，窗口每次向右滑动一个位置。例如，数组为[4,3,5,4,3,3,6,7]，当窗口大小为3时，[4,3,5,]4,3,3,6,7 窗口内最大值为54,[3,5,4,]3,3,6,7 窗口内最大值为54,3,[5,4,3,]3,6,7 窗口内最大值为54,3,5,[4,3,3,]6,7 窗口内最大值为44,3,5,4,[3,3,6,]7 窗口内最大值为64,3,5,4,3,[3,6,7] 窗口内最大值为7总共产生 n-w+1 个窗口最大值(n:数组长度，w：窗口大小)，实现一个函数：1，输入：整型数组arr，窗口大小为w。2，输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。本题的输出结果应该为{5，5，5，4，6，7}。解题思路：用双端队列来实现窗口最大值的更新，首先生成双端队列，qmax，qmax中存放数组arr中的下标。假设遍历到arr[i]，qmax的放入规则为：1，若qmax为空，直接把下标i放进qmax，放入过程结束。2，若qmax不为空，取出当前qmax队尾存放的下标，假设为i：1）若arr[j]&gt;arr[i]，直接把下标i存放进qmax的队尾，放入过程结束。2) 若arr[j]&lt;=arr[i]，把j从qmax中弹出，继续qmax的放入规则。假设遍历到arr[i]，qmax的弹出规则为：如果qmax队头的下标等于i-w，说明当前qmax队头的下标已过期，弹出当前队头的下标即可。根据如上的放入和弹出规则，qmax便成了一个维护窗口为w的子数组的最大值更新的结构。下面举例说明题目给出的例子。1，开始时qmax为空，qmax={}2，遍历到arr[0]==4，将下标0放入qmax，qmax={0}3，遍历到arr[1]==3，当前qmax的队尾下标为0，又有arr[0]&gt;arr[1]，所以将下标1放入qmax的尾部，qmax={0,1}4，遍历到arr[2]==5，当前qmax队尾下标为1，arr[1] 123456789101112131415161718192021public static int[] getMaxWindow(int[] arr, int w) &#123; if (arr == null || w &lt; 1 || arr.length &lt; w) &#123; return null; &#125; LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;Integer&gt;(); int[] res = new int[arr.length - w + 1]; int index = 0; for (int i = 0; i &lt; arr.length; i++) &#123; while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) &#123; qmax.pollLast(); &#125; qmax.addLast(i); if (qmax.peekFirst() == i - w) &#123; qmax.pollFirst(); &#125; if (i &gt;= w - 1) &#123; res[index++] = arr[qmax.peekFirst()]; &#125; &#125; return res;&#125; 代码如上。8，构造数组的MaxTree题目：定义二叉树结构如下： 123456789public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125;&#125; 一个数组的MaxTree定义如下：1),数组必须没有重复元素2),MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点3),包括MaxTree树在内且在其中的每一棵子树上，值最大的节点都是树的头给定一个没有重复元素的arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)，额外空间复杂度为O(n)。下面举例说明，比如arr={3,4,5,1,2};3的左边第一个比3大的数：无；3的左边第一个比3大的数：无；3的右边第一个比3大的数：4；4的左边第一个比4大的数：无；4的右边第一个比4大的数：5；5的左边第一个比5大的数：无；5的右边第一个比5大的数：无；1的左边第一个比1大的数：无；1的右边第一个比1大的数：2；2的左边第一个比1大的数：无；2的右边第一个比2大的数：无；用以下原则建立这颗树：1，每一个树的父节点是它左边第一个比他大的数和它右边第一个比它大的树中，较小的那个。2，如果一个数左边没有比它大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。怎么尽可能找到一个数左右两边第一个比它大的数呢？利用栈。找每一个数左边的第一个比它大的数，从左到右遍历每个数，栈中保持递减序列，新来的数不停地利用Pop出栈顶，直到栈顶比新数大或没有数。以[3,1,2]为例，3入栈，接下来1比3小，无须pop3，1入栈，确定了1左边第一个比他大的数为3，接下来2比1大，1出栈，2比3小，2入栈，并且确定了2左边第一个比它大的数是3。用同样的方法可以求出每一个数比它大的数。以下是getMaxTree代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static Node getMaxTree(int[] arr) &#123; Node[] nArr = new Node[arr.length]; for (int i = 0; i != arr.length; i++) &#123; nArr[i] = new Node(arr[i]); &#125; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); HashMap&lt;Node, Node&gt; lBigMap = new HashMap&lt;Node, Node&gt;(); HashMap&lt;Node, Node&gt; rBigMap = new HashMap&lt;Node, Node&gt;(); for (int i = 0; i != nArr.length; i++) &#123; Node curNode = nArr[i]; while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) &#123; popStackSetMap(stack, lBigMap); &#125; stack.push(curNode); &#125; while (!stack.isEmpty()) &#123; popStackSetMap(stack, lBigMap); &#125; for (int i = nArr.length - 1; i != -1; i--) &#123; Node curNode = nArr[i]; while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) &#123; popStackSetMap(stack, rBigMap); &#125; stack.push(curNode); &#125; while (!stack.isEmpty()) &#123; popStackSetMap(stack, rBigMap); &#125; Node head = null; for (int i = 0; i != nArr.length; i++) &#123; Node curNode = nArr[i]; Node left = lBigMap.get(curNode); Node right = rBigMap.get(curNode); if (left == null &amp;&amp; right == null) &#123; head = curNode; &#125; else if (left == null) &#123; if (right.left == null) &#123; right.left = curNode; &#125; else &#123; right.right = curNode; &#125; &#125; else if (right == null) &#123; if (left.left == null) &#123; left.left = curNode; &#125; else &#123; left.right = curNode; &#125; &#125; else &#123; Node parent = left.value &lt; right.value ? left : right; if (parent.left == null) &#123; parent.left = curNode; &#125; else &#123; parent.right = curNode; &#125; &#125; &#125; return head;&#125;public static void popStackSetMap(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map) &#123; Node popNode = stack.pop(); if (stack.isEmpty()) &#123; map.put(popNode, null); &#125; else &#123; map.put(popNode, stack.peek()); &#125;&#125; 以上是代码。9，求最大子矩阵的大小题目：给定一个整型矩阵map，值只有1和0，求全是1的所有矩形区域中，最大的矩形区域为1的数量。例如：1 1 1 0其中，最大的矩阵区域有3个1，所以返回3。思路：1，矩阵行数为n，以每一行为切割，统计以当前行作为底的情况下，每个位置往上的1的数量。使用高度数组height来表示。例如map =1 0 1 11 1 1 11 1 1 0以第一行切割，height={1,0,1,1}，以第二行切割，height={2,1,2,2}，以第三行切割，height={3,2,3,0}，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public static int maxRecSize(int[][] map) &#123; if (map == null || map.length == 0 || map[0].length == 0) &#123; return 0; &#125; int maxArea = 0; int[] height = new int[map[0].length]; for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; height[j] = map[i][j] == 0 ? 0 : height[j] + 1; &#125; maxArea = Math.max(maxRecFromBottom(height), maxArea); &#125; return maxArea;&#125;public static int maxRecFromBottom(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int maxArea = 0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; height.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; height[i] &lt;= height[stack.peek()]) &#123; int j = stack.pop(); int k = stack.isEmpty() ? -1 : stack.peek(); int curArea = (i - k - 1) * height[j]; maxArea = Math.max(maxArea, curArea); &#125; stack.push(i); &#125; while (!stack.isEmpty()) &#123; int j = stack.pop(); int k = stack.isEmpty() ? -1 : stack.peek(); int curArea = (height.length - k - 1) * height[j]; maxArea = Math.max(maxArea, curArea); &#125; return maxArea;&#125; 10，最大值减去最小值小于或等于num的子数组数量题目：给定数组arr和整数num，共返回有多少个子数组满足如下情况：max(arr[i..j]) - min(arr[i..j]) &lt;= nummax(arr[i..j])表示子数组arr[i..j]中的最大值，max(arr[i..j])表示子数组arr[i..j]中的最小值。要求：如果数组长度为n，时间复杂度为O(n)。思路：首先介绍普通解法，找到arr的所有子数组，一共有n的平方个，然后对每一个子数组做遍历找到其中的最小值和最大值，这个过程时间复杂度为O(n)，然后看子数组是否是满足条件。统计所有满足的子数组数量即可。普通解法时间复杂度是O(nnn)，本书不再详述。而最优解可以做到O(n)，在阅读下面的分析过程之前，先阅读本章的”生成窗口最大值数组”问题，本题所使用到的双端队列结构与解决”生成窗口最大值数组”问题中双端队列结构含义基本一致。生成两个双端队列qmax和qmin。当子数组为arr[i..j]时，qmax维护了窗口子数组arr[i..j]的最大值更新的结构，qmin维护了窗口子数组arr[i..j]的最小值更新的结构。当子数组arr[i..j]向右扩一个位置变成arr[i..j+1]时，qmax和qmin结构可以在O(1)时间内更新，并且可以在O(1)时间内得到arr[i..j+1]的最大值和最小值。当子数组arr[i..j]向左缩一个位置变成arr[i+1..j]时，qmax和qmin结构依然可以在O(1)时间内更新，并且在O(1)时间内得到arr[i+1..j]的最大值和最小值。通过分析题目满足的条件，可以得到如下两个结论：1)，如果子数组arr[i..j]满足条件，即max(arr[i..j]) - min(arr[i..j]) &lt;= num,那么arr[i..j]中的每一个子数组，即arrk..l都满足条件。我们以子数组arr[i..j-1]为例说明，arr[i..j-1]最大值只可能小于或等于arr[i..j]的最大值，arr[i..j]的最小值只可能大于或等于arr[i..j]的最小值，所以arr[i..j-1]必然满足条件。同理，arr[i..j]中的每一个子数组都满足条件。2),如果子数组不满足条件，那么所有包含arr[i..j]的子数组，即arrk..l都不满足条件。证明过程同第一个结论。根据双端队列的qmax和qmin的结构性质，以及如上两个结论，设计整个过程如下：1),生成两个双端队列qmax和qmin，含义如上文所说。生成两个整型变量i和j，表示子数组的范围，即arr[i..j]。生成整型变量res,表示所有满足条件的子数组数量。2),令j不断向右移动(j++)，表示arr[i..j]一直向右扩大，并不断更新qmax和qmin结构，保证qmax和qmin始终维持动态窗口最大值和最小值的更新结构。一旦出现arr[i..j]不满足条件的情况，j向右扩的过程停止，此时arr[i..j-1]、arr[i..i-2]、arr[i..j-3]、…、arr[i..i]一定都是满足条件的。也就是说，所有必须以arr[i]作为第一个元素的子数组，满足条件的数量为j-1个。于是令res+=j-1。3),当进行完步骤2时，令i向右移动一个位置，并对qmax和qmin做出相应的更新，qmax和qmin从原来的arr[[i..j]窗口变成arr[i+1..j]窗口的最大值和最小值的更新结构。然后重复步骤2，也就是求所有必须以arr[i+1]作为第一个元素的子数组中，满足条件的数量有多少个。4),根据步骤2和步骤3，依次求出以arr[0]、arr[1]、…、arr[n-1]作为第一个元素的子数组中满足条件的数量分别有多少个，累加起来的数量就是最终的结果。上述过程中，所有的下标值最多进qmax和qmin一次，出qmax和qmin一次。i和j的值也不断增加，并且从来不减小。所以整个过程的时间复杂度为O(n)。最优解请看如下代码的getNum方法： \ 1234567891011121314151617181920212223242526272829303132333435public static int getNum(int[] arr, int num) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; LinkedList&lt;Integer&gt; qmin = new LinkedList&lt;Integer&gt;(); LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;Integer&gt;(); int i = 0; int j = 0; int res = 0; while (i &lt; arr.length) &#123; while (j &lt; arr.length) &#123; while (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[j]) &#123; qmin.pollLast(); &#125; qmin.addLast(j); while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[j]) &#123; qmax.pollLast(); &#125; qmax.addLast(j); if (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; num) &#123; break; &#125; j++; &#125; if (qmin.peekFirst() == i) &#123; qmin.pollFirst(); &#125; if (qmax.peekFirst() == i) &#123; qmax.pollFirst(); &#125; res += j - i; i++; &#125; return res;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
</search>
